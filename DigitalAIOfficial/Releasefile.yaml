# Exported from:        http://DESKTOP-9S08TE1:5516/
# Release version:      24.1.2
# Date created:         Thu Jan 09 18:02:25 IST 2025

---
apiVersion: xl-release/v1
kind: Templates
metadata:
  home: Digital.ai - Official
spec:
- directory: Workflows
  children:
  - directory: DORA
    children:
    - template: Setup Release Folders and Variables
      description: Setup Folders in Digital.ai Release and create variables within
        the folders.
      scheduledStartDate: 2024-02-20T09:00:00+05:30
      dueDate: 2024-02-20T10:00:00+05:30
      phases:
      - phase: Setup folders and variables
        tasks:
        - name: Specify RunAs user
          type: xlrelease.UserInputTask
          description: Specify the Run as user credentials which will be used to run
            the workflow. All automated tasks will be run as this user.
          variables:
          - runAsUsername
          - runAsUserPassword
        - name: Specify Folder Names and Variables
          type: xlrelease.UserInputTask
          description: Specify the folder names and the varibles to be created within
            them.
          variables:
          - foldersToCreate
          - folderVariablesMap
        - name: Create Folders and Variables
          type: xlrelease.ScriptTask
          description: This automated script task creates the specified folders one
            within the other in the given sequence and also creates the list of variables
            specified against each folder.
          script: |-
            from com.xebialabs.xlrelease.domain.folder import Folder
            from com.xebialabs.xlrelease.api.v1.forms import Variable
            import java.lang.RuntimeException
            import json

            parentFolderId = "Applications"
            folder_var_map = ${folderVariablesMap}

            folders = "${foldersToCreate}".split("/")

            for folderName in folders:
              folder = Folder()
              folder.setTitle(folderName)
              parentFolderId = folderApi.addFolder(parentFolderId, folder)
              parentFolderId = str(parentFolderId.id)
              print("Folder created:%s"%(folderName))

              if folderName in folder_var_map:
                var_json_str = folder_var_map[folderName]
                variable_list = json.loads(var_json_str)
                for var_instance in variable_list:
                  key = var_instance['key']
                  if not key.startswith("folder."):
                    key = "folder.{}".format(var_instance['key'])
                  var_obj = Variable(key, var_instance['value'], False)
                  var_id = folderApi.createVariable(parentFolderId, var_obj)
                  print("Variable created:%s"%(key))
      kind: WORKFLOW
      categories:
      - Application onboarding
      variables:
      - type: xlrelease.StringVariable
        key: runAsUsername
        showOnReleaseStart: false
        label: Run automated tasks as user
        description: Run all automated tasks in this workflow as user
      - type: xlrelease.MapStringStringVariable
        key: folderVariablesMap
        showOnReleaseStart: false
        label: Folder Variables
        description: "Folder names against a JSON list of variable details. [{\"key\"\
          :\"name1\", \"value\":\"value1\"}, [{\"key\":\"name2\", \"value\":\"value2\"\
          }]"
        value:
          Folder1: "[{\"key\":\"var1\", \"value\":\"value1\"}]"
      - type: xlrelease.PasswordStringVariable
        key: runAsUserPassword
        showOnReleaseStart: false
        label: Password
        description: Password for automated tasks user
      - type: xlrelease.StringVariable
        key: foldersToCreate
        showOnReleaseStart: false
        label: Folders to create
        description: Folders will be created one within the other.
        value: Folder1/Folder2/Folder3
      disableNotifications: true
      scriptUsername: "${runAsUsername}"
      variableMapping:
        scriptUserPassword: "${runAsUserPassword}"
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/e0a83e68906c3fff6f2ebefaec7d6b5445ae521d/release.svg"
      defaultTargetFolder: ./Workflow Executions
  - directory: ArgoCD
    children:
    - template: Argo Rollouts install
      description: Install Argo Rollouts to Kubernetes cluster.
      scheduledStartDate: 2022-12-07T13:30:00+05:30
      dueDate: 2022-12-07T14:30:00+05:30
      phases:
      - phase: Check if Argo Rollouts is already installed
        tasks:
        - name: Input for Argo Rollouts installation
          type: xlrelease.UserInputTask
          description: Input for Kubernetes API server URL and Kubernetes namespace
            where ArgoCD will be installed.Please enter the required information below.
          variables:
          - kubernetesApiServer
          - namespace
        - name: Check if Argo Rollouts namespace exists
          type: kubernetes.ExistsNamespace
          description: "Checks if '${namespace}' namespace already exists. If it exists,\
            \ there will be a check performed if ArgoCD services already exist."
          variableMapping:
            server: "${kubernetesApiServer}"
            commandResponse: "${namespaceExistsResponse}"
          capabilities:
          - remote
          namespace: "${namespace}"
        - name: List all services in Argo Rollouts namespace
          type: kubernetes.ListServices
          description: |-
            If '${namespace}' namespace exists, this task will be skipped.
            Task lists all services and after that checks if there are any ArgoCD services.
          precondition: |-
            if releaseVariables['namespaceExistsResponse']['exists'] != 'false':
              result = True
            else:
              result = False
          variableMapping:
            server: "${kubernetesApiServer}"
            commandResponse: "${allServicesResponse}"
          capabilities:
          - remote
          namespace: "${namespace}"
        - name: Validate that Argo Rollouts services don't exist
          type: xlrelease.ScriptTask
          description: |-
            If '${namespace}' namespace exists, this task will be skipped.
            Task checks if there are any Argo Rollouts services in '${namespace}' namespace exist. If there are some, it means that Argo Rollouts is already installed and the release fails.
          precondition: |-
            if releaseVariables['namespaceExistsResponse']['exists'] == 'false':
              result = False
            else:
              result = True
          script: |-
            import json

            services = json.loads(releaseVariables['allServicesResponse']['services'])
            for service in services:
              if service.get('metadata', {}).get('name', '') == "argo-rollouts":
                raise Exception('Argo Rollouts is already installed in namespace ${namespace}')
        color: '#3d6c9e'
      - phase: Install Argo Rollouts
        tasks:
        - name: Create argo-rollouts namespace
          type: kubernetes.CreateNamespace
          description: "Creates '${namespace}' namespace."
          precondition: |-
            if releaseVariables['namespaceExistsResponse']['exists'] == 'false':
              result = True
            else:
              result = False
          variableMapping:
            server: "${kubernetesApiServer}"
          capabilities:
          - remote
          namespace: "${namespace}"
        - name: Apply Argo Rollouts installation on cluster
          type: kubernetes.Apply
          description: "Applies Argo Rollouts installation YAML on '${namespace}'\
            \ namespace."
          variableMapping:
            server: "${kubernetesApiServer}"
          capabilities:
          - remote
          namespace: argo-rollouts
          yamlLocation: https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml
        - name: Check status of pods in argo-rollouts namespace
          type: kubernetes.CheckPodStatus
          description: Performs check if all Argo Rollouts services are running successfully.
          variableMapping:
            server: "${kubernetesApiServer}"
            commandResponse: "${checkService}"
          capabilities:
          - remote
          namespace: "${namespace}"
          labelSelector: app.kubernetes.io/name=argo-rollouts
        color: '#3d6c9e'
      - phase: Create Argo Rollouts CI
        tasks:
        - name: Input for Argo Rollouts CI
          type: xlrelease.UserInputTask
          description: Please enter the required information below.
          precondition: |-
            if releaseVariables.has_key('checkService'):
              checkService = releaseVariables['checkService']
              if checkService.has_key('allRunning') and checkService['allRunning'] == 'true':
                result = True
              else:
                  raise Exception("Argo Rollouts services not running!")
          variables:
          - apiToken
          - usernameRollouts
          - argoRolloutsHost
        - name: Create Argo Rollouts CI
          type: xlrelease.ScriptTask
          script: '# todo implement when argo rollouts plugin is done'
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Application onboarding
      variables:
      - type: xlrelease.StringVariable
        key: namespace
        showOnReleaseStart: false
        label: Namespace
        description: Kubernetes namespace where Argo Rollouts will be installed
        value: argo-rollouts
      - type: xlrelease.ReferenceVariable
        key: kubernetesApiServer
        showOnReleaseStart: false
        label: Kubernetes API server
        description: Kubernetes API server where Argo Rollouts will be installed
        referencedType: kubernetes.APIServer
      - type: xlrelease.MapStringStringVariable
        key: namespaceExistsResponse
        requiresValue: false
        showOnReleaseStart: false
        label: namespaceExistsResponse
      - type: xlrelease.StringVariable
        key: argoRolloutsHost
        requiresValue: false
        showOnReleaseStart: false
        label: Argo Rollouts host
      - type: xlrelease.StringVariable
        key: usernameRollouts
        requiresValue: false
        showOnReleaseStart: false
        label: Username
        value: admin
      - type: xlrelease.StringVariable
        key: apiToken
        requiresValue: false
        showOnReleaseStart: false
        label: API token
      - type: xlrelease.MapStringStringVariable
        key: checkService
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.MapStringStringVariable
        key: allServicesResponse
        requiresValue: false
        showOnReleaseStart: false
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/png
        file: !file "template-logo/5a53e5d8988b3578428f22a4d91a98666309576c/argocd.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: ArgoCD delete application
      description: Delete Application in ArgoCD.
      scheduledStartDate: 2023-04-27T18:30:00+05:30
      dueDate: 2023-04-27T19:30:00+05:30
      phases:
      - phase: Delete Application in ArgoCD
        tasks:
        - name: Application Details
          type: xlrelease.UserInputTask
          description: Please enter the required information below.
          variables:
          - projectDetails
          - argoCDApiServer
          - applicationName
        - name: Delete Application in ArgoCD
          type: argocd.RemoveApplication
          variableMapping:
            server: "${argoCDApiServer}"
          capabilities:
          - remote
          applicationName: "${applicationName}"
        - name: Delete Application in Release
          type: managedApplications.DeleteApplication
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Application onboarding
      variables:
      - type: xlrelease.StringVariable
        key: applicationName
        showOnReleaseStart: false
        label: Application Name
        description: Application name to delete from ArgoCD
      - type: xlrelease.StringVariable
        key: projectDetails
        showOnReleaseStart: false
        label: Project Details
        description: Name of the project in ArgoCD where the Application is mapped
          to
        value: default
      - type: xlrelease.ReferenceVariable
        key: argoCDApiServer
        showOnReleaseStart: false
        label: ArgoCD API server
        description: ArgoCD Api Server connection details
        referencedType: argocd.APIServer
      - type: xlrelease.StringVariable
        key: managedApplicationId
        requiresValue: false
        showOnReleaseStart: false
        label: Application ID
        description: "Application ID in Digital.ai Release. For autocomplete, if folder\
          \ is empty, release/workflow execution folder will be used"
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/png
        file: !file "template-logo/294bb337f3c01e140e17f349ae87bd505055411e/argocd.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: ArgoCD install
      description: Install ArgoCD on Kubernetes cluster for deploying an Application
        in no time.
      scheduledStartDate: 2022-12-07T13:30:00+05:30
      dueDate: 2022-12-07T14:30:00+05:30
      phases:
      - phase: Check if ArgoCD is already installed
        tasks:
        - name: Input for ArgoCD installation
          type: xlrelease.UserInputTask
          description: Input for Kubernetes API server URL and Kubernetes namespace
            where ArgoCD will be installed.
          variables:
          - kubernetesApiServer
          - namespace
        - name: Check if ArgoCD namespace exists
          type: kubernetes.ExistsNamespace
          description: "Checks if '${namespace}' namespace already exists. If it exists,\
            \ there will be a check performed if ArgoCD services already exist."
          variableMapping:
            server: "${kubernetesApiServer}"
            commandResponse: "${argoCDNamespaceExistsResponse}"
          capabilities:
          - remote
          namespace: "${namespace}"
        - name: List all services in ArgoCD namespace
          type: kubernetes.ListServices
          description: |-
            If '${namespace}' namespace exists, this task will be skipped.
            Task lists all services and after that checks if there are any ArgoCD services.
          precondition: |-
            if releaseVariables['argoCDNamespaceExistsResponse']['exists'] != 'false':
              result = True
            else:
              result = False
          variableMapping:
            server: "${kubernetesApiServer}"
            commandResponse: "${allServicesResponse}"
          capabilities:
          - remote
          namespace: "${namespace}"
        - name: Validate that ArgoCD services don't exist
          type: xlrelease.ScriptTask
          description: |-
            If '${namespace}' namespace exists, this task will be skipped.
            Task checks if there are any ArgoCD services in '${namespace}' namespace exist. If there are some, it means that ArgoCD is already installed and the release fails.
          precondition: |-
            if releaseVariables['argoCDNamespaceExistsResponse']['exists'] == 'false':
              result = False
            else:
              result = True
          script: |-
            import json

            services = json.loads(releaseVariables['allServicesResponse']['services'])
            for service in services:
              if service.get('metadata', {}).get('name', '') == "argocd-server":
                raise Exception('ArgoCD is already installed in namespace ${namespace}')
        color: '#3d6c9e'
      - phase: Install ArgoCD
        tasks:
        - name: Create ArgoCD namespace
          type: kubernetes.CreateNamespace
          description: "Creates '${namespace}' namespace."
          precondition: |-
            if releaseVariables['argoCDNamespaceExistsResponse']['exists'] != 'false':
              result = False
            else:
              result = True
          variableMapping:
            server: "${kubernetesApiServer}"
          capabilities:
          - remote
          namespace: "${namespace}"
        - name: Apply ArgoCD installation on cluster
          type: kubernetes.Apply
          description: "Applies ArgoCD installation YAML on '${namespace}' namespace."
          variableMapping:
            server: "${kubernetesApiServer}"
          capabilities:
          - remote
          namespace: "${namespace}"
          yamlLocation: https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
        - name: Check status of pods in ArgoCD namespace
          type: kubernetes.CheckPodStatus
          description: Performs check if all ArgoCD services are running successfully.
          variableMapping:
            server: "${kubernetesApiServer}"
            commandResponse: "${checkServiceResponse}"
          capabilities:
          - remote
          namespace: "${namespace}"
          labelSelector: app.kubernetes.io/name=argocd-server
        color: '#3d6c9e'
      - phase: Create CIs for live deployment
        tasks:
        - name: Fetch secret
          type: kubernetes.GetSecret
          description: Fetches initial ArgoCD dashboard admin password.
          precondition: |-
            if releaseVariables['checkServiceResponse']['allRunning'] == 'true':
              result = True
            else:
                raise Exception("ArgoCD services not running!")
          variableMapping:
            secureResponse: "${argoCDSecret}"
            server: "${kubernetesApiServer}"
          capabilities:
          - remote
          namespace: "${namespace}"
          secretName: argocd-initial-admin-secret
          dataField: password
        - name: Input for ArgoCD CI
          type: xlrelease.UserInputTask
          description: Input for ArgoCD API server title and host URL for the CI that
            will be created.
          variables:
          - argoCDServerTitle
          - argoCDHost
        - name: Create ArgoCD live deployment CIs
          type: xlrelease.ScriptTask
          description: |-
            Creates ArgoCD API server CI with given title and host.
            Also, authentication is set to basic with admin username and initial password.
            For live deployment, webhook endpoint and event source are created.
          script: |-
            import base64
            import uuid

            from com.xebialabs.deployit.plugin.api.reflect import Type

            server = Type.valueOf("argocd.APIServer").getDescriptor().newInstance("argocd-server")

            server.setProperty("folderId", release.findFolderId())
            server.setProperty("title", releaseVariables['argoCDServerTitle'])
            server.setProperty("url", releaseVariables['argoCDHost'])
            server.setProperty("authenticationMethod", "Basic")
            server.setProperty("username", "admin")

            # Set password
            server.setProperty("password", "${argoCDSecret}")

            # Set default values
            server.setProperty("cardinality", 1)
            server.setProperty("proxyHost", "")
            server.setProperty("proxyPort", "")
            server.setProperty("proxyUsername", "")
            server.setProperty("proxyDomain", "")

            # Add ArgoCD API server
            configurationApi.addConfiguration(server)

            # Add webhook endpoint
            authentication = Type.valueOf("events.NoAuthentication").getDescriptor().newInstance("no-authentication")

            endpoint = Type.valueOf("events.PostWebhookEndpoint").getDescriptor().newInstance("post-webhook-endpoint")
            endpoint.setProperty("folderId", release.findFolderId())
            endpoint.setProperty("title", releaseVariables['argoCDServerTitle'])
            endpoint.setProperty("path", "path-" + str(uuid.uuid4()))
            endpoint.setProperty("authentication", authentication)

            configurationApi.addConfiguration(endpoint)

            # Add event source
            eventSource = Type.valueOf("argo.StatusWebhookEventSource").getDescriptor().newInstance("status-event-webhook")
            eventSource.setProperty("folderId", release.findFolderId())
            eventSource.setProperty("title", releaseVariables['argoCDServerTitle'])
            eventSource.setProperty("eventSource", endpoint)
            eventSource.setProperty("sourceServer", server)
            eventSource.setProperty("filteredFolders", ["default"])

            configurationApi.addConfiguration(eventSource)
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Infrastructure Service
      - Application onboarding
      - Application Life Cycle Management
      variables:
      - type: xlrelease.StringVariable
        key: namespace
        showOnReleaseStart: false
        label: Namespace
        description: Kubernetes namespace where ArgoCD will be installed
        value: argocd
      - type: xlrelease.ReferenceVariable
        key: kubernetesApiServer
        showOnReleaseStart: false
        label: Kubernetes API server
        description: Kubernetes API server where ArgoCD will be installed
        referencedType: kubernetes.APIServer
      - type: xlrelease.MapStringStringVariable
        key: allServicesResponse
        requiresValue: false
        showOnReleaseStart: false
        value:
          services: "[]"
      - type: xlrelease.MapStringStringVariable
        key: argoCDNamespaceExistsResponse
        requiresValue: false
        showOnReleaseStart: false
        value:
          exists: "false"
      - type: xlrelease.MapStringStringVariable
        key: checkServiceResponse
        requiresValue: false
        showOnReleaseStart: false
        value:
          allRunning: "false"
      - type: xlrelease.StringVariable
        key: argoCDHost
        showOnReleaseStart: false
        label: ArgoCD API Server Host
        description: URL to the base of the API Server
      - type: xlrelease.StringVariable
        key: argoCDServerTitle
        showOnReleaseStart: false
        label: ArgoCD API Server Title
        description: Connection title of ArgoCD API Server in Release
      - type: xlrelease.PasswordStringVariable
        key: argoCDSecret
        requiresValue: false
        showOnReleaseStart: false
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/png
        file: !file "template-logo/c0856b35d61d93a77538ebb1a25caf04a8839599/argocd.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: ArgoCD setup application
      description: "Create an application in ArgoCD that can be deployed to Kubernetes\
        \ cluster, with initial deployment"
      scheduledStartDate: 2022-12-13T13:30:00+05:30
      dueDate: 2022-12-13T14:30:00+05:30
      phases:
      - phase: Check if application exists
        tasks:
        - name: Check if remote runner exists
          type: xlrelease.ScriptTask
          script: |-
            def check_runners(runners):
              for runner in runners:
                if runner["enabled"] and "remote" in runner["capabilities"]:
                  return True
              return False

            runners = configurationApi.searchByTypeAndTitle("xlrelease.JobRunner", "")

            if not check_runners(runners):
              raise Exception("There is no job runner with 'remote' capability enabled")
        - name: Application input
          type: xlrelease.UserInputTask
          description: Input for application information together with the ArgoCD
            server
          variables:
          - argoCDApiServer
          - gitRepo
          - path
          - revision
          - chart
          - clusterUrl
        - name: Check if application exists
          type: argocd.CheckIfApplicationExists
          description: |-
            This is an automated task that checks whether an application already exists on the server based on the details provided.

            If the application does not exist, the task will be completed and the workflow will proceed to the next task.

            However, if the application already exists, the task will fail, and the workflow will be aborted. This is to prevent creating duplicate applications and ensure the proper functioning of the Argo CD Server.
          variableMapping:
            server: "${argoCDApiServer}"
            commandResponse: "${applicationExistsResponse}"
          capabilities:
          - remote
          gitRepo: "${gitRepo}"
          path: "${path}"
          branch: "${revision}"
          clusterUrl: "${clusterUrl}"
        color: '#3d6c9e'
      - phase: Check if namespace exists
        tasks:
        - name: Namespace input
          type: xlrelease.UserInputTask
          description: |-
            This task involves providing the namespace in which the application will be deployed and run from. Additionally, you will need to provide the Kubernetes API server to connect to for deploying and managing the application.

            If you do not provide a namespace, the task will use the default value. Please ensure that the provided namespace is valid and appropriate for your application
          precondition: |-
            import json

            if releaseVariables["applicationExistsResponse"]["exists"] == "true":
              raise Exception("Application app already exists!")

            result = True
          variables:
          - kubernetesApiServer
          - namespace
        - name: Check if namespace exists
          type: kubernetes.ExistsNamespace
          description: "Checks if '${namespace}' namespace already exists."
          variableMapping:
            server: "${kubernetesApiServer}"
            commandResponse: "${namespaceExistsResponse}"
          capabilities:
          - remote
          namespace: "${namespace}"
        color: '#3d6c9e'
      - phase: Create namespace
        tasks:
        - name: Create namespace
          type: kubernetes.CreateNamespace
          description: "Creates the ${namespace} namespace. If it already exists,\
            \ this task is skipped."
          precondition: |-
            import json

            result = (releaseVariables["namespaceExistsResponse"]["exists"] != "true")
          variableMapping:
            server: "${kubernetesApiServer}"
          capabilities:
          - remote
          namespace: "${namespace}"
        color: '#3d6c9e'
      - phase: Create ArgoCD application
        tasks:
        - name: Application information input
          type: xlrelease.UserInputTask
          description: Application name and ArgoCD project.
          variables:
          - applicationName
          - projectName
          - environmentTag
          - managedBy
          - repoAccess
          - autoSync
        - name: Repository authentication input
          type: xlrelease.UserInputTask
          description: Please enter the required information below.
          precondition: |-
            import json

            if releaseVariables["repoAccess"] == "private":
              result = True
            else:
              result = False
          variables:
          - repoUsername
          - repoPassword
          - repoName
          - enableLfs
          - enableOCI
          - gitEnterpriseURL
          - gitAppID
          - gitAppInstallationID
          - gitAppPrivateKey
          - inheritedCreds
          - insecure
          - insecureIgnoreHostKey
          - project
          - proxy
          - sshPrivateKey
          - tlsData
          - tlsKey
        - name: Get repository details
          type: argocd.ListRepositories
          description: Please enter the required information below.
          variableMapping:
            server: "${argoCDApiServer}"
            commandResponse: "${repositoryListResponse}"
          capabilities:
          - remote
        - name: Create repository configuration
          type: argocd.CreateRepository
          precondition: |-
            import json
            repositoriesRelease = releaseVariables["repositoryListResponse"]["repositories"]
            repositories = json.loads(repositoriesRelease)

            result = True
            if (repositories == None):
              result = True
            else:
              target_repo = releaseVariables["gitRepo"]
              result = not (any(repo['repo'] == target_repo for repo in repositories))
          variableMapping:
            enableLfs: "${enableLfs}"
            server: "${argoCDApiServer}"
            password: "${repoPassword}"
            insecure: "${insecure}"
            insecureIgnoreHostKey: "${insecureIgnoreHostKey}"
            inheritedCreds: "${inheritedCreds}"
            enableOCI: "${enableOCI}"
          capabilities:
          - remote
          repo: "${gitRepo}"
          username: "${repoUsername}"
          repoName: "${repoName}"
          githubAppEnterpriseBaseUrl: "${gitEnterpriseURL}"
          githubAppID: "${gitAppID}"
          githubAppInstallationID: "${gitAppInstallationID}"
          githubAppPrivateKey: "${gitAppPrivateKey}"
          project: "${project}"
          proxy: "${proxy}"
          sshPrivateKey: "${sshPrivateKey}"
          tlsClientCertData: "${tlsData}"
          tlsClientCertKey: "${tlsKey}"
        - name: ArgoCD application configuration input
          type: xlrelease.UserInputTask
          description: Labels & sync policies.
          variables:
          - prune
          - selfHeal
          - skipSchemaValidation
          - pruneLast
          - autoCreateNamespace
          - applyOutOfSyncOnly
          - prunePropagationPolicy
          - replace
        - name: Create ArgoCD application
          type: argocd.CreateApplication
          description: "Deploys ArgoCD application with given information about application\
            \ name, project, git repo, path and branch."
          variableMapping:
            skipValidation: "${skipSchemaValidation}"
            server: "${argoCDApiServer}"
            replace: "${replace}"
            autoSync: "${autoSync}"
            autoCreateNamespace: "${autoCreateNamespace}"
            pruneLast: "${pruneLast}"
            prunePropagationPolicy: "${prunePropagationPolicy}"
            pruneResources: "${prune}"
            selfHeal: "${selfHeal}"
            applyOutOfSyncOnly: "${applyOutOfSyncOnly}"
          capabilities:
          - remote
          appName: "${applicationName}"
          project: "${projectName}"
          url: "${gitRepo}"
          path: "${path}"
          chart: "${chart}"
          revision: "${revision}"
          namespace: "${namespace}"
        color: '#3d6c9e'
      - phase: Get application status
        tasks:
        - name: Sync application
          type: argocd.SyncApplication
          precondition: |-
            import json

            if releaseVariables["autoSync"] == False:
              result = True
            else:
              result = False
          variableMapping:
            server: "${argoCDApiServer}"
          capabilities:
          - remote
          applicationName: "${applicationName}"
        - name: Get application status
          type: argocd.CheckApplicationStatus
          description: Checks if application is successfully deployed.
          variableMapping:
            server: "${argoCDApiServer}"
          capabilities:
          - remote
          applicationName: "${applicationName}"
        color: '#3d6c9e'
      - phase: Create Managed Application
        tasks:
        - name: Create managed application
          type: managedApplications.CreateApplication
          applicationName: "${applicationName}"
          managedBy: "${managedBy}"
          environmentTag: "${environmentTag}"
          applicationReference: "${clusterUrl}"
          variableMapping:
            pythonScript.managedApplicationId: "${managedApplicationId}"
            pythonScript.connectionServer: "${argoCDApiServer}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Application onboarding
      variables:
      - type: xlrelease.MapStringStringVariable
        key: applicationExistsResponse
        requiresValue: false
        showOnReleaseStart: false
        value:
          exists: "false"
      - type: xlrelease.MapStringStringVariable
        key: namespaceExistsResponse
        requiresValue: false
        showOnReleaseStart: false
        value:
          exists: "false"
      - type: xlrelease.StringVariable
        key: gitRepo
        showOnReleaseStart: false
        label: Git Repo
        description: Git repository from where application configuration will be fetched
      - type: xlrelease.StringVariable
        key: path
        showOnReleaseStart: false
        label: Path
        description: Path inside git repository where configuration is located
      - type: xlrelease.StringVariable
        key: revision
        showOnReleaseStart: false
        label: Revision
        description: "Git - can be commit, tag, or branch. Helm - a semver tag for\
          \ the Chart's version"
        value: HEAD
      - type: xlrelease.StringVariable
        key: chart
        requiresValue: false
        label: Helm chart
        description: Helm chart name
      - type: xlrelease.StringVariable
        key: clusterUrl
        showOnReleaseStart: false
        label: Cluster url
        description: Kubernetes cluster URL
        value: https://kubernetes.default.svc
      - type: xlrelease.StringVariable
        key: namespace
        showOnReleaseStart: false
        label: Namespace
        description: The Kubernetes namespace where application wll be deployed
        value: default
      - type: xlrelease.StringVariable
        key: applicationName
        showOnReleaseStart: false
        label: Application name
        description: New application name in ArgoCD
      - type: xlrelease.StringVariable
        key: projectName
        showOnReleaseStart: false
        label: Project name
        description: ArgoCD project name
        value: default
      - type: xlrelease.ReferenceVariable
        key: kubernetesApiServer
        showOnReleaseStart: false
        label: Kubernetes API server
        description: Kubernetes API server where ArgoCD is installed
        referencedType: kubernetes.APIServer
      - type: xlrelease.ReferenceVariable
        key: argoCDApiServer
        showOnReleaseStart: false
        label: ArgoCD API server
        description: ArgoCD API server where application will be deployed
        referencedType: argocd.APIServer
      - type: xlrelease.StringVariable
        key: environmentTag
        showOnReleaseStart: false
        label: Environment tag
        description: Tag of the target environment
        value: PROD
      - type: xlrelease.StringVariable
        key: managedBy
        showOnReleaseStart: false
        label: Managed by
        description: "Marks how the application is managed, use Release value for\
          \ apps managed from Release"
        value: Release
      - type: xlrelease.StringVariable
        key: repoAccess
        showOnReleaseStart: false
        label: Repo access rights
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - public
          - private
      - type: xlrelease.StringVariable
        key: repoUsername
        requiresValue: false
        showOnReleaseStart: false
        label: Repo username
        description: This is required only if repository is private
      - type: xlrelease.PasswordStringVariable
        key: repoPassword
        requiresValue: false
        showOnReleaseStart: false
        label: Repo password
        description: This is required if private repository is password protected
      - type: xlrelease.StringVariable
        key: repoType
        requiresValue: false
        showOnReleaseStart: false
        label: Repo type
        description: Repo type
      - type: xlrelease.BooleanVariable
        key: autoSync
        requiresValue: false
        showOnReleaseStart: false
        label: Auto Sync
        description: Auto Sync application
      - type: xlrelease.StringVariable
        key: repoName
        requiresValue: false
        showOnReleaseStart: false
        label: Repo Name
        description: Repo Name
      - type: xlrelease.BooleanVariable
        key: enableLfs
        requiresValue: false
        showOnReleaseStart: false
        label: Enable Lfs
        description: Enable Git Large File Storage
      - type: xlrelease.BooleanVariable
        key: enableOCI
        showOnReleaseStart: false
        label: Enable O C I
        description: Enable Oracle Cloud Infrastructure Repository
      - type: xlrelease.StringVariable
        key: gitEnterpriseURL
        requiresValue: false
        showOnReleaseStart: false
        label: Github App Enterprise Base Url
        description: Github App Enterprise Base Url
      - type: xlrelease.StringVariable
        key: gitAppID
        requiresValue: false
        showOnReleaseStart: false
        label: Github App ID
        description: Github App ID
      - type: xlrelease.StringVariable
        key: gitAppInstallationID
        requiresValue: false
        showOnReleaseStart: false
        label: Github App Installation I D
        description: Github App Installation I D
      - type: xlrelease.StringVariable
        key: gitAppPrivateKey
        requiresValue: false
        showOnReleaseStart: false
        label: Github App Private Key
        description: Github App Private Key
      - type: xlrelease.BooleanVariable
        key: inheritedCreds
        requiresValue: false
        showOnReleaseStart: false
        label: Inherited Creds
        description: Inherited Creds
      - type: xlrelease.BooleanVariable
        key: insecure
        requiresValue: false
        showOnReleaseStart: false
        label: Insecure
        description: Insecure
      - type: xlrelease.BooleanVariable
        key: insecureIgnoreHostKey
        requiresValue: false
        showOnReleaseStart: false
        label: Insecure Ignore Host Key
        description: Insecure Ignore Host Key
      - type: xlrelease.StringVariable
        key: project
        requiresValue: false
        showOnReleaseStart: false
        label: Project
        description: Project
      - type: xlrelease.StringVariable
        key: proxy
        requiresValue: false
        showOnReleaseStart: false
        label: Proxy
        description: Proxy
      - type: xlrelease.StringVariable
        key: sshPrivateKey
        requiresValue: false
        showOnReleaseStart: false
        label: Ssh Private Key
        description: Ssh Private Key
        multiline: true
      - type: xlrelease.StringVariable
        key: tlsData
        requiresValue: false
        showOnReleaseStart: false
        label: Tls Client Cert Data
        description: Tls Client Cert Data
        multiline: true
      - type: xlrelease.StringVariable
        key: tlsKey
        requiresValue: false
        showOnReleaseStart: false
        label: Tls Client Cert Key
        description: Tls Client Cert Key
        multiline: true
      - type: xlrelease.BooleanVariable
        key: prune
        requiresValue: false
        showOnReleaseStart: false
        label: Prune
        description: Prune specifies whether to delete resources from the cluster
          that are not found in the sources anymore as part of automated sync.
      - type: xlrelease.BooleanVariable
        key: selfHeal
        requiresValue: false
        showOnReleaseStart: false
        label: Self Heal
        description: SelfHeal specifies whether to revert resources back to their
          desired state upon modification in the cluster.
      - type: xlrelease.BooleanVariable
        key: skipSchemaValidation
        requiresValue: false
        showOnReleaseStart: false
        label: Skip schema validation
      - type: xlrelease.BooleanVariable
        key: pruneLast
        requiresValue: false
        showOnReleaseStart: false
        label: Prune last
      - type: xlrelease.BooleanVariable
        key: autoCreateNamespace
        requiresValue: false
        showOnReleaseStart: false
        label: Auto create namespace
      - type: xlrelease.BooleanVariable
        key: applyOutOfSyncOnly
        requiresValue: false
        showOnReleaseStart: false
        label: Apply out of sync only
      - type: xlrelease.StringVariable
        key: prunePropagationPolicy
        requiresValue: false
        showOnReleaseStart: false
        label: Prune Propagation Policy
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - foreground
          - background
          - orphan
        value: foreground
      - type: xlrelease.BooleanVariable
        key: replace
        requiresValue: false
        showOnReleaseStart: false
        label: Replace
        description: "Caution: Uses kubectl replace/create commands"
      - type: xlrelease.StringVariable
        key: deleteWorkflowId
        requiresValue: false
        showOnReleaseStart: false
        label: Delete Workflow CI ID
        description: CI ID of the the Delete Workflow to be triggered as delete action
          from managed applications (this is set by template)
      - type: xlrelease.StringVariable
        key: updateWorkflowId
        requiresValue: false
        showOnReleaseStart: false
        label: Update Workflow CI ID
        description: CI ID of the the Update Workflow to be triggered as edit action
          from managed applicationsScript (this is set by template)
      - type: xlrelease.MapStringStringVariable
        key: repositoryListResponse
        requiresValue: false
        showOnReleaseStart: false
        label: Command Response
        description: Command Response
      - type: xlrelease.StringVariable
        key: managedApplicationId
        requiresValue: false
        showOnReleaseStart: false
        label: Application ID
        description: Application ID in Digital.ai Release
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/png
        file: !file "template-logo/d2a28c9e0bee8b9a4c9e8628be10b987aa87b9f2/argocd.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: ArgoCD update application
      description: Update an application in ArgoCD
      scheduledStartDate: 2022-12-13T13:30:00+05:30
      dueDate: 2022-12-13T14:30:00+05:30
      phases:
      - phase: Application input
        tasks:
        - name: Check if remote runner exists
          type: xlrelease.ScriptTask
          script: |-
            def check_runners(runners):
              for runner in runners:
                if runner["enabled"] and "remote" in runner["capabilities"]:
                  return True
              return False

            runners = configurationApi.searchByTypeAndTitle("xlrelease.JobRunner", "")

            if not check_runners(runners):
              raise Exception("There is no job runner with 'remote' capability enabled")
        - name: General information input
          type: xlrelease.UserInputTask
          description: "Input for ArgoCD API Server, Cluster where the application\
            \ will be deployed (namespace will be chosen later) & existing application\
            \ name which needs to be updated."
          variables:
          - argoCDApiServer
          - clusterUrl
          - applicationName
          - projectName
          - environmentTag
          - managedBy
        - name: Git repository input
          type: xlrelease.UserInputTask
          description: "Git input fields. You can change the repository, path and\
            \ branch."
          variables:
          - gitRepo
          - path
          - revision
          - chart
        - name: Application information input
          type: xlrelease.UserInputTask
          description: Labels & sync policies.
          variables:
          - autoSync
          - prune
          - selfHeal
          - skipSchemaValidation
          - pruneLast
          - autoCreateNamespace
          - applyOutOfSyncOnly
          - prunePropagationPolicy
          - replace
        color: '#3d6c9e'
      - phase: Check if namespace exists
        tasks:
        - name: Namespace input
          type: xlrelease.UserInputTask
          description: |-
            This task involves providing the namespace in which the application will be deployed and run from. Additionally, you will need to provide the Kubernetes API server to connect to for deploying and managing the application.

            If you do not provide a namespace, the task will use the default value. Please ensure that the provided namespace is valid and appropriate for your application
          variables:
          - kubernetesApiServer
          - namespace
        - name: Check if namespace exists
          type: kubernetes.ExistsNamespace
          description: "Checks if '${namespace}' namespace already exists."
          variableMapping:
            server: "${kubernetesApiServer}"
            commandResponse: "${namespaceExistsResponse}"
          capabilities:
          - remote
          namespace: "${namespace}"
        color: '#3d6c9e'
      - phase: Create namespace
        tasks:
        - name: Create namespace
          type: kubernetes.CreateNamespace
          description: "Creates the ${namespace} namespace. If it already exists,\
            \ this task is skipped."
          precondition: |-
            import json

            result = (releaseVariables["namespaceExistsResponse"]["exists"] != "true")
          variableMapping:
            server: "${kubernetesApiServer}"
          capabilities:
          - remote
          namespace: "${namespace}"
        color: '#3d6c9e'
      - phase: Update ArgoCD application
        tasks:
        - name: Update ArgoCD application
          type: argocd.UpdateApplication
          variableMapping:
            skipValidation: "${skipSchemaValidation}"
            server: "${argoCDApiServer}"
            replace: "${replace}"
            autoSync: "${autoSync}"
            autoCreateNamespace: "${autoCreateNamespace}"
            pruneLast: "${pruneLast}"
            prunePropagationPolicy: "${prunePropagationPolicy}"
            pruneResources: "${prune}"
            selfHeal: "${selfHeal}"
            applyOutOfSyncOnly: "${applyOutOfSyncOnly}"
          capabilities:
          - remote
          appName: "${applicationName}"
          project: "${projectName}"
          url: "${gitRepo}"
          path: "${path}"
          chart: "${chart}"
          revision: "${revision}"
          cluster: "${clusterUrl}"
          namespace: "${namespace}"
        color: '#3d6c9e'
      - phase: Sync & Get status
        tasks:
        - name: Sync Application
          type: argocd.SyncApplication
          variableMapping:
            server: "${argoCDApiServer}"
          capabilities:
          - remote
          applicationName: "${applicationName}"
        - name: Get application status
          type: argocd.CheckApplicationStatus
          description: Checks if application is successfully updated.
          variableMapping:
            server: "${argoCDApiServer}"
          capabilities:
          - remote
          applicationName: "${applicationName}"
        color: '#3d6c9e'
      - phase: Update Managed Application
        tasks:
        - name: Update Application in Release
          type: managedApplications.UpdateApplication
          folderId: "${folderId}"
          applicationName: "${applicationName}"
          managedBy: "${managedBy}"
          environmentTag: "${environmentTag}"
          applicationReference: "${clusterUrl}"
          deleteWorkflowId: "${deleteWorkflowId}"
          updateWorkflowId: "${updateWorkflowId}"
          variableMapping:
            pythonScript.managedApplicationId: "${managedApplicationId}"
            pythonScript.connectionServer: "${argoCDApiServer}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Application onboarding
      variables:
      - type: xlrelease.MapStringStringVariable
        key: namespaceExistsResponse
        requiresValue: false
        showOnReleaseStart: false
        value:
          exists: "false"
      - type: xlrelease.StringVariable
        key: gitRepo
        showOnReleaseStart: false
        label: Git Repo
        description: The URL of the Git repository where the application's manifests
          are stored.
      - type: xlrelease.StringVariable
        key: path
        showOnReleaseStart: false
        label: Path
        description: The directory or path in the Git repository where the application's
          manifests are located.
      - type: xlrelease.StringVariable
        key: revision
        showOnReleaseStart: false
        label: Revision
        description: The revision or branch in the Git repository to use for this
          application. Defaults to the latest commit in the default branch (HEAD).
        value: HEAD
      - type: xlrelease.StringVariable
        key: chart
        requiresValue: false
        showOnReleaseStart: false
        label: Helm chart
        description: Helm chart name
      - type: xlrelease.StringVariable
        key: clusterUrl
        showOnReleaseStart: false
        label: Cluster url
        description: Kubernetes cluster URL where the application should be deployed.
        value: https://kubernetes.default.svc
      - type: xlrelease.StringVariable
        key: projectName
        showOnReleaseStart: false
        label: Project name
        description: ArgoCD project name
        value: default
      - type: xlrelease.StringVariable
        key: namespace
        showOnReleaseStart: false
        label: Namespace
        description: The Kubernetes namespace where the application should be deployed.
          Keeping the old value keeps the application in the same namespace.
        value: default
      - type: xlrelease.StringVariable
        key: applicationName
        showOnReleaseStart: false
        label: Application name
        description: Existing application name in ArgoCD. Cannot be updated.
      - type: xlrelease.ReferenceVariable
        key: kubernetesApiServer
        showOnReleaseStart: false
        label: Kubernetes API server
        description: Kubernetes API server where ArgoCD is installed
        referencedType: kubernetes.APIServer
      - type: xlrelease.ReferenceVariable
        key: argoCDApiServer
        showOnReleaseStart: false
        label: ArgoCD API server
        description: ArgoCD API server where application will be deployed
        referencedType: argocd.APIServer
      - type: xlrelease.BooleanVariable
        key: autoSync
        requiresValue: false
        showOnReleaseStart: false
        label: Auto Sync
        description: "Controls the behavior of an automated sync. If left false, default\
          \ policy will be manual sync."
      - type: xlrelease.BooleanVariable
        key: prune
        requiresValue: false
        showOnReleaseStart: false
        label: Prune
        description: Prune specifies whether to delete resources from the cluster
          that are not found in the sources anymore as part of automated sync.
      - type: xlrelease.BooleanVariable
        key: selfHeal
        requiresValue: false
        showOnReleaseStart: false
        label: Self Heal
        description: SelfHeal specifies whether to revert resources back to their
          desired state upon modification in the cluster.
      - type: xlrelease.BooleanVariable
        key: skipSchemaValidation
        requiresValue: false
        showOnReleaseStart: false
        label: Skip schema validation
      - type: xlrelease.BooleanVariable
        key: pruneLast
        requiresValue: false
        showOnReleaseStart: false
        label: Prune last
      - type: xlrelease.BooleanVariable
        key: autoCreateNamespace
        requiresValue: false
        showOnReleaseStart: false
        label: Auto create namespace
      - type: xlrelease.BooleanVariable
        key: applyOutOfSyncOnly
        requiresValue: false
        showOnReleaseStart: false
        label: Apply out of sync only
      - type: xlrelease.StringVariable
        key: prunePropagationPolicy
        requiresValue: false
        showOnReleaseStart: false
        label: Prune Propagation Policy
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - foreground
          - background
          - orphan
        value: foreground
      - type: xlrelease.BooleanVariable
        key: replace
        requiresValue: false
        showOnReleaseStart: false
        label: Replace
        description: "Caution: Uses kubectl replace/create commands"
      - type: xlrelease.StringVariable
        key: managedApplicationId
        showOnReleaseStart: false
        label: Managed Application ID
        description: "ID of the Managed Application, its value should come when running\
          \ workflow as edit action from managed applications."
      - type: xlrelease.StringVariable
        key: environmentTag
        showOnReleaseStart: false
        label: Environment Tag
        description: "Marks how the application is managed, use Release value for\
          \ apps managed from Release"
        value: PROD
      - type: xlrelease.StringVariable
        key: managedBy
        showOnReleaseStart: false
        label: Managed by
        description: "Marks how the application is managed, use Release value for\
          \ apps managed from Release"
      - type: xlrelease.StringVariable
        key: updateWorkflowId
        requiresValue: false
        showOnReleaseStart: false
        label: Update Workflow CI ID
        description: CI ID of the the Update Workflow to be triggered as edit action
          from managed applicationsScript (this is set by template)
      - type: xlrelease.StringVariable
        key: deleteWorkflowId
        requiresValue: false
        showOnReleaseStart: false
        label: Delete Workflow CI ID
        description: CI ID of the the Delete Workflow to be triggered as delete action
          from managed applications (this is set by template)
      - type: xlrelease.StringVariable
        key: folderId
        label: Managed Application Folder
        description: "Folder where Managed Application is or should be located, if\
          \ empty release/workflow execution folder will be used"
        value: Release
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/png
        file: !file "template-logo/ab0806d53b199b9f22f82195c9c934d80104442c/argocd.svg"
      defaultTargetFolder: ./Workflow Executions
  - directory: Terraform
    children:
    - template: Terraform manage infrastructure
      description: "Workflow provides the steps that create, update, or destroy infrastructure\
        \ in the cloud using Terraform."
      scheduledStartDate: 2023-09-15T09:00:00+05:30
      dueDate: 2023-09-15T10:00:00+05:30
      phases:
      - phase: Create|Destroy Infra
        tasks:
        - name: Git Repository Information
          type: xlrelease.UserInputTask
          description: Provide the Git Repository Information where the Terraform
            configuration files (.tf) are located.
          variables:
          - gitUrl
          - branch
          - gitDirPath
          - gitToken
        - name: Environment Variables and Values
          type: xlrelease.UserInputTask
          description: |-
            The environment variables that can be set to customize the Terraform execution environment. This can include cloud provider authentication credentials.

            Example for AWS :
            {'AWS_ACCESS_KEY_ID': 'Your value', 'AWS_SECRET_ACCESS_KEY': 'Your value', 'AWS_SESSION_TOKEN': 'Your value'}
          variables:
          - environmentVariables
        - name: Create or Update infrastructure ?
          type: xlrelease.UserInputTask
          description: Do you want to create or update infrastructure?
          variables:
          - isCreate
        - name: Execute Terraform Apply
          type: containerTerraform.Apply
          description: |-
            Automated task to execute the Terraform Apply command.
            It creates or updates infrastructure as defined in your Terraform configurations.
          precondition: "releaseVariables['isCreate']"
          variableMapping:
            gitToken: "${gitToken}"
            environmentVariables: "${environmentVariables}"
          capabilities:
          - remote
          gitUrl: "${gitUrl}"
          branch: "${branch}"
          gitDirPath: "${gitDirPath}"
        - name: Destroy Infrastructure?
          type: xlrelease.UserInputTask
          description: Do you want to destroy infrastructure?
          variables:
          - isDestroy
        - name: Execute Terraform Destroy
          type: containerTerraform.Destroy
          description: |-
            Automated task to execute the Terraform Destroy command.
            It destroys infrastructure as defined in your Terraform configurations.
          precondition: "releaseVariables['isDestroy']"
          variableMapping:
            gitToken: "${gitToken}"
            environmentVariables: "${environmentVariables}"
          capabilities:
          - remote
          gitUrl: "${gitUrl}"
          branch: "${branch}"
          gitDirPath: "${gitDirPath}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Infrastructure Service
      variables:
      - type: xlrelease.StringVariable
        key: gitUrl
        showOnReleaseStart: false
        label: Git URL
        description: Git URL is the web address of the Git repository with Terraform
          files
      - type: xlrelease.StringVariable
        key: branch
        requiresValue: false
        showOnReleaseStart: false
        label: Git Branch
        description: Git Branch is the specific branch in that repository
      - type: xlrelease.StringVariable
        key: gitDirPath
        requiresValue: false
        showOnReleaseStart: false
        label: Git Directory Path
        description: Git Directory Path is the folder location in the repository where
          Terraform files are stored
      - type: xlrelease.PasswordStringVariable
        key: gitToken
        requiresValue: false
        showOnReleaseStart: false
        label: Git Token
        description: Git Token is the password-like code needed to access private
          repositories
      - type: xlrelease.PasswordStringVariable
        key: environmentVariables
        showOnReleaseStart: false
        label: Environment Variables
        multiline: true
      - type: xlrelease.BooleanVariable
        key: isCreate
        showOnReleaseStart: false
        label: "Yes"
      - type: xlrelease.BooleanVariable
        key: isDestroy
        showOnReleaseStart: false
        label: "Yes"
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/47dd789165897e372cef52e7a932da3a769891bc/terraform.svg"
      defaultTargetFolder: ./Workflow Executions
  - directory: AWS
    children:
    - template: AWS Lambda create function using S3 zip file
      description: Workflow provides the steps that create an AWS Lambda Function
        using S3 zip file
      scheduledStartDate: 2023-09-20T09:00:00+05:30
      dueDate: 2023-09-20T10:00:00+05:30
      phases:
      - phase: New Phase
        tasks:
        - name: AWS Server Connection
          type: xlrelease.UserInputTask
          description: |-
            Select the AWS Server Connection and Provide the Region.
            You can create a new connection if you have not created one.
          variables:
          - host
          - region
        - name: AWS Lambda Function Details
          type: xlrelease.UserInputTask
          description: Provide the AWS Lambda Function Details to create.
          variables:
          - functionName
          - role
          - runtime
          - handler
        - name: S3 Bucket Details
          type: xlrelease.UserInputTask
          description: Provide the S3 Bucket Details for your deployment package.
          variables:
          - bucketName
          - objectKey
        - name: Create Lambda Function using S3 Zip
          type: containerAws.CreateFunctionS3Zip
          description: Automated task to create an AWS Lambda Function using S3 zip
            file.
          variableMapping:
            host: "${host}"
          capabilities:
          - remote
          region: "${region}"
          functionName: "${functionName}"
          bucketName: "${bucketName}"
          objectKey: "${objectKey}"
          runtime: "${runtime}"
          role: "${role}"
          handler: "${handler}"
      kind: WORKFLOW
      categories:
      - Infrastructure Service
      variables:
      - type: xlrelease.ReferenceVariable
        key: host
        showOnReleaseStart: false
        label: AWS Server
        description: AWS Server Connection
        referencedType: containerAws.Server
      - type: xlrelease.StringVariable
        key: region
        showOnReleaseStart: false
        label: AWS Region
        description: AWS region to use
      - type: xlrelease.StringVariable
        key: functionName
        showOnReleaseStart: false
        label: Function Name
        description: AWS lambda function name
      - type: xlrelease.StringVariable
        key: runtime
        showOnReleaseStart: false
        label: Runtime
        description: "The runtime environment for the Lambda function  Ex: python3.8"
      - type: xlrelease.StringVariable
        key: role
        showOnReleaseStart: false
        label: Role
        description: The Amazon Resource Name (ARN) of the IAM role
      - type: xlrelease.StringVariable
        key: handler
        showOnReleaseStart: false
        label: Handler
        description: The function within your code that Lambda calls to begin execution
      - type: xlrelease.StringVariable
        key: bucketName
        showOnReleaseStart: false
        label: Bucket Name
        description: AWS S3 bucket name where the .zip file containing your deployment
          package is stored
      - type: xlrelease.StringVariable
        key: objectKey
        requiresValue: false
        label: S3 Object Key
        description: path/to/your/lambda-package.zip
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/f28a0ba7c764636bd747c3a1611bfa2f31675967/aws.svg"
      defaultTargetFolder: ./Workflow Executions
  - directory: Helm
    children:
    - template: Helm install and uninstall application
      description: The workflow provides the steps that install and uninstall the
        application using Helm.
      scheduledStartDate: 2024-02-23T09:00:00+05:30
      dueDate: 2024-02-23T10:00:00+05:30
      phases:
      - phase: Install and Uninstall App
        tasks:
        - name: Helm Configuration
          type: xlrelease.UserInputTask
          description: Select the Helm configuration. You can create a new connection
            if you have not created one.
          variables:
          - helmConfig
        - name: Application Details for Install
          type: xlrelease.UserInputTask
          description: Provide the Application Details for Install
          variables:
          - releaseName
          - chartName
          - chartVersion
          - namespace
        - name: Repository Details for Install
          type: xlrelease.UserInputTask
          description: Provide the chart repository details for Install
          variables:
          - repositoryUrl
          - repoUsername
          - repoPassword
        - name: Install Application
          type: containerHelm.Install
          description: The automated task to install the application.
          variableMapping:
            helmConfig: "${helmConfig}"
            repoPassword: "${repoPassword}"
          capabilities:
          - remote
          releaseName: "${releaseName}"
          chartName: "${chartName}"
          chartVersion: "${chartVersion}"
          namespace: "${namespace}"
          repositoryUrl: "${repositoryUrl}"
          repoUsername: "${repoUsername}"
        - name: Uninstall Application ?
          type: xlrelease.UserInputTask
          description: Do you want to uninstall the application installed in the previous
            step?
          variables:
          - isUninstall
        - name: Uninstall Application
          type: containerHelm.Uninstall
          description: The automated task to uninstall the application.
          precondition: "releaseVariables['isUninstall']"
          variableMapping:
            helmConfig: "${helmConfig}"
          capabilities:
          - remote
          releaseName: "${releaseName}"
          namespace: "${namespace}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Cloud & Container
      variables:
      - type: xlrelease.ReferenceVariable
        key: helmConfig
        showOnReleaseStart: false
        label: Helm Config
        description: Helm Configuration
        referencedType: containerHelm.Config
      - type: xlrelease.StringVariable
        key: releaseName
        showOnReleaseStart: false
        label: Release Name
        description: Name of the Helm release
      - type: xlrelease.StringVariable
        key: chartName
        showOnReleaseStart: false
        label: Chart Name
        description: Name of the Helm chart
      - type: xlrelease.StringVariable
        key: chartVersion
        showOnReleaseStart: false
        label: Chart Version
        description: Version of the Helm chart
      - type: xlrelease.StringVariable
        key: namespace
        showOnReleaseStart: false
        label: Namespace
        description: Kubernetes namespace where the Helm chart will be installed or
          upgraded
      - type: xlrelease.StringVariable
        key: repositoryUrl
        showOnReleaseStart: false
        label: Repository URL
        description: URL for the Helm chart repository
      - type: xlrelease.StringVariable
        key: repoUsername
        requiresValue: false
        showOnReleaseStart: false
        label: Username
        description: Username for accessing the Helm chart repository
      - type: xlrelease.PasswordStringVariable
        key: repoPassword
        requiresValue: false
        showOnReleaseStart: false
        label: Password
        description: Password for accessing the Helm chart repository
      - type: xlrelease.BooleanVariable
        key: isUninstall
        requiresValue: false
        showOnReleaseStart: false
        label: "Yes"
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/c391242d0976ec8fb0db5bb2c5854660e6e35609/helm.svg"
      defaultTargetFolder: ./Workflow Executions
  - directory: Secret Management
    children:
    - template: AWS SecretsManager create secret
      description: |-
        Easily create secrets in AWS Secrets Manager, which can again be looked up and substituted across Digital.ai Release templates and workflows.

        A Secret can be a map of key value pairs or a plain text value.
      scheduledStartDate: 2023-09-12T09:00:00+05:30
      dueDate: 2023-09-12T10:00:00+05:30
      phases:
      - phase: Create Secret
        tasks:
        - name: Create|Select AWS Secrets Manager Connection
          type: xlrelease.UserInputTask
          description: Select or create a new AWS SecretsManager connection.
          variables:
          - aws_secrets_manager
        - name: Specify Secret Details
          type: xlrelease.UserInputTask
          description: Enter the secret name and value. Secret value can be plain
            text or a json key value map.
          variables:
          - secret_name
          - secret_value
        - name: Create Secret
          type: awsSecretManager.SetSecret
          secretName: "${secret_name}"
          description: Creates a secret with the specified value in AWS SecretsManager.
          variableMapping:
            pythonScript.awsCloud: "${aws_secrets_manager}"
            pythonScript.secretValue: "${secret_value}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Cloud & Container
      variables:
      - type: xlrelease.ReferenceVariable
        key: aws_secrets_manager
        showOnReleaseStart: false
        label: AWS SecretsManager
        description: Connection to AWS SecretsManager
        referencedType: secrets.aws.SecretsManager
      - type: xlrelease.StringVariable
        key: secret_name
        showOnReleaseStart: false
        label: Secret Name
        description: Name of the secret
      - type: xlrelease.PasswordStringVariable
        key: secret_value
        showOnReleaseStart: false
        label: Secret Value
        description: Value of the secret as plain text or json key value map
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/a45e41fb5ed003a3e19042672b9dca98cce1336e/aws.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: AWS SecretsManager delete secret
      description: Easily delete secret entries in AWS Secrets Manager.
      scheduledStartDate: 2023-09-12T09:00:00+05:30
      dueDate: 2023-09-12T10:00:00+05:30
      phases:
      - phase: Delete Secret
        tasks:
        - name: Create|Select AWS Secrets Manager Connection
          type: xlrelease.UserInputTask
          description: Select or create a new AWS SecretsManager connection.
          variables:
          - aws_secrets_manager
        - name: Specify Secret Details
          type: xlrelease.UserInputTask
          description: Enter the secret name to be deleted.
          variables:
          - secret_name
        - name: Delete Secret
          type: awsSecretManager.DeleteSecret
          secretName: "${secret_name}"
          description: Deletes the specified secret in the AWS SecretsManager.
          variableMapping:
            pythonScript.awsCloud: "${aws_secrets_manager}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Cloud & Container
      variables:
      - type: xlrelease.ReferenceVariable
        key: aws_secrets_manager
        showOnReleaseStart: false
        label: AWS SecretsManager
        description: Connection to AWS SecretsManager
        referencedType: secrets.aws.SecretsManager
      - type: xlrelease.StringVariable
        key: secret_name
        showOnReleaseStart: false
        label: Secret Name
        description: Name of the secret
      - type: xlrelease.PasswordStringVariable
        key: secret_value
        showOnReleaseStart: false
        label: Secret Value
        description: Value of the secret as plain text or json key value map
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/878ceaad09c7b1b91d6864b4b3de88eae717647a/aws.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: AWS SecretsManager update secret
      description: |-
        Easily update secrets in AWS Secrets Manager, which can be looked up and substituted across Digital.ai Release templates and workflows.

        A Secret can be a map of key value pairs or a plain text value.
      scheduledStartDate: 2023-09-12T09:00:00+05:30
      dueDate: 2023-09-12T10:00:00+05:30
      phases:
      - phase: Update Secret
        tasks:
        - name: Create|Select AWS Secrets Manager Connection
          type: xlrelease.UserInputTask
          description: Select or create a new AWS SecretsManager connection.
          variables:
          - aws_secrets_manager
        - name: Specify Secret Details
          type: xlrelease.UserInputTask
          description: Enter the secret name and value. Secret value can be plain
            text or a json key value map.
          variables:
          - secret_name
          - secret_value
        - name: Update Secret
          type: awsSecretManager.SetSecret
          secretName: "${secret_name}"
          description: Updates the secret with the specified value.
          variableMapping:
            pythonScript.awsCloud: "${aws_secrets_manager}"
            pythonScript.secretValue: "${secret_value}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Cloud & Container
      variables:
      - type: xlrelease.ReferenceVariable
        key: aws_secrets_manager
        showOnReleaseStart: false
        label: AWS SecretsManager
        description: Connection to AWS SecretsManager
        referencedType: secrets.aws.SecretsManager
      - type: xlrelease.StringVariable
        key: secret_name
        showOnReleaseStart: false
        label: Secret Name
        description: Name of the secret
      - type: xlrelease.PasswordStringVariable
        key: secret_value
        showOnReleaseStart: false
        label: Secret Value
        description: Value of the secret as plain text or json key value map
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/74a93b00194341f3b8bf7101d1ab5fdd11ea3abe/aws.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: Azure KeyVault create secret
      description: "Easily create secrets in Azure KeyVault, which can again be looked\
        \ up and substituted across Digital.ai Release templates and workflows."
      scheduledStartDate: 2023-09-12T09:00:00+05:30
      dueDate: 2023-09-12T10:00:00+05:30
      phases:
      - phase: Create Secret
        tasks:
        - name: Create|Select Azure KeyVault Connection
          type: xlrelease.UserInputTask
          description: Select or create a new Azure KeyVault connection.
          variables:
          - azure_key_vault
        - name: Specify Secret Details
          type: xlrelease.UserInputTask
          description: Enter the secret name and value. Secret value should be plain
            text.
          variables:
          - vault_name
          - secret_name
          - secret_value
        - name: Create Secret
          type: azureKeyvault.SetSecret
          vaultName: "${vault_name}"
          secretName: "${secret_name}"
          description: Creates a secret with the specified value in Azure KeyVault.
          variableMapping:
            pythonScript.keyvaultServer: "${azure_key_vault}"
            pythonScript.secretValue: "${secret_value}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Cloud & Container
      variables:
      - type: xlrelease.StringVariable
        key: secret_name
        showOnReleaseStart: false
        label: Secret Name
        description: Name of the secret
      - type: xlrelease.PasswordStringVariable
        key: secret_value
        showOnReleaseStart: false
        label: Secret Value
        description: Value of the secret as plain text
      - type: xlrelease.ReferenceVariable
        key: azure_key_vault
        showOnReleaseStart: false
        label: Azure KeyVault Server
        description: Connection to Azure KeyVault
        referencedType: azure.KeyvaultServer
      - type: xlrelease.StringVariable
        key: vault_name
        showOnReleaseStart: false
        label: Vault Name
        description: Azure KeyVault Name
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/20ece0db6a7a824861ee258afb17e93b1a424ea3/azure.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: Azure KeyVault delete secret
      description: Easily delete secret entries from Azure KeyVault.
      scheduledStartDate: 2023-09-12T09:00:00+05:30
      dueDate: 2023-09-12T10:00:00+05:30
      phases:
      - phase: Delete Secret
        tasks:
        - name: Create|Select Azure KeyVault Connection
          type: xlrelease.UserInputTask
          description: Select or create a new Azure KeyVault connection.
          variables:
          - azure_key_vault
        - name: Specify Secret Details
          type: xlrelease.UserInputTask
          description: Enter the secret name to be deleted.
          variables:
          - vault_name
          - secret_name
        - name: Delete Secret
          type: azureKeyvault.DeleteSecret
          vaultName: "${vault_name}"
          secretName: "${secret_name}"
          description: Deletes the specified secret from the specified Azure KeyVault.
          variableMapping:
            pythonScript.keyvaultServer: "${azure_key_vault}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Cloud & Container
      variables:
      - type: xlrelease.StringVariable
        key: secret_name
        showOnReleaseStart: false
        label: Secret Name
        description: Name of the secret
      - type: xlrelease.PasswordStringVariable
        key: secret_value
        showOnReleaseStart: false
        label: Secret Value
        description: Value of the secret as plain text
      - type: xlrelease.ReferenceVariable
        key: azure_key_vault
        showOnReleaseStart: false
        label: Azure KeyVault Server
        description: Connection to Azure KeyVault
        referencedType: azure.KeyvaultServer
      - type: xlrelease.StringVariable
        key: vault_name
        showOnReleaseStart: false
        label: Vault Name
        description: Azure KeyVault Name
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/36d6f87e14a8e4c7555e654394560ea5e48d2af7/azure.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: Azure KeyVault update secret
      description: "Easily update secrets in Azure KeyVault, which can be looked up\
        \ and substituted across Digital.ai Release templates and workflows."
      scheduledStartDate: 2023-09-12T09:00:00+05:30
      dueDate: 2023-09-12T10:00:00+05:30
      phases:
      - phase: Update Secret
        tasks:
        - name: Create|Select Azure KeyVault Connection
          type: xlrelease.UserInputTask
          description: Select or create a new Azure KeyVault connection.
          variables:
          - azure_key_vault
        - name: Specify Secret Details
          type: xlrelease.UserInputTask
          description: Enter the secret name and value. Secret value should be plain
            text.
          variables:
          - vault_name
          - secret_name
          - secret_value
        - name: Update Secret
          type: azureKeyvault.SetSecret
          vaultName: "${vault_name}"
          secretName: "${secret_name}"
          description: Updates a secret with the specified value.
          variableMapping:
            pythonScript.keyvaultServer: "${azure_key_vault}"
            pythonScript.secretValue: "${secret_value}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Cloud & Container
      variables:
      - type: xlrelease.StringVariable
        key: secret_name
        showOnReleaseStart: false
        label: Secret Name
        description: Name of the secret
      - type: xlrelease.PasswordStringVariable
        key: secret_value
        showOnReleaseStart: false
        label: Secret Value
        description: Value of the secret as plain text
      - type: xlrelease.ReferenceVariable
        key: azure_key_vault
        showOnReleaseStart: false
        label: Azure KeyVault Server
        description: Connection to Azure KeyVault
        referencedType: azure.KeyvaultServer
      - type: xlrelease.StringVariable
        key: vault_name
        showOnReleaseStart: false
        label: Vault Name
        description: Azure KeyVault Name
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/dd3e0b5a3aa68569bbc5b1ae1f8e078d5de3db7d/azure.svg"
      defaultTargetFolder: ./Workflow Executions
  - directory: Azure
    children:
    - template: List Azure Container Registry Images
      description: Lists the images present in an Azure Container Registry.
      scheduledStartDate: 2023-09-20T09:00:00+05:30
      dueDate: 2023-09-20T10:00:00+05:30
      phases:
      - phase: List Images
        tasks:
        - name: Azure Connection
          type: xlrelease.UserInputTask
          description: Select the Azure Connection or create a new connection if you
            have not created one.
          variables:
          - azureConnection
        - name: Specify the Registry Name
          type: xlrelease.UserInputTask
          description: Specify the Registry Name
          variables:
          - registryName
        - name: List Images in Registry
          type: containerAzure.RunCommand
          description: Lists Images in specfied Registry
          variableMapping:
            azureConfiguration: "${azureConnection}"
          capabilities:
          - remote
          command: "acr repository list --name ${registryName}"
      kind: WORKFLOW
      categories:
      - Infrastructure Service
      variables:
      - type: xlrelease.ReferenceVariable
        key: azureConnection
        showOnReleaseStart: false
        label: Azure Connection
        description: Connection to Azure
        referencedType: containerAzure.configuration
      - type: xlrelease.StringVariable
        key: command
        showOnReleaseStart: false
        label: Command to List ACR Images
      - type: xlrelease.StringVariable
        key: registryName
        showOnReleaseStart: false
        label: Registry Name
        description: Name of the Registry
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/png
        file: !file "template-logo/cf55ce7b37a3127d605482aabbf8742fb59c220a/azure.svg"
      defaultTargetFolder: ./Workflow Executions
  - directory: Release runner
    children:
    - template: Digital.ai Release runner additional install in Kubernetes
      description: Install an additional Digital.ai Release Runner in a Kubernetes
        cluster. You need a Digital.ai Release Kubernetes container plugin for this
        option.
      scheduledStartDate: 2023-12-22T13:30:00+05:30
      dueDate: 2023-12-22T14:30:00+05:30
      phases:
      - phase: Workflow tasks
        tasks:
        - name: Set Digital.ai Release URL value placeholder
          type: xlrelease.ScriptTask
          description: Setting `$releaseUrl` variable placeholder for further input.
          script: |-
            import re

            pattern = re.compile(r'^(https?://[^:/]+(?:\:\d+)?)')

            match = pattern.match('${release.url}')

            if match:
                releaseVariables['releaseUrl'] = match.group(1)
        - name: Prepare Digital.ai  Release URL
          type: xlrelease.UserInputTask
          description: Enter URL of your Digital.ai Release instance that is **accessible
            from the Kubernetes cluster**.
          variables:
          - releaseUrl
        - name: Prepare input for Digital.ai Release runner installation on Kubernetes
            cluster
          type: xlrelease.UserInputTask
          description: Add required information for adding a new Digital.ai Release
            Runner.
          variables:
          - kubernetesApiServer
          - namespace
          - runnerName
          - runnerImage
          - replicas
        - name: Create runner token
          type: xlrelease.ScriptTask
          description: Creates runner token for authentication on Digital.ai Release
          script: |-
            import random
            import string
            from java.util import Set
            from com.xebialabs.xlrelease.api.v1.forms import CreatePersonalAccessTokenForm

            characters = string.ascii_letters + string.digits
            uid = ''.join(random.choice(characters) for _ in range(6))
            token_note = releaseVariables["runnerName"] + "-" + uid

            token_form = CreatePersonalAccessTokenForm(token_note)
            global_permissions = Set.of("runner#registration")
            token_form.setGlobalPermissions(global_permissions)

            response = personalAccessTokenApi.createPersonalAccessToken(token_form)

            releaseVariables["token"] = response.getProperty("token")
        - name: "Check if ${namespace} namespace exists"
          type: kubernetes.ExistsNamespace
          description: "Task checks if ${namespace} namespace already exists. If it\
            \ doesn't exist, next task will create the namespace. Otherwise, next\
            \ task will be skipped."
          variableMapping:
            server: "${kubernetesApiServer}"
            commandResponse: "${namespaceExistsResponse}"
          capabilities:
          - remote
          namespace: "${namespace}"
        - name: "Create ${namespace} namespace"
          type: kubernetes.CreateNamespace
          description: "Since the ${namespace} namespace doesn't exist, this task\
            \ creates one."
          precondition: |-
            if releaseVariables['namespaceExistsResponse']['exists'] == 'false':
              result = True
            else:
              result = False
          variableMapping:
            server: "${kubernetesApiServer}"
          capabilities:
          - remote
          namespace: "${namespace}"
        - name: Create runner resources
          type: kubernetes.Apply
          description: |-
            Creates all necessary resources on the Kubernetes cluster inside ${namespace} namespace.
            This includes service accounts, secrets, config maps, role bindings, services and stateful sets.
          variableMapping:
            server: "${kubernetesApiServer}"
          capabilities:
          - remote
          namespace: "${namespace}"
          yamlContent: |-
            ---
            # Source: runner/templates/service-account.yaml
            apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: ${runnerName}
              namespace: "${namespace}"
              labels:
                app.kubernetes.io/name: runner
                helm.sh/chart: runner-0.1.0
                app.kubernetes.io/instance: my-release
                app.kubernetes.io/managed-by: Helm
            ---
            # Source: runner/templates/secrets.yaml
            apiVersion: v1
            kind: Secret
            metadata:
              name: ${runnerName}-registration-token
              namespace: "${namespace}"
              labels:
                app.kubernetes.io/name: runner
                helm.sh/chart: runner-0.1.0
                app.kubernetes.io/instance: my-release
                app.kubernetes.io/managed-by: Helm
            type: Opaque
            stringData:
              token: "${token} "
            ---
            # Source: runner/templates/configmaps.yaml
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: ${runnerName}-env-config
              namespace: "${namespace}"
              labels:
                app.kubernetes.io/name: runner
                helm.sh/chart: runner-0.1.0
                app.kubernetes.io/instance: my-release
                app.kubernetes.io/managed-by: Helm
            data:
              {}
            ---
            # Source: runner/templates/service-account.yaml
            apiVersion: rbac.authorization.k8s.io/v1
            kind: Role
            metadata:
              name: ${runnerName}
              namespace: "${namespace}"
              labels:
                app.kubernetes.io/name: runner
                helm.sh/chart: runner-0.1.0
                app.kubernetes.io/instance: my-release
                app.kubernetes.io/managed-by: Helm
            rules:
              - apiGroups:
                  - ""
                resources:
                  - pods
                verbs:
                  - get
                  - list
                  - watch
                  - create
                  - update
                  - patch
                  - delete
              - apiGroups:
                  - ""
                resources:
                  - pods/log
                verbs:
                  - get
                  - list
              - apiGroups:
                  - ""
                resources:
                  - pods/exec
                verbs:
                  - create
              - apiGroups:
                  - ""
                resources:
                  - secrets
                verbs:
                  - get
                  - create
                  - update
                  - delete
                  - list
                  - patch
                  - watch
              - apiGroups:
                  - ""
                resources:
                  - serviceaccounts
                verbs:
                  - get
                  - create
                  - delete
              - apiGroups:
                  - rbac.authorization.k8s.io
                resources:
                  - roles
                  - rolebindings
                verbs:
                  - get
                  - create
                  - delete
            ---
            # Source: runner/templates/service-account.yaml
            kind: RoleBinding
            apiVersion: rbac.authorization.k8s.io/v1
            metadata:
              name: ${runnerName}
              namespace: "${namespace}"
              labels:
                app.kubernetes.io/name: runner
                helm.sh/chart: runner-0.1.0
                app.kubernetes.io/instance: my-release
                app.kubernetes.io/managed-by: Helm
            roleRef:
              kind: Role
              name: ${runnerName}
              apiGroup: rbac.authorization.k8s.io
            subjects:
              - kind: ServiceAccount
                name: ${runnerName}
                namespace: "${namespace}"
            ---
            # Source: runner/templates/statefulset.yaml
            apiVersion: v1
            kind: Service
            metadata:
              name: ${runnerName}-headless
              namespace: "${namespace}"
              labels:
                app.kubernetes.io/name: runner
                helm.sh/chart: runner-0.1.0
                app.kubernetes.io/instance: my-release
                app.kubernetes.io/managed-by: Helm
            spec:
              clusterIP: None
              selector:
                app: ${runnerName}
            ---
            # Source: runner/templates/statefulset.yaml
            apiVersion: apps/v1
            kind: StatefulSet
            metadata:
              name: ${runnerName}
              namespace: "${namespace}"
              labels:
                app.kubernetes.io/name: runner
                helm.sh/chart: runner-0.1.0
                app.kubernetes.io/instance: my-release
                app.kubernetes.io/managed-by: Helm
            spec:
              serviceName: ${runnerName}-headless
              podManagementPolicy: Parallel
              replicas: ${replicas}
              updateStrategy:
                type: RollingUpdate
              selector:
                matchLabels:
                  app.kubernetes.io/name: runner
                  app.kubernetes.io/instance: my-release
                  app: ${runnerName}
              template:
                metadata:
                  labels:
                    app.kubernetes.io/name: runner
                    helm.sh/chart: runner-0.1.0
                    app.kubernetes.io/instance: my-release
                    app.kubernetes.io/managed-by: Helm
                    app: ${runnerName}
                  annotations:
                    checksum/config: a8c057bd11fa913d3aee52c40a3a4892c51ff6cf1a4e4171b2fb89a29268bf68
                    checksum/secret: b758b5aa5a17777f33478760a9a9d6074dedc3d0b892ee6a8f13b46ab3c635d2
                spec:
                  serviceAccountName: ${runnerName}
                  affinity:
                    podAntiAffinity:
                      preferredDuringSchedulingIgnoredDuringExecution:
                        - podAffinityTerm:
                            labelSelector:
                              matchLabels:
                                app.kubernetes.io/name: runner
                                app.kubernetes.io/instance: my-release
                            namespaces:
                              - "${namespace}"
                            topologyKey: kubernetes.io/hostname
                          weight: 1
                  dnsPolicy: ClusterFirst
                  hostNetwork: false
                  terminationGracePeriodSeconds: 200
                  containers:
                    - name: runner
                      image: "${runnerImage}"
                      imagePullPolicy: "IfNotPresent"
                      env:
                        - name: RELEASE_RUNNER_NAME
                          valueFrom:
                            fieldRef:
                              fieldPath: metadata.name
                        - name: RELEASE_RUNNER_KUBERNETES_SERVICE_NAME
                          value: ${runnerName}-headless
                        - name: RELEASE_RUNNER_RELEASE_URL
                          value: "${releaseUrl}"
                        - name: RELEASE_RUNNER_TOKEN
                          valueFrom:
                            secretKeyRef:
                              name: ${runnerName}-registration-token
                              key: token
                        - name: RELEASE_RUNNER_CAPABILITIES
                          value: remote,remote-script,container,k8s
                        - name: RELEASE_RUNNER_KUBERNETES_NAMESPACE
                          value: "${namespace}"
                        - name: RELEASE_RUNNER_PROFILE
                          value: "k8s,json-logging"
                        - name: RELEASE_RUNNER_KUBERNETES_IN_CLUSTER_CONFIG
                          value: "true"
                        - name: RELEASE_RUNNER_STORE_NAME
                          value: "/workspace/db/runner-store.db"
                      envFrom:
                        - configMapRef:
                            name: ${runnerName}-env-config
                            optional: true
                      livenessProbe:
                        httpGet:
                          path: /live
                          port: 8686
                        initialDelaySeconds: 10
                        periodSeconds: 5
                        failureThreshold: 12
                      readinessProbe:
                        httpGet:
                          path: /ready
                          port: 8686
                        initialDelaySeconds: 10
                        periodSeconds: 5
                        failureThreshold: 12
                      resources:
                        limits:
                          cpu: "4"
                          memory: 1G
                        requests:
                          cpu: "0.5"
                          memory: 512Mi
        - name: Check if runner is installed
          type: kubernetes.CheckResourceReadiness
          description: |-
            Checking if runner installation was successful.

            This may take a couple of minutes.
          variableMapping:
            server: "${kubernetesApiServer}"
          capabilities:
          - remote
          namespace: "${namespace}"
          kind: StatefulSet
          resourceName: "${runnerName}"
          timeout: 120
      kind: WORKFLOW
      categories:
      - Digital.ai Release runner installation
      variables:
      - type: xlrelease.StringVariable
        key: namespace
        requiresValue: false
        showOnReleaseStart: false
        label: Namespace
        description: Kubernetes namespace where Digital.ai Release runner will be
          installed
        value: digitalai
      - type: xlrelease.StringVariable
        key: runnerImage
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Release runner image
        description: Digital.ai Release runner docker image to be used
        value: xebialabs/release-remote-runner:23.3.0
      - type: xlrelease.StringVariable
        key: releaseUrl
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Release URL
        description: Digital.ai Release URL for Digital.ai Release runner to register
      - type: xlrelease.StringVariable
        key: token
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Release runner token
        description: Digital.ai Release runner uses this token to call the Digital.ai
          Release REST API
      - type: xlrelease.ReferenceVariable
        key: kubernetesApiServer
        requiresValue: false
        showOnReleaseStart: false
        label: Kubernetes API server
        description: Kubernetes API server to install Digital.ai Release runner
        referencedType: kubernetes.APIServer
      - type: xlrelease.MapStringStringVariable
        key: namespaceExistsResponse
        requiresValue: false
        showOnReleaseStart: false
        label: Command Response
        description: Command Response
      - type: xlrelease.StringVariable
        key: runnerName
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Release runner name
        description: "Digital.ai Release runner name to register on Digital.ai Release.\
          \ Also, this is the name of all runner related services in Kubernetes cluster.\
          \ Consider choosing a name without whitespaces, using only letters, numbers,\
          \ or hyphens, to ensure compatibility and simplicity across Kubernetes cluster."
        value: runner
      - type: xlrelease.IntegerVariable
        key: replicas
        requiresValue: false
        showOnReleaseStart: false
        label: Replicas
        description: Number of Digital.ai Release runner replicas
        value: 1
      allowPasswordsInAllFields: true
      disableNotifications: true
      author: Digital.ai
      defaultTargetFolder: ./Workflow Executions
    - template: Digital.ai Release runner install in Kubernetes
      description: Install a Digital.ai Release runner into an existing Kubernetes
        cluster using the `xl` client.
      scheduledStartDate: 2023-12-22T13:30:00+05:30
      dueDate: 2023-12-22T14:30:00+05:30
      phases:
      - phase: Workflow tasks
        tasks:
        - name: Set up Kubernetes cluster
          type: xlrelease.Task
          description: |-
            Configure Kubernetes cluster

            Current supported clusters:
            - Openshift
            - AWS EKS
            - Plain multi-node K8s cluster
            - Azure AKS
            - Google Kubernetes Engine

            Also, `kubectl` should be up and running and connected to the cluster
        - name: Create runner token
          type: xlrelease.ScriptTask
          description: Creates Runner token for authentication on Digital.ai Release
          script: |-
            import random
            import string
            from java.util import Set
            from com.xebialabs.xlrelease.api.v1.forms import CreatePersonalAccessTokenForm

            characters = string.ascii_letters + string.digits
            uid = ''.join(random.choice(characters) for _ in range(6))
            token_note = "runner-" + uid

            token_form = CreatePersonalAccessTokenForm(token_note)
            global_permissions = Set.of("runner#registration")
            token_form.setGlobalPermissions(global_permissions)

            response = personalAccessTokenApi.createPersonalAccessToken(token_form)

            releaseVariables["runnerRegistrationToken"] = response.getProperty("token")
        - name: Install XL CLI
          type: xlrelease.Task
          description: |-
            [About XL CLI](https://docs.digital.ai/bundle/devops-release-version-v.23.3/page/release/operator/xl-op-before-you-begin.html)

            [Instructions to install XL CLI](https://docs.digital.ai/bundle/devops-deploy-version-v.23.3/page/deploy/how-to/install-the-xl-cli.html)

            Make sure that you run the same version of `xl` as the installation of Digital.ai Release
        - name: Install Digital.ai Release runner
          type: xlrelease.Task
          description: |-
            ## Install new Digital.ai Release runner through XL CLI

            Run `xl kube install`

            This will start a CLI wizard.

            ### Digital.ai Release runner install wizard
            - Insert kubectl context to be used during execution (or use default)
            - Select Kubernetes setup
            - Insert Kubernetes namespace (or use default)
            - When be asked to select a product for installation, select `dai-release-runner [Digital.ai Release runner for Digital.ai Release]`
            - Select type of image registry (or use default)
            - Enter Digital.ai Release runner image information (or use default)
            - Enter Digital.ai Release runner Helm Chart release name and version (or use default)
            - Enter the URL for the Digital.ai Release server that is **reachable from within the Kubernetes cluster**
            - Enter token `${runnerRegistrationToken}`
            - Enter how many replicas of Digital.ai Release runner you want
            - Enter truststore for Digital.ai Release runner


            To customize the configuration based on your setup, `xl kube install` offers various customization options. Please refer to the [documentation](https://docs.digital.ai/bundle/devops-release-version-v.23.3/page/release/operator/xl-op-before-you-begin.html) for further information
      kind: WORKFLOW
      categories:
      - Digital.ai Release runner installation
      variables:
      - type: xlrelease.StringVariable
        key: runnerRegistrationToken
        requiresValue: false
        showOnReleaseStart: false
        label: Description
        description: The description of the item.
      disableNotifications: true
      author: Digital.ai
      defaultTargetFolder: ./Workflow Executions
    - template: Digital.ai Release runner install with Digital.ai Cloud Connector
      description: Install the Digital.ai Release runner with an embedded Kubernetes
        cluster using the Digital.ai Cloud Connector. You need a Digital.ai account
        for this option.
      scheduledStartDate: 2024-02-19T13:30:00+05:30
      dueDate: 2024-02-19T14:30:00+05:30
      phases:
      - phase: Prerequisites
        tasks:
        - name: Getting started
          type: xlrelease.Task
          description: |-
            This workflow will help you set up a Release runner by way of the Digital.ai Platform Cloud Connector.

            Use this option if you don't have access to an existing Kubernetes cluster.

            The Cloud Connector provides an embedded Kubernetes runtime environment that will host the Release runner and the container-based tasks coming from Release.

            ### Prerequisites

            For a successful runner installation with Digital.ai Platform you will need

            - Admin permissions in Digital.ai Release for this user running the workflow
            - Network access to Digital.ai Platform service on the internet
            - Username and password of the admin user of your customer account on Digital.ai Platform
            - A target machine for the installation running Linux or macOS
            - A Docker runtime on the target machine
        color: '#3d6c9e'
      - phase: Connect to Platform
        tasks:
        - name: Check Digital.ai Platform connection
          type: xlrelease.ScriptTask
          description: Checking if an existing connection to Digital.ai Platform exists.
          script: |-
            platformConnections = configurationApi.searchByTypeAndTitle("daiplatform.Server", "")

            if len(platformConnections) == 0:
              releaseVariables["createPlatformConnection"] = True
            else:
              releaseVariables["createPlatformConnection"] = False
        - name: Provide Digital.ai Platform connection details
          type: xlrelease.UserInputTask
          description: |-
            Please enter the credentials of the admin user for your customer account on Digital.ai Platform.

            If you don't have this information, please contact your Digital.ai representative.
          precondition: "releaseVariables[\"createPlatformConnection\"]"
          variables:
          - customer
          - platformUsername
          - platformPassword
        - name: Create Digital.ai Platform connection
          type: daiplatform.CreateConnection
          customer: "${customer}"
          username: "${platformUsername}"
          regions:
          - eu
          - staging
          - us
          description: |-
            Creating connecting to Digital.ai Platform


            ⚠️ If this step fails because of incorrect credentials, please go to the previous step called **Provide Digital.ai Platform connection details** to change them and restart the workflow from there.
          precondition: "releaseVariables[\"createPlatformConnection\"]"
          variableMapping:
            pythonScript.password: "${platformPassword}"
            pythonScript.output: "${platformConnectionId}"
        - name: Register Digital.ai Platform connection
          type: xlrelease.ScriptTask
          description: Registering Digital.ai Platform connection for use in subsequent
            tasks.
          precondition: "releaseVariables[\"createPlatformConnection\"]"
          script: "releaseVariables[\"platformConnection\"] = releaseVariables[\"\
            platformConnectionId\"]"
        - name: Select Digital.ai Platform connection
          type: xlrelease.UserInputTask
          description: Please select  the Digital.ai Platform connection that will
            be used for installing the Cloud Connector.
          precondition: "not releaseVariables[\"createPlatformConnection\"]"
          variables:
          - platformConnection
        color: '#3d6c9e'
      - phase: Get Cloud Connector Definition
        tasks:
        - name: Set Digital.ai Release placeholders
          type: xlrelease.ScriptTask
          description: Setting `$releaseUrl` and `$releaseName` variables placeholder
            for further input.
          script: |-
            import re

            # Set Release URL
            pattern = re.compile(r'^(https?://[^:/]+(?:\:\d+)?)')

            match = pattern.match('${release.url}')

            if match:
              releaseUrl = match.group(1)
              releaseVariables['releaseUrl'] = releaseUrl

            # Set Release name
            pattern = re.compile(r'http[s]?://([^:/]+)')

            match = pattern.match('${release.url}')

            if match:
              releaseName = match.group(1)
              releaseVariables['releaseName'] = releaseName
        - name: Set Digital.ai Release identifier
          type: xlrelease.UserInputTask
          description: |-
            Please enter a unique identifier for  this Digital.ai Release server.

            Choose a name without whitespaces, using only letters, numbers, dots or hyphens.
          variables:
          - releaseName
        - name: Check Cloud Connector registration
          type: daiplatform.GetCloudConnectors
          description: Retrieving registered Cloud Connectors from Digital.ai Platform
          variableMapping:
            pythonScript.daiPlatformServer: "${platformConnection}"
            pythonScript.output: "${cloudConnectorsResponse}"
        - name: Check Cloud Connector registration
          type: xlrelease.ScriptTask
          description: "Checking if there is already an existing Cloud Connector definition\
            \ for `${releaseName}`"
          script: |-
            import json

            cloudConnectors = json.loads(releaseVariables["cloudConnectorsResponse"])
            for cloudConnector in cloudConnectors:
              if cloudConnector["name"] == releaseVariables["releaseName"]:
                releaseVariables["cloudConnectorId"] = cloudConnector["id"]
                releaseVariables["createCloudConnector"] = False
                break
        - name: Create new Cloud Connector Definition
          type: daiplatform.CreateCloudConnector
          cloudConnectorName: "${releaseName}"
          description: Creating a new Cloud Connector definition on the Digital.ai
            Platform.
          precondition: "releaseVariables[\"createCloudConnector\"]"
          variableMapping:
            pythonScript.output: "${createCloudConnectorResponse}"
            pythonScript.daiPlatformServer: "${platformConnection}"
        - name: Set Cloud Connector ID
          type: xlrelease.ScriptTask
          precondition: "releaseVariables[\"createCloudConnector\"]"
          script: |-
            import json

            create_cloud_connector_response = json.loads(releaseVariables['createCloudConnectorResponse'])
            releaseVariables['cloudConnectorId'] = create_cloud_connector_response['id']
        color: '#3d6c9e'
      - phase: Select Release Runner version
        tasks:
        - name: Get available Release runner versions (1/2)
          type: daiplatform.GetAgentRuntimes
          sort: -created_date
          filter: "name[search]:runner"
          description: Fetching available agent runtimes from Digital.ai Platform
          variableMapping:
            pythonScript.output: "${agentRuntimesResponse}"
            pythonScript.daiPlatformServer: "${platformConnection}"
        - name: Get available Release runner versions (2/2)
          type: xlrelease.ScriptTask
          description: Preparing form
          script: |-
            import json

            agent_runtimes = json.loads(releaseVariables['agentRuntimesResponse'])
            agent_runtime_names = [agent_runtime['name'] for agent_runtime in agent_runtimes]
            releaseVariables['agentRuntimeNames'] = agent_runtime_names

            if len(agent_runtimes)>0:
              releaseVariables["agentRuntimeSelect"] = agent_runtimes[0]["name"]
        - name: Select Release runner version
          type: xlrelease.UserInputTask
          description: Please confirm the version of the Release runner that will
            be installed
          variables:
          - agentRuntimeSelect
        - name: Set Release runner ID
          type: xlrelease.ScriptTask
          description: Setting agent runtime ID for creating a new Release runner
            on Digital.ai Platform.
          script: |-
            import json

            agent_runtimes = json.loads(releaseVariables['agentRuntimesResponse'])
            for agent_runtime in agent_runtimes:
              if agent_runtime['name'] == releaseVariables['agentRuntimeSelect']:
                releaseVariables['agentRuntimeId'] = agent_runtime['id']
                break
        color: '#3d6c9e'
      - phase: Install Cloud Connector and Release Runner
        tasks:
        - name: Get installation token
          type: daiplatform.GetToken
          description: |-
            Fetching access token from the Digital.ai Platform server. The token is required for installing the Cloud Connector in the nest step.

            Restart from here if the token expired and caused the installation to fail
          variableMapping:
            pythonScript.output: "${platformAccessToken}"
            pythonScript.daiPlatformServer: "${platformConnection}"
        - name: Install the Cloud Connector
          type: xlrelease.Task
          description: |-
            Digital.ai Platform has provided a customized installer with a unique token.

            ## Download and start Cloud Connector installer script
            Copy the following command and paste it into your target machine's terminal.

            ```
            curl -X GET 'https://api.staging.digital.ai/workload/v1/cloud_connectors/${cloudConnectorId}/installer/?target_os=linux' -H 'accept: application/x-sh' -H 'authorization: Bearer ${platformAccessToken}' --output dcc-installer.sh && bash dcc-installer.sh && bash cloud-connector-setup.sh
            ```


            If the token has expired, restart from the previous step **Get installation token**
        - name: Prepare Digital.ai Release URL
          type: xlrelease.UserInputTask
          description: Enter URL of your Digital.ai Release instance that is **accessible
            from the Kubernetes cluster**.
          variables:
          - releaseUrl
        - name: Set Release runner name
          type: xlrelease.UserInputTask
          description: |-
            Please enter the identifying name of the Release runner

            This is the name of all Digital.ai Release runner related services in Kubernetes cluster.

            Choose a name without whitespaces, using only letters, numbers, or hyphens.
            The name must start and end with an alphanumeric character to ensure compatibility across Kubernetes cluster.
          variables:
          - runnerName
        - name: Create runner token
          type: xlrelease.ScriptTask
          description: Creates Runner token for authentication on Digital.ai Release
          script: |-
            import random
            import string
            from java.util import Set
            from com.xebialabs.xlrelease.api.v1.forms import CreatePersonalAccessTokenForm

            characters = string.ascii_letters + string.digits
            uid = ''.join(random.choice(characters) for _ in range(6))
            token_note = releaseVariables["runnerName"] + "-" + uid

            token_form = CreatePersonalAccessTokenForm(token_note)
            global_permissions = Set.of("runner#registration")
            token_form.setGlobalPermissions(global_permissions)

            response = personalAccessTokenApi.createPersonalAccessToken(token_form)

            releaseVariables["runnerRegistrationToken"] = response.getProperty("token")
        - name: Create runner Instance
          type: daiplatform.CreateAgentInstance
          agentId: "${agentRuntimeId}"
          alias: "${runnerName}"
          ^description: Digital.ai Release runner
          variables:
            RUNNER_REGISTRATION_TOKEN: "${runnerRegistrationToken}"
            DAI_AGENT_ID: "${cloudConnectorId}"
            RELEASE_URL: "${releaseUrl}"
            RUNNER_NAME: "${runnerName}"
          cloudConnectorId: "${cloudConnectorId}"
          description: Creating a new agent instance in Digital.ai Platform for selected
            Release runner version
          variableMapping:
            pythonScript.daiPlatformServer: "${platformConnection}"
            pythonScript.output: "${createAgentInstanceResponse}"
        color: '#3d6c9e'
      - phase: Check Release Runner installation
        tasks:
        - name: Check if Release runner is installed
          type: xlrelease.ScriptTask
          description: |-
            Checking if runner installation was successful.

            This may take a couple of minutes.
          script: |-
            import time
            import json

            # set created agent instance ID
            agent_instance = json.loads(releaseVariables["createAgentInstanceResponse"])
            releaseVariables["agentInstanceId"] = agent_instance["agent_instance"]["id"]

            # check if runner is registered
            for i in range(60):
              runners = configurationApi.searchByTypeAndTitle("xlrelease.RemoteJobRunner", "{}-0".format(releaseVariables["runnerName"]))
              if len(runners)>0:
                releaseVariables["runnerInstalled"] = True
                break
              time.sleep(1)
        - name: Troubleshooting
          type: xlrelease.UserInputTask
          description: |-
            Runner is not registered on Digital.ai Release.
            Check logs of the Runner service in the Kubernetes cluster.
            Below are some common issues. If some of them is matching your problem, consider selecting the corresponding troubleshoot action.

            ### Runner logs show dial tcp: lookup ${releaseUrl}: no such host
            - Check that provided Digital.ai Release server URL is accessible from the Kubernetes cluster.
            - If wrong URL is provided, or port is missing, select **Change Release URL**
          precondition: "not releaseVariables[\"runnerInstalled\"]"
          variables:
          - troubleshootAction
        - name: Prepare Digital.ai Release URL
          type: xlrelease.UserInputTask
          description: Enter URL of your Digital.ai Release instance that is **accessible
            from the Kubernetes cluster**.
          precondition: "releaseVariables[\"troubleshootAction\"] == \"Change Release\
            \ URL\""
          variables:
          - releaseUrl
        - name: Change Release URL
          type: daiplatform.PatchAgentInstance
          agentInstanceId: "${agentInstanceId}"
          variables:
            RELEASE_URL: "${releaseUrl}"
          description: Updating Agent Instance RELEASE_URL variable.
          precondition: "releaseVariables[\"troubleshootAction\"] == \"Change Release\
            \ URL\""
          variableMapping:
            pythonScript.daiPlatformServer: "${platformConnection}"
        - name: Update Agent Instance
          type: daiplatform.PatchAgentInstance
          agentInstanceId: "${agentInstanceId}"
          ^description: Digital.ai Release runner
          variables:
            RUNNER_REGISTRATION_TOKEN: "${runnerRegistrationToken}"
            DAI_AGENT_ID: "${cloudConnectorId}"
            RELEASE_URL: "${releaseUrl}"
            RUNNER_NAME: "${runnerName}"
          description: Updating Agent Instance values
          precondition: "releaseVariables[\"troubleshootAction\"] == \"Change Release\
            \ URL\""
          variableMapping:
            pythonScript.daiPlatformServer: "${platformConnection}"
            pythonScript.output: "${createAgentInstanceResponse}"
        - name: Check if runner is installed after troubleshoot
          type: xlrelease.ScriptTask
          description: |-
            Checking if Runner installation is successful after troubleshoot.
            This may take up to 1 minute.
            If the task fails, return to Troubleshooting.
          script: |-
            import time
            import json

            for i in range(60):
              runners = configurationApi.searchByTypeAndTitle("xlrelease.RemoteJobRunner", "{}-0".format(releaseVariables["runnerName"]))
              if len(runners)>0:
                releaseVariables["runnerInstalled"] = True
                break
              time.sleep(1)

            if not releaseVariables["runnerInstalled"]:
              raise Exception("Runner still not installed. Go back to Troubleshooting.")
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Digital.ai Release runner installation
      variables:
      - type: xlrelease.StringVariable
        key: customer
        requiresValue: false
        showOnReleaseStart: false
        label: Customer ID
        description: The unique identifier for your account
      - type: xlrelease.ReferenceVariable
        key: platformConnection
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Platform connection
        description: Digital.ai Platform Server to connect
        referencedType: daiplatform.Server
      - type: xlrelease.StringVariable
        key: platformUsername
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Platform username
        description: Used to connect to to Digital.ai Platform
      - type: xlrelease.PasswordStringVariable
        key: platformPassword
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Platform password
        description: Used to connect to Digital.ai Platform
      - type: xlrelease.StringVariable
        key: releaseName
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Release instance name
        description: Unique Digital.ai Release identifier
      - type: xlrelease.StringVariable
        key: releaseUrl
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Release URL
        description: Digital.ai Release URL for Digital.ai Release runner to register
        value: http://host.k3d.internal:5516
      - type: xlrelease.BooleanVariable
        key: createPlatformConnection
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.BooleanVariable
        key: createCloudConnector
        requiresValue: false
        showOnReleaseStart: false
        value: true
      - type: xlrelease.StringVariable
        key: cloudConnectorsResponse
        requiresValue: false
        showOnReleaseStart: false
        label: Output
        description: Output
      - type: xlrelease.StringVariable
        key: agentRuntimesResponse
        requiresValue: false
        showOnReleaseStart: false
        label: Output
        description: Output
      - type: xlrelease.ListStringVariable
        key: agentRuntimeNames
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: latestAgentRuntime
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: agentRuntimeSelect
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Release runner version
        description: Select Agent Runtime that contains Digital.ai Release runner
          configuration
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          variableMapping:
            values: "${agentRuntimeNames}"
      - type: xlrelease.StringVariable
        key: platformAccessToken
        requiresValue: false
        showOnReleaseStart: false
        label: Output
        description: Output
      - type: xlrelease.StringVariable
        key: cloudConnectorId
        requiresValue: false
        showOnReleaseStart: false
        label: Cloud Connector ID
      - type: xlrelease.StringVariable
        key: runnerRegistrationToken
        requiresValue: false
        showOnReleaseStart: false
        label: Runner token
        description: Runner uses this token to call the Digital.ai Release Rest API
      - type: xlrelease.StringVariable
        key: runnerName
        requiresValue: false
        showOnReleaseStart: false
        label: Digital.ai Release runner name
        description: Digital.ai Release runner name to register on Digital.ai Release
        value: runner
      - type: xlrelease.StringVariable
        key: createCloudConnectorResponse
        requiresValue: false
        showOnReleaseStart: false
        label: Output
        description: Output
      - type: xlrelease.StringVariable
        key: agentRuntimeId
        requiresValue: false
        showOnReleaseStart: false
        label: Agent Runtime ID
        description: Agent Runtime ID
      - type: xlrelease.BooleanVariable
        key: runnerInstalled
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: troubleshootAction
        requiresValue: false
        showOnReleaseStart: false
        label: Troubleshoot Action
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - No action needed
          - Change Release URL
        value: No action needed
      - type: xlrelease.StringVariable
        key: createAgentInstanceResponse
        requiresValue: false
        showOnReleaseStart: false
        label: Output
        description: Output
      - type: xlrelease.StringVariable
        key: agentInstanceId
        requiresValue: false
        showOnReleaseStart: false
        label: Agent Instance ID
        description: Agent Instance ID
      - type: xlrelease.StringVariable
        key: platformConnectionId
        requiresValue: false
        showOnReleaseStart: false
        label: Output
        description: Output
      disableNotifications: true
      author: Digital.ai
      defaultTargetFolder: ./Workflow Executions
  - directory: Digital.ai Deploy
    children:
    - template: AWS Lamba setup function with Digital.ai Deploy
      description: "Easily create an application in Digital.ai Deploy that can be\
        \ deployed to AWS Lambda, including its respective environment and infrastructure\
        \ setup."
      scheduledStartDate: 2023-03-23T09:00:00+05:30
      dueDate: 2023-03-23T10:00:00+05:30
      phases:
      - phase: Setup Infra and Env
        tasks:
        - name: Specify Deploy Server Connection
          type: xlrelease.UserInputTask
          description: Select the Digital.ai Deploy Server Connection onto which the
            AWS Lambda application has to be created. You can create a new connection
            if you have not created one.
          variables:
          - deployServer
        - name: Specify Environment Name
          type: xlrelease.UserInputTask
          description: Specify a name for the environment CI that should be created
            for AWS in Digital.ai Deploy server.
          variables:
          - environmentName
        - name: Create Environment
          type: deploy.CreateCI
          description: Creates an Environment CI in Digital.ai Deploy Server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Environments/${environmentName}"
          ciType: udm.Environment
          jsonDescriptor: "{}"
        - name: Specify AWS Connection Parameters
          type: xlrelease.UserInputTask
          description: Specify the connection details for your AWS account.
          variables:
          - awscloudIdentifier
          - accessKey
          - awsAccessSecret
          - awsSessionToken
        - name: Configure AWS Cloud Connection
          type: deploy.CreateCI
          description: Creates an AWS Cloud CI in Digital.ai Deploy Server with the
            credentials specified in the previous task.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${awscloudIdentifier}"
          ciType: aws.Cloud
          jsonDescriptor: |-
            {
                "accesskey":"${accessKey}"
            }
          addToEnvironment: true
          envID: "Environments/${environmentName}"
        - name: Set AWS credentials
          type: deploy.UpdateCIPropertyWithSecretValue
          description: Sets the AWS secret value in the Cloud CI created in Digital.ai
            Deploy server in the previous step.
          variableMapping:
            propertyValue: "${awsAccessSecret}"
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${awscloudIdentifier}"
          ciProperty: accessSecret
        - name: Set AWS Session Token
          type: deploy.UpdateCIPropertyWithSecretValue
          description: Sets the AWS session token (if specified) in the Cloud CI created
            in Digital.ai Deploy Server in the previous step.
          precondition: "releaseVariables['awsSessionToken'] != None and releaseVariables['awsSessionToken']\
            \ != \"\""
          variableMapping:
            propertyValue: "${awsSessionToken}"
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${awscloudIdentifier}"
          ciProperty: sessionToken
        - name: Check AWS Connection
          type: deploy.ControlTask
          description: Checks if the specified AWS credentials are valid by running
            the Check Connection control task on the created AWS Cloud CI in Digital.ai
            Deploy Server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciId: "Infrastructure/${awscloudIdentifier}"
          taskName: checkConnection
          numberOfContinueRetrials: 0
          pollingInterval: 10
          numberOfPollingTrials: 0
          displayStepLogs: true
          connectionRetries: 10
        color: '#3d6c9e'
      - phase: Setup Application
        tasks:
        - name: Specify Application Name
          type: xlrelease.UserInputTask
          description: Specify a name  for the application CI that should be created
            in Digital.ai Deploy server.
          variables:
          - applicationName
        - name: Create Application
          type: deploy.CreateCI
          description: Creates an application in Digital.ai Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}"
          ciType: udm.Application
          jsonDescriptor: "{}"
        - name: Specify Package Name
          type: xlrelease.UserInputTask
          description: Specify a name for the application deployment package that
            should be created in Digital.ai Deploy server.
          variables:
          - packageName
        - name: Create Deployment Package
          type: deploy.CreateCI
          description: Creates an Deployment Package in the Digital.ai Deploy Server
            application created in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/${packageName}"
          ciType: udm.DeploymentPackage
          jsonDescriptor: "{}"
        - name: Specify S3Lambda Parameters
          type: xlrelease.UserInputTask
          description: Specify the inputs for the lambda function to be created in
            the Digital.ai Deploy server.
          variables:
          - functionName
          - bucketName
          - s3Key
          - region
          - runtime
          - role
          - handler
        - name: Create Sample Lambda Deployment from S3
          type: deploy.CreateCI
          description: Creates a lambda deployable CI in Digital.ai Deploy Server
            with the details given in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/${packageName}/sample-lambda"
          ciType: aws.lambda.S3Spec
          jsonDescriptor: |-
            {
                "functionName":"${functionName}",
                "bucketName":"${bucketName}",
                "s3Key":"${s3Key}",
                "region":"${region} ",
                "runtime":"${runtime} ",
                "role":"${role} ",
                "handler":"${handler} "
            }
        - name: Add managed application
          type: managedApplications.CreateApplication
          applicationName: "${applicationName}"
          managedBy: Digital.ai Deploy
          environmentTag: "${environmentName}"
          applicationReference: "${applicationName}"
          description: Adds the lambda application created to the Release Managed
            Application view.
          variableMapping:
            pythonScript.connectionServer: "${deployServer}"
            pythonScript.managedApplicationId: "${managedApplicationId}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Application onboarding
      - Application Life Cycle Management
      - Cloud & Container
      - Serverless
      variables:
      - type: xlrelease.StringVariable
        key: environmentName
        description: Environment CI Name
        value: aws-env
      - type: xlrelease.StringVariable
        key: awscloudIdentifier
        showOnReleaseStart: false
        description: Name of the AWS Cloud CI to be created in Digital.ai Deploy server
        value: aws-cloud
      - type: xlrelease.StringVariable
        key: applicationName
        description: Name of the application CI in Deploy
        value: aws-app
      - type: xlrelease.StringVariable
        key: packageName
        description: Application package name in Deploy
        value: "1.0"
      - type: xlrelease.StringVariable
        key: functionName
        value: functionName
      - type: xlrelease.StringVariable
        key: bucketName
        value: bucketName
      - type: xlrelease.StringVariable
        key: s3Key
        value: s3Key
      - type: xlrelease.StringVariable
        key: region
        value: region
      - type: xlrelease.StringVariable
        key: runtime
        value: runtime
      - type: xlrelease.StringVariable
        key: role
        value: role
      - type: xlrelease.StringVariable
        key: handler
        value: handler
      - type: xlrelease.StringVariable
        key: accessKey
        showOnReleaseStart: false
        description: AWS account access key
      - type: xlrelease.ReferenceVariable
        key: deployServer
        showOnReleaseStart: false
        label: Deploy Server
        description: Connection to Deploy Server
        referencedType: digitalai.DeployServer
      - type: xlrelease.PasswordStringVariable
        key: awsAccessSecret
        showOnReleaseStart: false
        description: AWS account access secret
      - type: xlrelease.PasswordStringVariable
        key: awsSessionToken
        requiresValue: false
        showOnReleaseStart: false
        description: AWS account session token (optional)
      - type: xlrelease.StringVariable
        key: managedApplicationId
        requiresValue: false
        showOnReleaseStart: false
        label: Application ID
        description: Application ID in Digital.ai Release
      allowPasswordsInAllFields: true
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/1ac98caf83f3490046b3268dd58972d304ff6f92/deploy.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: Azure setup application with Digital.ai Deploy
      description: "Seamlessly create an application in Digital.ai Deploy that can\
        \ create Azure resource groups, including its respective environment and infrastructure\
        \ setup."
      scheduledStartDate: 2023-03-23T09:00:00+05:30
      dueDate: 2023-03-23T10:00:00+05:30
      phases:
      - phase: Setup Infra and Env
        tasks:
        - name: Specify Deploy Server Details
          type: xlrelease.UserInputTask
          description: Select the Digital.ai Deploy Server Connection onto which the
            Azure application has to be created. You can create a new connection if
            you have not created one.
          variables:
          - deployServer
        - name: Specify Environment Name
          type: xlrelease.UserInputTask
          description: Specify the name of the environment CI to be created in the
            Digital.ai Deploy Server.
          variables:
          - environmentName
        - name: Create Environment
          type: deploy.CreateCI
          description: Creates an environment CI with the given name in the Digital.ai
            Deploy Server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Environments/${environmentName}"
          ciType: udm.Environment
          jsonDescriptor: "{}"
        - name: Specify Azure Connection Parameters
          type: xlrelease.UserInputTask
          description: Specify the Azure connection details. The Azure Cloud CI in
            the Digital.ai Deploy Server will be created with the specified details.
          variables:
          - azurecloud-identifier
          - subscriptionId
          - tenantId
          - clientId
          - clientSecret
        - name: Configure Azure Connection
          type: deploy.CreateCI
          description: Creates an Azure Cloud CI in the Digital.ai Deploy Server with
            the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${azurecloud-identifier}"
          ciType: azure.Cloud
          jsonDescriptor: |-
            {
                "authMethod":"directory-application-and-service-principal",
                "subscriptionId":"${subscriptionId}",
                "tenantId":"${tenantId}",
                "clientId":"${clientId}"
            }
          addToEnvironment: true
          envID: "Environments/${environmentName}"
        - name: Set Azure Credentials
          type: deploy.UpdateCIPropertyWithSecretValue
          description: Sets the secret information in the previously created Azure
            Cloud CI in Digital.ai Deploy server.
          variableMapping:
            propertyValue: "${clientSecret}"
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${azurecloud-identifier}"
          ciProperty: clientKey
        - name: Check Azure Connection
          type: deploy.ControlTask
          description: Runs a Check Connection control task on the created Azure Cloud
            CI in the Digital.ai Deploy server to validate the specified credentials.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciId: "Infrastructure/${azurecloud-identifier}"
          taskName: checkConnection
          numberOfContinueRetrials: 0
          pollingInterval: 10
          numberOfPollingTrials: 0
          displayStepLogs: true
          connectionRetries: 10
        color: '#3d6c9e'
      - phase: Setup Application
        tasks:
        - name: Specify Application Name
          type: xlrelease.UserInputTask
          description: Specify the name of the application to be created in the Digital.ai
            Deploy server.
          variables:
          - applicationName
        - name: Create Application
          type: deploy.CreateCI
          description: Creates an application with the specified name in the Digital.ai
            Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}"
          ciType: udm.Application
          jsonDescriptor: "{}"
        - name: Specify Package Name
          type: xlrelease.UserInputTask
          description: Specify a package name to be created within the application
            created in Digital.ai Deploy server in the previous step.
          variables:
          - packageName
        - name: Create Deployment Package
          type: deploy.CreateCI
          description: Creates a deployment package with the specfied name in the
            application created in Digital.ai Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/${packageName}"
          ciType: udm.DeploymentPackage
          jsonDescriptor: "{}"
        - name: Specify Resource Group Parameters
          type: xlrelease.UserInputTask
          description: Specify the resource group information which will be used to
            create the application package in Digital.ai Deploy server.
          variables:
          - resourcegroupName
          - resourcegroupLocation
        - name: Create Sample Resource Group
          type: deploy.CreateCI
          description: Creates the Azure Resource Group CI in the Digital.ai Deploy
            server with the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/${packageName}/sample-resource-group"
          ciType: azure.ResourceGroupSpec
          jsonDescriptor: |-
            {
                "location":"${resourcegroupLocation}",
                "resourceGroupName":"${resourcegroupName}"
            }
        - name: Add managed application
          type: managedApplications.CreateApplication
          applicationName: "${applicationName}"
          managedBy: Digital.ai Deploy
          environmentTag: "${environmentName}"
          applicationReference: "${applicationName}"
          description: Adds the created Azure Resource Group application to the Digital.ai
            Release managed application list.
          variableMapping:
            pythonScript.connectionServer: "${deployServer}"
            pythonScript.managedApplicationId: "${managedApplicationId}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Application onboarding
      variables:
      - type: xlrelease.StringVariable
        key: environmentName
        description: Name of the environment CI in Deploy
        value: azure-env
      - type: xlrelease.StringVariable
        key: applicationName
        description: Name of the application CI in Deploy
        value: azure-app
      - type: xlrelease.StringVariable
        key: packageName
        description: Name of the application package in Deploy
        value: "1.0"
      - type: xlrelease.StringVariable
        key: azurecloud-identifier
        description: Name of the Azure Cloud CI
        value: azure-cloud
      - type: xlrelease.StringVariable
        key: clientId
        description: Azure Client Id
        value: client-id
      - type: xlrelease.PasswordStringVariable
        key: clientSecret
        showOnReleaseStart: false
        description: Azure Client Secret
      - type: xlrelease.StringVariable
        key: subscriptionId
        showOnReleaseStart: false
        description: Azure Subscription Id
        value: subscription-id
      - type: xlrelease.StringVariable
        key: tenantId
        description: Azure Tenant Id
        value: tenant-id
      - type: xlrelease.StringVariable
        key: resourcegroupLocation
        description: Location of the Resource Group in Azure
        value: East US
      - type: xlrelease.StringVariable
        key: resourcegroupName
        description: Name of the Resource Group in Azure
        value: resourcegroup-name
      - type: xlrelease.ReferenceVariable
        key: deployServer
        showOnReleaseStart: false
        label: Deploy Server
        description: Connection to the Deploy Server
        referencedType: digitalai.DeployServer
      - type: xlrelease.StringVariable
        key: managedApplicationId
        requiresValue: false
        showOnReleaseStart: false
        label: Application ID
        description: Application ID in Digital.ai Release
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/e937292a6e97a39f3288f478e55578b7efff9ec5/deploy.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: GCP setup application with Digital.ai Deploy
      description: "Seamlessly create an application in Digital.ai Deploy that can\
        \ set up virtual machine instances in GCP, including its respective environment\
        \ and infrastructure configuration."
      scheduledStartDate: 2023-03-31T09:00:00+05:30
      dueDate: 2023-03-31T10:00:00+05:30
      phases:
      - phase: Setup Env and Infra
        tasks:
        - name: Specify Deploy Server Details
          type: xlrelease.UserInputTask
          description: Select the Digital.ai Deploy Server Connection onto which the
            Google Cloud Platform application has to be created. You can create a
            new connection if you have not created one.
          variables:
          - deployServer
        - name: Specify Environment Name
          type: xlrelease.UserInputTask
          description: Specify the name of the environment CI to be created in the
            Digital.ai Deploy Server.
          variables:
          - environmentName
        - name: Create Environment
          type: deploy.CreateCI
          description: Creates an environment CI with the given name in the Digital.ai
            Deploy Server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Environments/${environmentName}"
          ciType: udm.Environment
          jsonDescriptor: "{}"
        - name: Specify Google Account Parameters
          type: xlrelease.UserInputTask
          description: Specify the connection details for the Google cloud platform
            account.
          variables:
          - googleAccountCloudName
          - gcpProjectId
          - gcpClientEmail
          - gcpPrivateKey
        - name: Create Google Account Cloud Infra
          type: deploy.CreateCI
          description: Creates an Google Cloud CI in the Digital.ai Deploy Server
            with the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${googleAccountCloudName}"
          ciType: google.AccountCloud
          jsonDescriptor: |-
            {
                "projectId": "${gcpProjectId}",
                "clientEmail": "${gcpClientEmail}",
                "privateKey": ""
            }
          addToEnvironment: true
          envID: "Environments/${environmentName}"
        - name: Set Google Credentials
          type: deploy.UpdateCIPropertyWithSecretValue
          description: Sets the private key information in the previously created
            Google Cloud CI in Digital.ai Deploy server.
          variableMapping:
            propertyValue: "${gcpPrivateKey}"
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${googleAccountCloudName}"
          ciProperty: privateKey
        - name: Check Connection of Google account
          type: deploy.ControlTask
          description: Runs a Check Connection control task on the created Google
            Cloud CI in the Digital.ai Deploy server to validate the specified credentials.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciId: "Infrastructure/${googleAccountCloudName}"
          taskName: checkConnection
          numberOfContinueRetrials: 0
          pollingInterval: 10
          numberOfPollingTrials: 0
          displayStepLogs: true
          connectionRetries: 10
      - phase: Setup Application
        tasks:
        - name: Specify Application Name
          type: xlrelease.UserInputTask
          description: Specify the name of the application to be created in the Digital.ai
            Deploy server.
          variables:
          - applicationName
        - name: Create Application
          type: deploy.CreateCI
          description: Creates an application with the specified name in the Digital.ai
            Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}"
          ciType: udm.Application
          jsonDescriptor: "{}"
        - name: Specify Package Name
          type: xlrelease.UserInputTask
          description: Specify a package name to be created within the application
            created in Digital.ai Deploy server in the previous step.
          variables:
          - packageName
        - name: Create Deployment Package
          type: deploy.CreateCI
          description: Creates a deployment package with the specfied name in the
            application created in Digital.ai Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/${packageName}"
          ciType: udm.DeploymentPackage
          jsonDescriptor: "{}"
        - name: Specify Intance Spec Parameters
          type: xlrelease.UserInputTask
          description: Specify the Instance specifications which will be used to create
            the application package in Digital.ai Deploy server.
          variables:
          - zone
          - machine
          - image_project
          - image
          - waitTimeForCreate
          - waitTimeForDestroy
        - name: Create Google Instance spec
          type: deploy.CreateCI
          description: Creates the InstanceSpec CI with the specified details in the
            application package created in Digital.ai Deploy server in the previous
            steps.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/${packageName}/${instanceSpecName}"
          ciType: googlecloud.compute.InstanceSpec
          jsonDescriptor: |-
            {
                "zone": "${zone}",
                "machine": "${machine}",
                "imageProject": "${image_project}",
                "image": "${image}",
                "waitOnCreate": "${waitTimeForCreate}",
                "waitOnDestroy": "${waitTimeForDestroy}"
            }
        - name: Add managed application
          type: managedApplications.CreateApplication
          applicationName: "${applicationName}"
          managedBy: Digital.ai Deploy
          environmentTag: "${environmentName}"
          applicationReference: "${applicationName}"
          description: Adds the created GCP Instance application to the Digital.ai
            Release managed application list.
          variableMapping:
            pythonScript.connectionServer: "${deployServer}"
            pythonScript.managedApplicationId: "${managedApplicationId}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Application onboarding
      - Application Life Cycle Management
      - Cloud & Container
      variables:
      - type: xlrelease.StringVariable
        key: environmentName
        description: Name of the environment CI in Deploy
        value: gcp_env
      - type: xlrelease.StringVariable
        key: googleAccountCloudName
        description: Name of Google Cloud CI to be created in Digital.ai Deploy server
        value: google_cloud
      - type: xlrelease.StringVariable
        key: gcpProjectId
        description: Google Cloud Platform project id
        value: gcp_project_id
      - type: xlrelease.PasswordStringVariable
        key: gcpPrivateKey
        showOnReleaseStart: false
        description: Google Cloud Platform account private key
      - type: xlrelease.StringVariable
        key: applicationName
        description: Name of the application CI in Deploy
        value: gcp_app
      - type: xlrelease.StringVariable
        key: packageName
        description: Name of the applicaiton package in Deploy
        value: "1.0"
      - type: xlrelease.StringVariable
        key: instanceSpecName
        description: Name of the Instance Spec CI in Deploy
        value: gcp_instance_spec_name
      - type: xlrelease.StringVariable
        key: machine
        description: The Google machine to use
        value: machine
      - type: xlrelease.StringVariable
        key: image_project
        description: Google Project where the image is stored
        value: image_project
      - type: xlrelease.StringVariable
        key: zone
        description: Instance creation zone
        value: zone
      - type: xlrelease.StringVariable
        key: image
        description: Google image to use
        value: image
      - type: xlrelease.StringVariable
        key: waitTimeForCreate
        description: The time to wait for creation in seconds
        value: wait_for_create
      - type: xlrelease.StringVariable
        key: waitTimeForDestroy
        description: The time to wait for deletion in seconds
        value: wait_time_for_destroy
      - type: xlrelease.StringVariable
        key: gcpClientEmail
        description: Google Cloud Platform client email
        value: gcp_client_email
      - type: xlrelease.ReferenceVariable
        key: deployServer
        showOnReleaseStart: false
        label: Deploy Server
        description: Connection to the Deploy server
        referencedType: digitalai.DeployServer
      - type: xlrelease.StringVariable
        key: managedApplicationId
        requiresValue: false
        showOnReleaseStart: false
        label: Application ID
        description: Application ID in Digital.ai Release
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/a8eb104385bb88959e385eec7b22eb96943650e7/deploy.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: Helm Application Setup with Digital.ai Deploy
      description: "Easily create a Helm application in Digital.ai Deploy that can\
        \ be deployed to a target Kubernetes Cluster, including its respective environment\
        \ and infrastructure setup."
      scheduledStartDate: 2023-03-23T09:00:00+05:30
      dueDate: 2023-03-23T10:00:00+05:30
      phases:
      - phase: Setup Infra and Env
        tasks:
        - name: Specify Run As User
          type: xlrelease.UserInputTask
          description: Specify the Run As user. All automated tasks in the workflow
            will be run as the specified user.
          variables:
          - runAsUsername
          - runAsUserPassword
        - name: Specify Deploy Server Details
          type: xlrelease.UserInputTask
          description: Select the Digital.ai Deploy Server Connection onto which the
            Helm application has to be created. You can create a new connection if
            you have not created one.
          variables:
          - deployServer
        - name: Specify Environment Name
          type: xlrelease.UserInputTask
          description: Specify the name of the environment CI to be created in the
            Digital.ai Deploy Server.
          variables:
          - environmentName
        - name: Create Environment
          type: deploy.CreateCI
          description: Creates an environment CI with the given name in the Digital.ai
            Deploy Server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Environments/${environmentName}"
          ciType: udm.Environment
          jsonDescriptor: "{}"
        - name: Specify Helm Client Host Parameters
          type: xlrelease.UserInputTask
          description: Specify the SSH connection details to the host where the Helm
            Client installation resides.
          variables:
          - hostIdentifier
          - sudoUsername
          - os
          - address
          - port
          - sshUsername
          - sshPrivatekey
        - name: Configure Helm Client Host
          type: deploy.CreateCI
          description: Creates an Overthere SSH Host CI in the Digital.ai Deploy Server
            with the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}"
          ciType: overthere.SshHost
          jsonDescriptor: |-
            {
                "stagingDirectoryPath":"",
                "sudoUsername":"${sudoUsername}",
                "suUsername":"",
                "suPassword":"",
                "os":"${os}",
                "connectionType":"SUDO",
                "address":"${address}",
                "port":"${port}",
                "username":"${sshUsername}",
                "password":"",
                "privateKeyFile":"${sshPrivatekey}",
                "passphrase":""
            }
        - name: Check Helm Client Host Connection
          type: deploy.ControlTask
          description: Runs a Check Connection control task on the created SSH host
            CI in the Digital.ai Deploy server to validate the specified credentials.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciId: "Infrastructure/${hostIdentifier}"
          taskName: checkConnection
          numberOfContinueRetrials: 0
          pollingInterval: 10
          numberOfPollingTrials: 0
          displayStepLogs: true
          connectionRetries: 10
        - name: Specify Helm Client Configuration Details
          type: xlrelease.UserInputTask
          description: Specify the configuration details for the Helm client.
          variables:
          - helmClientName
          - helmClientInstallationPath
          - kubeConfigPath
        - name: Configure Helm Client in Deploy
          type: deploy.CreateCI
          description: Creates an Helm Client CI in the Digital.ai Deploy Server with
            the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}/${helmClientName}"
          ciType: helm.Client
          jsonDescriptor: |-
            {
                "home":"${helmClientInstallationPath}",
                "kubeConfig":"${kubeConfigPath}"
            }
        - name: Specify Kubernetes Cluster Details
          type: xlrelease.UserInputTask
          description: Specify the configuration details of the Kubernetes cluster
            CI to be created in Digital.ai Deploy server.
          variables:
          - kubeMasterName
          - apiServerUrl
          - caCertificate
          - skipTLS
          - tlsCertificate
          - tlsPrivateKey
          - k8sServiceAccountToken
        - name: Configure Kubernetes Master
          type: deploy.CreateCI
          description: Creates a Kubernetes Master CI in the Digital.ai Deploy Server
            with the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${kubeMasterName}"
          ciType: k8s.Master
          jsonDescriptor: |-
            {
                "tlsCert": "${tlsCertificate}",
                "tlsPrivateKey": "${tlsPrivateKey}",
                "apiServerURL": "${apiServerUrl}" ,
                "skipTLS": "${skipTLS}",
                "caCert": "${caCertificate}" ,
                "helmClient": "Infrastructure/${hostIdentifier}/${helmClientName}"
            }
        - name: Update K8s Master token
          type: deploy.UpdateCIPropertyWithSecretValue
          variableMapping:
            propertyValue: "${k8sServiceAccountToken}"
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${kubeMasterName}"
          ciProperty: token
        - name: Check Connection to K8s Master
          type: deploy.ControlTask
          description: Runs a Check Status control task on the created Tomcat server
            CI in the Digital.ai Deploy server to validate the specified credentials.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciId: "Infrastructure/${kubeMasterName}"
          taskName: checkConnection
          numberOfContinueRetrials: 0
          pollingInterval: 10
          numberOfPollingTrials: 0
          displayStepLogs: true
          connectionRetries: 10
        - name: Specify Kubernetes Namespace
          type: xlrelease.UserInputTask
          description: Specify a name for the Kubernetes namespace CI to be created
            in Digital.ai Deploy server.
          variables:
          - kubeNamespace
        - name: Configure Kubernetes Namespace
          type: deploy.CreateCI
          description: Creates a Kubernetes Namespace CI in the Digital.ai Deploy
            Server with the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${kubeMasterName}/${kubeNamespace}"
          ciType: k8s.Namespace
          jsonDescriptor: "{}"
          addToEnvironment: true
          envID: "Environments/${environmentName}"
      - phase: Setup Application
        tasks:
        - name: Specify Application Name
          type: xlrelease.UserInputTask
          description: Specify the name of the application to be created in the Digital.ai
            Deploy server.
          variables:
          - applicationName
        - name: Setup Application
          type: deploy.CreateCI
          description: Creates an application with the specified name in the Digital.ai
            Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}"
          ciType: udm.Application
          jsonDescriptor: "{}"
        - name: Specify Package Name
          type: xlrelease.UserInputTask
          description: Specify a package name to be created within the application
            created in Digital.ai Deploy server in the previous step.
          variables:
          - packageName
        - name: Create Deployment Package
          type: deploy.CreateCI
          description: Creates a deployment package with the specfied name in the
            application created in Digital.ai Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/1.0"
          ciType: udm.DeploymentPackage
          jsonDescriptor: "{}"
        - name: Specify Helm Chart Details
          type: xlrelease.UserInputTask
          description: "Specify the Helm chart details, which will be used to create\
            \ a Helm chart CI in Digital.ai Deploy server."
          variables:
          - helmChartCiName
          - helmChartName
          - chartVersion
          - repositoryUrl
          - addRepository
          - updateRepositories
          - testRelease
        - name: Create Helm Chart CI in Digital.ai Deploy
          type: deploy.CreateCI
          description: Creates a Helm chart CI in the Digital.ai Deploy server with
            the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/${packageName}/${helmChartCiName}"
          ciType: helm.Chart
          jsonDescriptor: |-
            {
                "chartName": "${helmChartName}",
                "chartVersion": "${chartVersion}",
                "testRelease": "${testRelease}",
                "repositoryUrl": "${repositoryUrl}",
                "addRepository": "${addRepository}",
                "updateRepositories": "${updateRepositories}"
            }
        - name: Add Managed Application
          type: xlrelease.ScriptTask
          description: Adds the created Azure Resource Group application to the Digital.ai
            Release managed application list.
          script: |-
            from com.xebialabs.xlrelease.api.v1.views import ManagedApplicationView
            from com.xebialabs.xlrelease.api.v1.views import ConnectionServerView
            from java.util import Date
            from java.text import SimpleDateFormat
            import datetime

            parsedDate = datetime.datetime.now()

            requestBody = ManagedApplicationView()
            requestBody.applicationName = "${applicationName}"
            requestBody.managedBy = "Digital.ai Deploy"
            requestBody.dateCreated = parsedDate
            requestBody.environmentTag = "${environmentName}"
            requestBody.applicationReference = "${applicationName}"

            connectionServer = ConnectionServerView('${deployServer}', '', '', '')
            requestBody.connectionServer = connectionServer

            res = managedApplicationApi.addManagedApplication(requestBody)
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Application onboarding
      - Application Life Cycle Management
      - Cloud & Container
      - Serverless
      variables:
      - type: xlrelease.StringVariable
        key: environmentName
        showOnReleaseStart: false
        label: Environment Name
        description: Name of the environment CI in Deploy
        value: helm-env
      - type: xlrelease.StringVariable
        key: hostIdentifier
        showOnReleaseStart: false
        label: Host Identifier
        description: Name of the SSH host CI to be created in Digital.ai Deploy server
        value: helmclient-host
      - type: xlrelease.StringVariable
        key: address
        label: SSH host address
        description: SSH host address
        value: 1.2.3.4
      - type: xlrelease.StringVariable
        key: os
        showOnReleaseStart: false
        label: OS
        description: UNIX|WINDOWS|ZOS
        value: UNIX
      - type: xlrelease.StringVariable
        key: port
        showOnReleaseStart: false
        label: SSH port
        description: SSH port
        value: "22"
      - type: xlrelease.StringVariable
        key: sshPrivatekey
        showOnReleaseStart: false
        label: Private Key
        description: Path to the SSH key file
        value: private-key-path
      - type: xlrelease.StringVariable
        key: sshUsername
        label: SSH Username
        description: SSH username
        value: ssh-username
      - type: xlrelease.StringVariable
        key: sudoUsername
        showOnReleaseStart: false
        label: SUDO username
        description: SUDO username
        value: sudo-username
      - type: xlrelease.StringVariable
        key: applicationName
        showOnReleaseStart: false
        label: Application Name
        description: Name of the application CI in Deploy
        value: helm-app
      - type: xlrelease.StringVariable
        key: packageName
        showOnReleaseStart: false
        label: Package Name
        description: Name of the application package in Deploy
        value: "1.0"
      - type: xlrelease.StringVariable
        key: helmClientInstallationPath
        showOnReleaseStart: false
        label: Helm Client Installation Path
        description: Helm Client installation home directory
        value: /usr/local/bin
      - type: xlrelease.StringVariable
        key: helmClientName
        description: Name of Helm Client CI in Deploy
        value: helm-client
      - type: xlrelease.StringVariable
        key: virtualHostName
        description: The tomacat virtual hostname in Deploy
        value: virtual-host
      - type: xlrelease.StringVariable
        key: datasourceName
        description: The name of the datasource to create
        value: sample-datasource
      - type: xlrelease.ReferenceVariable
        key: deployServer
        showOnReleaseStart: false
        label: Deploy Server
        description: Connection to the Deploy Server
        referencedType: digitalai.DeployServer
      - type: xlrelease.PasswordStringVariable
        key: runAsUserPassword
        showOnReleaseStart: false
        label: Password
        description: Password for automated tasks user
      - type: xlrelease.StringVariable
        key: runAsUsername
        showOnReleaseStart: false
        label: Run automated tasks as user
        description: Run all automated tasks in this workflow as user
      - type: xlrelease.StringVariable
        key: kubeConfigPath
        requiresValue: false
        showOnReleaseStart: false
        label: KubeConfig Path
        description: Kubeconfig Path
      - type: xlrelease.StringVariable
        key: apiServerUrl
        showOnReleaseStart: false
        label: API ServerUrl
        description: URL for RESTful interface provided by API Server
      - type: xlrelease.BooleanVariable
        key: skipTLS
        requiresValue: false
        showOnReleaseStart: false
        label: Skip TLS
        description: Do not verify using TLS/SSL
      - type: xlrelease.StringVariable
        key: caCertificate
        requiresValue: false
        showOnReleaseStart: false
        label: CA Certificate
        description: Certification authority certificate
      - type: xlrelease.StringVariable
        key: tlsCertificate
        requiresValue: false
        showOnReleaseStart: false
        label: TLS Certificate
        description: TLS certificate for master server
      - type: xlrelease.StringVariable
        key: tlsPrivateKey
        requiresValue: false
        showOnReleaseStart: false
        label: TLS Private Key
        description: TLS private key for master server
      - type: xlrelease.StringVariable
        key: serviceAccountToken
        requiresValue: false
        showOnReleaseStart: false
        label: Service Account Token
        description: Service account token
      - type: xlrelease.StringVariable
        key: kubeMasterName
        showOnReleaseStart: false
        label: Kubernetes Master CI Name
        description: Kubernetes Master CI Name
        value: kubernetes-master
      - type: xlrelease.StringVariable
        key: kubeNamespace
        showOnReleaseStart: false
        label: Kubernetes Namespace
        description: Kubernetes Namspace
      - type: xlrelease.StringVariable
        key: helmChartCiName
        showOnReleaseStart: false
        label: Helm Chart CI Name
        description: Helm Chart CI Name
        value: sample-chart
      - type: xlrelease.StringVariable
        key: helmChartName
        showOnReleaseStart: false
        label: Helm Chart Name
        description: Helm Chart CI Name (Repo name/chart name)
        value: bitnami/redis
      - type: xlrelease.StringVariable
        key: chartVersion
        showOnReleaseStart: false
        label: Chart Version
        description: Helm chart version
        value: 19.0.1
      - type: xlrelease.StringVariable
        key: repositoryUrl
        showOnReleaseStart: false
        label: Repository URL
        description: Helm repository URL
        value: https://charts.bitnami.com/bitnami
      - type: xlrelease.BooleanVariable
        key: testRelease
        requiresValue: false
        showOnReleaseStart: false
        label: Test Release
        description: Test Release
        value: true
      - type: xlrelease.BooleanVariable
        key: addRepository
        showOnReleaseStart: false
        label: Add Repository
        description: Add repository
        value: true
      - type: xlrelease.BooleanVariable
        key: updateRepositories
        showOnReleaseStart: false
        label: Update Repositories
        description: Update Repositories
        value: true
      - type: xlrelease.PasswordStringVariable
        key: k8sServiceAccountToken
        requiresValue: false
        showOnReleaseStart: false
        label: Service Account Token
        description: Service Account Token
      disableNotifications: true
      scriptUsername: "${runAsUsername}"
      variableMapping:
        scriptUserPassword: "${runAsUserPassword}"
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/1336d33f613cec76ae8d02f10c5e6f34da6ac0a7/helm.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: Tomcat DataSource setup with Digital.ai Deploy
      description: "Easily create an application in Digital.ai Deploy that can be\
        \ used to create a DataSource in a Remote Tomcat Server, including its respective\
        \ environment and infrastructure setup."
      scheduledStartDate: 2023-03-23T09:00:00+05:30
      dueDate: 2023-03-23T10:00:00+05:30
      phases:
      - phase: Setup Infra and Env
        tasks:
        - name: Specify Deploy Server Details
          type: xlrelease.UserInputTask
          description: Select the Digital.ai Deploy Server Connection onto which the
            Tomcat application has to be created. You can create a new connection
            if you have not created one.
          variables:
          - deployServer
        - name: Specify Environment Name
          type: xlrelease.UserInputTask
          description: Specify the name of the environment CI to be created in the
            Digital.ai Deploy Server.
          variables:
          - environmentName
        - name: Create Environment
          type: deploy.CreateCI
          description: Creates an environment CI with the given name in the Digital.ai
            Deploy Server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Environments/${environmentName}"
          ciType: udm.Environment
          jsonDescriptor: "{}"
        - name: Specify Tomcat Host Parameters
          type: xlrelease.UserInputTask
          description: Specify the SSH connection details to the host where the Tomcat
            installation resides.
          variables:
          - hostIdentifier
          - sudoUsername
          - os
          - address
          - port
          - sshUsername
          - sshPrivatekey
        - name: Configure Remote Host
          type: deploy.CreateCI
          description: Creates an Overthere SSH Host CI in the Digital.ai Deploy Server
            with the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}"
          ciType: overthere.SshHost
          jsonDescriptor: |-
            {
                "stagingDirectoryPath":"",
                "sudoUsername":"${sudoUsername}",
                "suUsername":"",
                "suPassword":"",
                "os":"${os}",
                "connectionType":"SUDO",
                "address":"${address}",
                "port":"${port}",
                "username":"${sshUsername}",
                "password":"",
                "privateKeyFile":"${sshPrivatekey}",
                "passphrase":""
            }
          addToEnvironment: true
          envID: "Environments/${environmentName}"
        - name: Check Remote Host Connection
          type: deploy.ControlTask
          description: Runs a Check Connection control task on the created SSH host
            CI in the Digital.ai Deploy server to validate the specified credentials.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciId: "Infrastructure/${hostIdentifier}"
          taskName: checkConnection
          numberOfContinueRetrials: 0
          pollingInterval: 10
          numberOfPollingTrials: 0
          displayStepLogs: true
          connectionRetries: 10
        - name: Specify Tomcat Server Parameters
          type: xlrelease.UserInputTask
          description: Specify the Tomcat installation details.
          variables:
          - serverName
          - tomcatHome
          - tomcatStartCommand
          - tomcatStopCommand
          - tomcatStatusCommand
          - tomcatStatusExptectedOutput
        - name: Configure Tomcat Server
          type: deploy.CreateCI
          description: Creates an Tomcat server CI in the Digital.ai Deploy Server
            with the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}/${serverName}"
          ciType: tomcat.Server
          jsonDescriptor: |-
            {
                "home":"${tomcatHome}",
                "startCommand":"${tomcatStartCommand}",
                "stopCommand":"${tomcatStopCommand}",
                "statusCommand":"${tomcatStatusCommand}",
                "statusCommandExpectedOutput":"${tomcatStatusExptectedOutput}",
                "startWaitTime":"0",
                "stopWaitTime":"0",
                "serverStartupTime":"0",
                "serverShutdownTime":"0",
                "tomcatRunningPort":""
            }
          addToEnvironment: true
          envID: "Environments/${environmentName}"
        - name: Check Tomcat Status
          type: deploy.ControlTask
          description: Runs a Check Status control task on the created Tomcat server
            CI in the Digital.ai Deploy server to validate the specified credentials.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciId: "Infrastructure/${hostIdentifier}/${serverName}"
          taskName: status
          numberOfContinueRetrials: 0
          pollingInterval: 10
          numberOfPollingTrials: 0
          displayStepLogs: true
          connectionRetries: 10
        - name: Specify Tomcat Virtual Host Name
          type: xlrelease.UserInputTask
          description: Specify the name of the virtual host CI to be created within
            the Tomcat serverCI in Digital.ai Deploy server.
          variables:
          - virtualHostName
        - name: Configure Tomcat VirtualHost
          type: deploy.CreateCI
          description: Creates an Tomcat VirtualHost CI in the Digital.ai Deploy Server
            with the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}/${serverName}/${virtualHostName}"
          ciType: tomcat.VirtualHost
          jsonDescriptor: "{}"
          addToEnvironment: true
          envID: "Environments/${environmentName}"
      - phase: Setup Application
        tasks:
        - name: Specify Application Name
          type: xlrelease.UserInputTask
          description: Specify the name of the application to be created in the Digital.ai
            Deploy server.
          variables:
          - applicationName
        - name: Setup Application
          type: deploy.CreateCI
          description: Creates an application with the specified name in the Digital.ai
            Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}"
          ciType: udm.Application
          jsonDescriptor: "{}"
        - name: Specify Package Name
          type: xlrelease.UserInputTask
          description: Specify a package name to be created within the application
            created in Digital.ai Deploy server in the previous step.
          variables:
          - packageName
        - name: Create Deployment Package
          type: deploy.CreateCI
          description: Creates a deployment package with the specfied name in the
            application created in Digital.ai Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/1.0"
          ciType: udm.DeploymentPackage
          jsonDescriptor: "{}"
        - name: Specify Tomcat Datasource
          type: xlrelease.UserInputTask
          description: "Specify the Tomcat dataSource inforrmation, which will be\
            \ used to create a DataSourceSpec CI in Digital.ai Deploy server."
          variables:
          - datasourceName
          - jndiName
          - datasourceContext
          - databaseDriverClassName
          - databaseUrl
          - dbUsername
          - dbPassword
        - name: Create Sample Tomcat DataSourceSpec
          type: deploy.CreateCI
          description: Creates the Tomcat DataSource CI in the Digital.ai Deploy server
            with the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/${packageName}/${datasourceName}"
          ciType: tomcat.DataSourceSpec
          jsonDescriptor: |-
            {
                "context":"${datasourceContext}",
                "jndiName":"${jndiName}",
                "driverClassName":"${databaseDriverClassName}",
                "url":"${databaseUrl}",
                "username":"${dbUsername}",
                "password":"${dbPassword}"
            }
        - name: Add managed application
          type: managedApplications.CreateApplication
          applicationName: "${applicationName}"
          managedBy: Digital.ai Deploy
          environmentTag: "${environmentName}"
          applicationReference: "${applicationName}"
          description: Adds the created Azure Resource Group application to the Digital.ai
            Release managed application list.
          variableMapping:
            pythonScript.connectionServer: "${deployServer}"
            pythonScript.managedApplicationId: "${managedApplicationId}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Application onboarding
      variables:
      - type: xlrelease.StringVariable
        key: environmentName
        description: Name of the environment CI in Deploy
        value: tomcat-env
      - type: xlrelease.StringVariable
        key: hostIdentifier
        description: Name of the SSH host CI to be created in Digital.ai Deploy server
        value: tomcat-host
      - type: xlrelease.StringVariable
        key: address
        description: SSH host address
        value: 1.2.3.4
      - type: xlrelease.StringVariable
        key: os
        description: UNIX|WINDOWS|ZOS
        value: UNIX
      - type: xlrelease.StringVariable
        key: port
        description: SSH port
        value: "22"
      - type: xlrelease.StringVariable
        key: sshPrivatekey
        description: Path to the SSH key file
        value: private-key-path
      - type: xlrelease.StringVariable
        key: sshUsername
        description: SSH username
        value: ssh-username
      - type: xlrelease.StringVariable
        key: sudoUsername
        description: SUDO username
        value: sudo-username
      - type: xlrelease.StringVariable
        key: applicationName
        description: Name of the application CI in Deploy
        value: tomcat-app
      - type: xlrelease.StringVariable
        key: packageName
        description: Name of the application package in Deploy
        value: "1.0"
      - type: xlrelease.StringVariable
        key: tomcatHome
        description: Tomcat installation home directory
        value: tomcat-home
      - type: xlrelease.StringVariable
        key: tomcatStartCommand
        description: Command to start the tomcat server
        value: systemctl start tomcat
      - type: xlrelease.StringVariable
        key: tomcatStatusCommand
        value: systemctl status tomcat
      - type: xlrelease.StringVariable
        key: tomcatStatusExptectedOutput
        description: Output of status command to expect to determine running state
        value: active (running)
      - type: xlrelease.StringVariable
        key: tomcatStopCommand
        description: Command to stop Tomcat server
        value: systemctl stop tomcat
      - type: xlrelease.StringVariable
        key: databaseUrl
        description: JDBC url on the DB connection
        value: database url
      - type: xlrelease.StringVariable
        key: databaseDriverClassName
        description: JDBC driver class name
        value: database-driver-class-name
      - type: xlrelease.StringVariable
        key: datasourceContext
        description: The data source context
        value: datasource-context
      - type: xlrelease.StringVariable
        key: dbPassword
        description: Database password
        value: db-password
      - type: xlrelease.StringVariable
        key: dbUsername
        description: Database username
        value: db-username
      - type: xlrelease.StringVariable
        key: jndiName
        description: JNDI name
        value: jndi-name
      - type: xlrelease.StringVariable
        key: serverName
        description: Name of Tomcat Server CI in Deploy
        value: tomcat-server
      - type: xlrelease.StringVariable
        key: virtualHostName
        description: The tomacat virtual hostname in Deploy
        value: virtual-host
      - type: xlrelease.StringVariable
        key: datasourceName
        description: The name of the datasource to create
        value: sample-datasource
      - type: xlrelease.ReferenceVariable
        key: deployServer
        showOnReleaseStart: false
        label: Deploy Server
        description: Connection to the Deploy Server
        referencedType: digitalai.DeployServer
      - type: xlrelease.StringVariable
        key: managedApplicationId
        requiresValue: false
        showOnReleaseStart: false
        label: Application ID
        description: Application ID in Digital.ai Release
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/7579ca5778047fc369c49e6192a1621666292282/deploy.svg"
      defaultTargetFolder: ./Workflow Executions
    - template: Websphere JaasAlias setup with Digital.ai Deploy
      description: "Easily create an application in Digital.ai Deploy that can be\
        \ used to create a JaasAlias in a remote Websphere Server, including its respective\
        \ environment and infrastructure setup."
      scheduledStartDate: 2023-02-14T09:00:00+05:30
      dueDate: 2023-02-14T10:00:00+05:30
      phases:
      - phase: Setup Infra and Env
        tasks:
        - name: Specify Deploy Server Details
          type: xlrelease.UserInputTask
          description: Select the Digital.ai Deploy Server Connection onto which the
            Websphere application has to be created. You can create a new connection
            if you have not created one.
          variables:
          - deployServer
        - name: Specify Environment Name
          type: xlrelease.UserInputTask
          description: Specify a name for the environment CI that should be created
            for AWS in Digital.ai Deploy server.
          variables:
          - environmentName
        - name: Create Environment
          type: deploy.CreateCI
          description: Creates an Environment CI in Digital.ai Deploy Server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Environments/${environmentName}"
          ciType: udm.Environment
          jsonDescriptor: "{}"
        - name: Specify WAS Host Parameters
          type: xlrelease.UserInputTask
          description: Specify the SSH connection details to connect to the Webshere
            hosting machine.
          variables:
          - hostIdentifier
          - sudoUsername
          - os
          - connectionType
          - address
          - sshUsername
          - sshPassword
        - name: Configure Remote Host
          type: deploy.CreateCI
          description: Creates an Overthere SSH host CI in Digital.ai Deploy Server
            using the details specified in the previous step.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}"
          ciType: overthere.SshHost
          jsonDescriptor: |-
            {
                "stagingDirectoryPath":"",
                "sudoUsername":"${sudoUsername}",
                "suUsername":"",
                "suPassword":"",
                "os":"${os}",
                "connectionType":"${connectionType}",
                "address":"${address}",
                "port":22,
                "username":"${sshUsername}",
                "privateKeyFile":"",
                "passphrase":""
            }
        - name: Set WAS Host Credentials
          type: deploy.UpdateCIPropertyWithSecretValue
          description: Sets the SSH password in the previously created Host CI in
            Digital.ai Deploy server.
          variableMapping:
            propertyValue: "${sshPassword}"
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}"
          ciProperty: password
        - name: Check Remote Host Connection
          type: deploy.ControlTask
          description: Runs a Check Connection control task on the created SSH host
            CI in the Digital.ai Deploy server to validate the specified credentials.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciId: "Infrastructure/${hostIdentifier}"
          taskName: checkConnection
          numberOfContinueRetrials: 0
          pollingInterval: 10
          numberOfPollingTrials: 0
          displayStepLogs: true
          connectionRetries: 10
        - name: Specify WAS Deployment Manager Parameters
          type: xlrelease.UserInputTask
          description: Specify the connection details for Webshere.
          variables:
          - cellName
          - wasHome
          - wasUsername
          - wasPassword
        - name: Configure Websphere Deployment Manager
          type: deploy.CreateCI
          description: Creates a Websphere Deployment Manager CI in the Digital.ai
            Deploy server using the details specified in the previous tasks.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}/${cellName}"
          ciType: was.DeploymentManager
          jsonDescriptor: |-
            {
                "wasHome": "${wasHome}",
                "username": "${wasUsername}",
                "version": "WAS_90"
            }
          addToEnvironment: true
          envID: "Environments/${environmentName}"
        - name: Set Websphere Credentials
          type: deploy.UpdateCIPropertyWithSecretValue
          description: Sets the Websphere password in the previously created Deployment
            Manager CI.
          variableMapping:
            propertyValue: "${wasPassword}"
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}/${cellName}"
          ciProperty: password
        - name: Specify WAS Node Agent Parameters
          type: xlrelease.UserInputTask
          description: Specify the name of the Websphere Node Agent CI to be created
            in Digital.ai Deploy Server.
          variables:
          - nodeName
        - name: Configure Websphere Node Agent
          type: deploy.CreateCI
          description: Creates a Websphere Node Agent CI in the Digital.ai Deploy
            server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}/${cellName}/${nodeName}"
          ciType: was.NodeAgent
          jsonDescriptor: "{}"
          addToEnvironment: true
          envID: "Environments/${environmentName}"
        - name: Specify WAS Server Parameters
          type: xlrelease.UserInputTask
          description: Specify the name of the Websphere Server CI to be created in
            the Digital.ai Deploy server.
          variables:
          - serverName
        - name: Configure Websphere Server
          type: deploy.CreateCI
          description: Creates a Websphere Server CI in the Digital.ai Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}/${cellName}/${nodeName}/${serverName}"
          ciType: was.ManagedServer
          jsonDescriptor: "{}"
          addToEnvironment: true
          envID: "Environments/${environmentName}"
        color: '#3d6c9e'
      - phase: Setup Application
        tasks:
        - name: Specify WAS Application Name
          type: xlrelease.UserInputTask
          description: Specify the name of the application to be created in the Digital.ai
            Deploy server.
          variables:
          - applicationName
        - name: Create Application
          type: deploy.CreateCI
          description: Creates an application with the specified name in the Digital.ai
            Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}"
          ciType: udm.Application
          jsonDescriptor: "{}"
        - name: Specify Deployment Package
          type: xlrelease.UserInputTask
          description: Specify a package name to be created within the application
            created in Digital.ai Deploy server in the previous step.
          variables:
          - packageName
        - name: Create Deployment Package
          type: deploy.CreateCI
          description: Creates a deployment package with the specfied name in the
            application created in Digital.ai Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/${packageName}"
          ciType: udm.DeploymentPackage
          jsonDescriptor: "{}"
        - name: Specify WAS JaasAliasSpec Parameters
          type: xlrelease.UserInputTask
          description: Specify the JASS Alias name and password. this will be used
            to create the application package in the Digital.ai Deploy server.
          variables:
          - jaasUsername
          - jaasPassword
        - name: Create Sample WAS JaasAliasSpec
          type: deploy.CreateCI
          description: Creates the JASS AliasSpec CI in the application package in
            Digital.ai Deploy server.
          variableMapping:
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Applications/${applicationName}/${packageName}/${jaas-alias-name}"
          ciType: was.JaasAliasSpec
          jsonDescriptor: |-
            {
            "username": "${jaasUsername}"
            }
        - name: Set JaasAlias Password
          type: deploy.UpdateCIPropertyWithSecretValue
          description: Sets the sensitive password information in the created JAAS
            AliasSpec CI created in the previous step.
          variableMapping:
            propertyValue: "${jaasPassword}"
            server: "${deployServer}"
          capabilities:
          - remote
          ciID: "Infrastructure/${hostIdentifier}"
          ciProperty: password
        - name: Add managed application
          type: managedApplications.CreateApplication
          applicationName: "${applicationName}"
          managedBy: Digital.ai Deploy
          environmentTag: "${environmentName}"
          applicationReference: "${applicationName}"
          description: Adds the created Websphere application to the Digital.ai Release
            managed application list.
          variableMapping:
            pythonScript.connectionServer: "${deployServer}"
            pythonScript.managedApplicationId: "${managedApplicationId}"
        color: '#3d6c9e'
      kind: WORKFLOW
      categories:
      - Application onboarding
      variables:
      - type: xlrelease.StringVariable
        key: environmentName
        description: Name of the environment CI in Deploy
        value: was-env
      - type: xlrelease.StringVariable
        key: hostIdentifier
        description: Name of the Host CI in Deploy
        value: was-host
      - type: xlrelease.StringVariable
        key: os
        description: Operating system of the remote host
        value: UNIX
      - type: xlrelease.StringVariable
        key: address
        description: Address of the webpshere host
        value: 1.2.3.4
      - type: xlrelease.StringVariable
        key: connectionType
        description: Connection type to the websphere host
        value: SUDO
      - type: xlrelease.StringVariable
        key: sshUsername
        description: SSH username to remote host
        value: ssh-username
      - type: xlrelease.PasswordStringVariable
        key: sshPassword
        showOnReleaseStart: false
        description: SSH password to the remote host
      - type: xlrelease.StringVariable
        key: sudoUsername
        description: SUDO username for the SSH connection
        value: sudo-username
      - type: xlrelease.StringVariable
        key: applicationName
        description: Name of the application CI in Deploy
        value: was-application
      - type: xlrelease.StringVariable
        key: packageName
        description: Name of the application package in Deploy
        value: "1.0"
      - type: xlrelease.StringVariable
        key: cellName
        description: Websphere Cell name
        value: was-cell-1
      - type: xlrelease.StringVariable
        key: wasHome
        description: Websphere installation directory
        value: /opt/IBM/WebSphere/AppServer-1/profiles/Dmgr01
      - type: xlrelease.StringVariable
        key: wasUsername
        description: Webpshere username
        value: admin
      - type: xlrelease.PasswordStringVariable
        key: wasPassword
        showOnReleaseStart: false
        description: Websphere password
      - type: xlrelease.StringVariable
        key: wasVersion
        description: Version of Websphere installation
        value: WAS_90
      - type: xlrelease.StringVariable
        key: nodeName
        description: Websphere node name
        value: was-node-1
      - type: xlrelease.StringVariable
        key: serverName
        description: Websphere server name
        value: was-server-1
      - type: xlrelease.StringVariable
        key: jaasUsername
        description: JAAS Alias username
        value: admin
      - type: xlrelease.PasswordStringVariable
        key: jaasPassword
        showOnReleaseStart: false
        description: JAAS Alias password
      - type: xlrelease.ReferenceVariable
        key: deployServer
        showOnReleaseStart: false
        label: Deploy Server
        description: Connection to the Deploy server
        referencedType: digitalai.DeployServer
      - type: xlrelease.StringVariable
        key: jaas-alias-name
        description: JAAS Alias name
        value: Sample JAAS Alias
      - type: xlrelease.StringVariable
        key: managedApplicationId
        requiresValue: false
        showOnReleaseStart: false
        label: Application ID
        description: Application ID in Digital.ai Release
      disableNotifications: true
      author: Digital.ai
      logo:
        type: xlrelease.TemplateLogo
        contentType: image/svg+xml
        file: !file "template-logo/9dda4235a32e0a48f98fd815771690a722aeb812/deploy.svg"
      defaultTargetFolder: ./Workflow Executions
- directory: Templates
  children:
  - directory: Governance Pipeline
    children:
    - template: Financial Institution Governance Pipeline
      description: '**This template is an example of release governance for a financial
        institution. It shows the various compliance and governance checks before
        each deployment gate and also the artifact certification process to ensure
        the right artifact is deployed.**'
      scheduledStartDate: 2018-03-08T19:30:00+05:30
      dueDate: 2018-03-08T20:30:00+05:30
      phases:
      - phase: dev
        tasks:
        - name: Acknowledge/sign off release code quality metrics
          type: xlrelease.SequentialGroup
          description: This is an example of grouping all tasks which are part of
            one function. All Sonarqube related tasks in this case have been grouped
            on one sequential group.
          precondition: "releaseVariables['enable_sonar_metrics_check'] == 'Yes'"
          tags:
          - key_process_step
          tasks:
          - name: Delete Existing SonarQube token
            type: webhook.JsonWebhook
            URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
            method: POST
            username: "${global.cross_connect_userid}"
            variableMapping:
              pythonScript.password: "${global.cross_connect_password}"
          - name: Generate SonarQube token
            type: webhook.JsonWebhook
            URL: "${global.sonarurl}/api/user_tokens/generate?name=${spkComponentsToRelease}"
            method: POST
            username: "${global.cross_connect_userid}"
            jsonPathExpression: $.token
            variableMapping:
              pythonScript.result: "${SonarQube_token}"
              pythonScript.password: "${global.cross_connect_password}"
          - name: "Reading SonarQube Metrics for  ${sonarComponentKey}"
            type: xlrelease.ScriptTask
            script: |-
              import urllib2
              import json
              import base64

              # defining the api-endpoint

              url="${global.sonarurl}/api/measures/component?componentKey=${sonarComponentKey}&metricKeys=alert_status,bugs,blocker_violations,critical_violations,vulnerabilities,code_smells,duplicated_blocks,duplicated_lines_density,ncloc"

              print("URL....", url)

              token = releaseVariables['SonarQube_token'] + ":"
              encodedToken =  base64.encodestring(token).rstrip('\n')
              print ("Encodedtoken= ", encodedToken)

              req=urllib2.Request(url=url)
              req.add_header('Authorization', "Basic %s" % encodedToken)
              req.add_header("Content-Type", "application/json")

              jobResponse=urllib2.urlopen(req).read()

              print("JOB Response", jobResponse)

              json_data = json.loads(jobResponse)

              print ("\n JSON DATA....",json_data)

              metrics_data = {}
              for item in json_data['component']['measures']:
                  metrics_data[item['metric']] = item['value']

              releaseVariables['sonarqube_bugs']  = int(metrics_data.get('bugs'))

              releaseVariables['sonarqube_blocker_violations']  = int(metrics_data.get('blocker_violations'))

              releaseVariables['sonarqube_critical_violations']  = int(metrics_data.get('critical_violations'))
              releaseVariables['sonarqube_vulnerabilities'] = int(metrics_data.get('vulnerabilities'))
              releaseVariables['sonarqube_code_smells'] = int(metrics_data.get('code_smells'))
              releaseVariables['sonarqube_duplicated_blocks'] = int(metrics_data.get('duplicated_blocks'))
              releaseVariables['sonarqube_duplicated_lines_density'] = metrics_data.get('duplicated_lines_density')
              releaseVariables['sonarqube_ncloc'] = int(metrics_data.get('ncloc'))

              gg = metrics_data.get('alert_status')

              if gg == "OK":
                  releaseVariables['sonarqube_quality_gate'] = "PASSED"

              if gg == "ERROR":
                 releaseVariables['sonarqube_quality_gate'] = "FAILED"
          - name: Delete SonarQube token
            type: webhook.JsonWebhook
            URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
            method: POST
            username: "${global.cross_connect_userid}"
            variableMapping:
              pythonScript.password: "${global.cross_connect_password}"
          - name: Sign off on SonarQube metrics for the release
            type: xlrelease.GateTask
            description: |-
              - Quality Gate :  ${sonarqube_quality_gate}
              - Bugs: ${sonarqube_bugs}
              - Blocker Violations: ${sonarqube_blocker_violations}
              - Critical Violations: ${sonarqube_critical_violations}
              - Vulnerabilities: ${sonarqube_vulnerabilities}
              - Code Smells: ${sonarqube_code_smells}
              - Duplicated Blocks: ${sonarqube_duplicated_blocks}
              - Duplicated Line Density: ${sonarqube_duplicated_lines_density}
              - Lines of Code: ${sonarqube_ncloc}
            tags:
            - key_process_step
        - name: Pre-tasks for DMZ deployment
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: Validate Inventory configured in tower Job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: $..inventory
            variableMapping:
              pythonScript.result: "${ansible_template_inventory_name}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: Get Inventory name from Tower Job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: "results[0].summary_fields.inventory.name"
            precondition: "releaseVariables['ansible_template_inventory_name']!=\"\
              [null]\""
            variableMapping:
              pythonScript.result: "${tower_job_inventory_name}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: Validate inventory
            type: xlrelease.ScriptTask
            script: |-
              if releaseVariables['ansible_template_inventory_name']!='[null]' and releaseVariables['xlr_inventory_name']!="":
                  if releaseVariables['tower_job_inventory_name'] == releaseVariables['xlr_inventory_name']:
                      print "Inventory name in XLR and Tower are same, Good to go!"
                  elif releaseVariables['tower_job_inventory_name'] != releaseVariables['xlr_inventory_name']:
                     print "Ansible tower job_template '${ansible_tower_job_template_name}' is not correctly configured to accept an inventory as input, please update the tower job_template with ('prompt on launch')"
                     sys.exit(1)
              elif releaseVariables['ansible_template_inventory_name']=='[null]' and releaseVariables['xlr_inventory_name']=="":
                  print "Ansible tower job_template '${ansible_tower_job_template_name}'is not configured with an inventory name, please configure valid inventory name"
                  sys.exit(1)
              print "Validation looks Good !"
          - name: Construct Instance group url  from ansible Job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: "results[0].related.instance_groups"
            variableMapping:
              pythonScript.password: "${nonprod_tower_deployer_password}"
              pythonScript.result: "${ansible_tower_job_template_instance_group_url}"
          - name: Get Instance group details from instance group url
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}${ansible_tower_job_template_instance_group_url}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: results
            variableMapping:
              pythonScript.result: "${ansible_tower_instance_group_from_template}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: Get Ansible inventory id from XLR template
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/inventories?name=${xlr_inventory_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: "results[0].id"
            precondition: "releaseVariables['xlr_inventory_name'] !=\"\""
            variableMapping:
              pythonScript.result: "${ansible_tower_job_inventory}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: Get Inventory id from ansible job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: "results[0].summary_fields.inventory.id"
            precondition: "releaseVariables['xlr_inventory_name'] ==\"\""
            variableMapping:
              pythonScript.result: "${ansible_tower_job_inventory}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: Get Ansible Instance group from inventory id
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/inventories/${ansible_tower_job_inventory}/instance_groups"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: results
            variableMapping:
              pythonScript.password: "${nonprod_tower_deployer_password}"
              pythonScript.result: "${ansible_tower_instance_group}"
          - name: "Determine Artifactory: DMZ or Baronet"
            type: xlrelease.ScriptTask
            script: |-
              releaseVariables['deployDMZ_dev']="No"
              releaseVariables['ansible_tower_job_inventory_id']=0
              jobtemplate_deploydmz ="No"
              inventory_deploydmz = "No"
              instance_group_match ="No"
              if releaseVariables['xlr_inventory_name'] =="":
                  releaseVariables['ansible_tower_job_inventory_id']=0
              elif releaseVariables['xlr_inventory_name'] !="":
                  releaseVariables['ansible_tower_job_inventory_id'] = int (releaseVariables['ansible_tower_job_inventory'])
              print ("Inventory_id passing from XLR to Tower job template =>",releaseVariables['ansible_tower_job_inventory_id'])

              if "ztwr" in releaseVariables['ansible_tower_instance_group']:
                  inventory_deploydmz="Yes"
              elif "ztwr" not in releaseVariables['ansible_tower_instance_group']:
                  inventory_deploydmz="No"
              if inventory_deploydmz =="No":
                  if "ztwr" not in releaseVariables['ansible_tower_instance_group'] and releaseVariables['ansible_tower_instance_group'] !="[]":
                      inventory_instance_grp = "Yes"
                  elif releaseVariables['ansible_tower_instance_group'] =="[]":
                      inventory_instance_grp = "No"
                  print ("inventory_instance_grp==>", inventory_instance_grp)

              if "ztwr" in releaseVariables['ansible_tower_instance_group_from_template']:
                  jobtemplate_deploydmz="Yes"
              elif "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template']:
                  jobtemplate_deploydmz = "No"

              if jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="Yes":
                  print """Instance group in inventory configured with non-DMZ but instance group in tower job template configured with DMZ \n Always job template instance group take precedence, so please configure your Tower job template properly"""
                  sys.exit(1)
              elif jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="No":
                  releaseVariables['deployDMZ_dev'] = "Yes"
              elif jobtemplate_deploydmz == "Yes" and inventory_deploydmz=="Yes":
                  if "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  elif "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  elif "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  elif "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  if instance_group_match == "Yes":
                      releaseVariables['deployDMZ_dev'] = "Yes"
                  else:
                      print """DMZ instance group configured in inventory does not match with DMZ instance group configured in job template...\n Please configure them correctly!!"""
                      sys.exit(1)

              if jobtemplate_deploydmz=="No":
                  if "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template'] and releaseVariables['ansible_tower_instance_group_from_template'] !="[]":
                      template_instance_grp = "Yes"
                  elif releaseVariables['ansible_tower_instance_group_from_template'] =="[]":
                      template_instance_grp = "No"
                  print ("template_instance_grp==>", template_instance_grp)
                  if template_instance_grp == "Yes" and inventory_deploydmz=="Yes":
                      print """Your inventory's instance group configured with DMZ But Your job template's instance group not configured with DMZ. \n Always job template instance group take precedence, so please configure your Tower job template properly"""
                      releaseVariables['deployDMZ_dev'] = "No"
                      sys.exit(1)
                  elif template_instance_grp == "No" and inventory_deploydmz=="Yes":
                      releaseVariables['deployDMZ_dev'] = "Yes"
                  elif template_instance_grp == "No" and inventory_deploydmz=="No":
                      releaseVariables['deployDMZ_dev'] = "No"
              print ("inventory_dmz==>", inventory_deploydmz)
              print ("jobtemplate_dmz==>", jobtemplate_deploydmz)
              print("<-------------------deployDMZ---------->", releaseVariables['deployDMZ_dev'])
        - name: Get build artifact version (s) to deploy
          type: xlrelease.SequentialGroup
          tasks:
          - name: Artifactory API key generation
            type: xlrelease.SequentialGroup
            description: '### This task will generate encrypted API key that can be
              used in the fetch artifact version script tasks of this release template'
            tasks:
            - name: GET
              type: webhook.JsonWebhook
              URL: "${global.artifactoryurl}/api/security/apiKey"
              username: "${global.cross_connect_userid}"
              jsonPathExpression: $.apiKey
              variableMapping:
                pythonScript.result: "${ArtifactoryAPIkey}"
                pythonScript.password: "${global.cross_connect_password}"
          - name: Get build artifact's latest version
            type: xlrelease.ScriptTask
            description: "#### This task will get latest version of the build artifact\
              \  ####"
            script: |-
              import urllib2
              import json

              artifactoryUrl="${global.artifactoryurl}/api/search/aql"

              def getArtifactDetails(repo_name,build_artifact_name):
                  data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"created\").sort({\"$desc\":[\"created\"]})" %(repo_name,build_artifact_name)
                  artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
                  artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
                  artifactoryRequest.add_header("Content-Type", "text/plain")
                  artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
                  artifactData = json.loads(artifactoryResponse)

                  data1="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"path\":{\"$match\":\"%s\"}},{\"name\":{\"$match\":\"%s\"}}).include(\"name\",\"repo\",\"path\",\"created\",\"property\",\"artifact.module.build.url\")" %(repo_name,build_artifact_name,artifactData["results"][0]["path"],artifactData["results"][0]["name"])
                  artifactoryRequest1=urllib2.Request(url=artifactoryUrl,data=data1)
                  artifactoryRequest1.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
                  artifactoryRequest1.add_header("Content-Type", "text/plain")
                  jobResponse1=urllib2.urlopen(artifactoryRequest1).read()
                  artifactData1 = json.loads(jobResponse1)

                  releaseVariables["artifact_build_version_ciurl_var"]=artifactData1["results"][0]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]

                  certification_history = ""
                  for i in xrange(len(artifactData1["results"][0]["properties"])):
                      if ("Certified" in artifactData1["results"][0]["properties"][i]["key"]):
                          certification_history="\n\n" + artifactData1["results"][0]["properties"][i]["key"] + "=" + artifactData1["results"][0]["properties"][i]["value"]+ "\n\n" + certification_history
                      if (artifactData1["results"][0]["properties"][i]["key"] == "ait.number"):
                          releaseVariables["artifact_build_version_ait_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "scm.location"):
                          releaseVariables["artifact_build_version_scmloc_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "build.number"):
                          releaseVariables["artifact_build_version_buildnum_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "scm.branch"):
                          releaseVariables["artifact_build_version_scmbranch_var"]=artifactData1["results"][0]["properties"][i]["value"]

                  releaseVariables["artifactory_certification_history"]=certification_history

                  data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"created\").sort({\"$desc\":[\"created\"]})" %(repo_name,build_artifact_name,releaseVariables["artifact_build_version_buildnum_var"])
                  artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
                  artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
                  artifactoryRequest2.add_header("Content-Type", "text/plain")
                  jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
                  artifactData2 = json.loads(jobResponse2)

                  mylist=""
                  for index in range(len(artifactData2["results"])):
                      artifact_build_version_var="artifact_build_version_var_"+str(index)
                      releaseVariables[artifact_build_version_var]=artifactData2["results"][index]["name"]
                      data_url="${global.artifactoryurl}"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
                      if(mylist==""):
                          mylist=data_url
                      else:
                          mylist=mylist+","+data_url

                  if ',' in mylist:
                      mylist=mylist.replace(",","', '")
                      mylist= "['"+mylist+"']"

                  releaseVariables["artifact_build_version_artifactoryUrl"] = mylist



              getArtifactDetails("${artifactoryBuildRepo}","${artifactoryBuildName}")

              releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"
              releaseVariables["old_artifact_build_version_artifactoryUrl"]=releaseVariables["artifact_build_version_artifactoryUrl"]
              releaseVariables["old_artifact_build_version_buildnum_var"]=releaseVariables["artifact_build_version_buildnum_var"]
        - name: Deployment approval by Deployer DEV team
          type: xlrelease.UserInputTask
          description: |-
            #### Hello Deployer ${delivery_environment_type} Team :-
            ${phase_certified_artifact_property} ${phase_certified_artifact_version}

            Tower job template ${ansible_tower_job_template_name} will deploy the following build to ${delivery_environment_name}

            ${artifact_build_version_artifactorybrowseUrl}

            Certification History:
            ${artifactory_certification_history}

            Click "Complete" to to kick off deployment job in tower
          precondition: "\"${phaseEnablePreDeployGate_dev}\".lower() == \"yes\""
          tags:
          - key_process_step
          variables:
          - artifact_build_version_artifactoryUrl
          - artifact_build_version_buildnum_var
          - nonprod_tower_deployer_id
          - nonprod_tower_deployer_password
        - name: Deploy application changes/build
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: Construct artifactory url for deployment
            type: xlrelease.ScriptTask
            description: "#### This task will get latest version of the build artifact\
              \  ####"
            script: |-
              import urllib2
              import json

              artifactoryUrl="${global.artifactoryurl}/api/search/aql"
              myNewUrl="${artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
              myNewUrl=myNewUrl.replace("webapp/#/artifacts/browse/tree/General/","")
              myNewUrl=myNewUrl.replace("${artifactoryBuildRepo}/","")
              myNewUrl=myNewUrl.replace("[","")
              myNewUrl=myNewUrl.replace("]","")
              myNewUrl=myNewUrl.replace("'","")
              myNewUrlList=myNewUrl.split(",")


              myOldUrl="${old_artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
              myOldUrl=myOldUrl.replace("webapp/#/artifacts/browse/tree/General/","")
              myOldUrl=myOldUrl.replace("${artifactoryBuildRepo}/","")
              myOldUrl=myOldUrl.replace("[","")
              myOldUrl=myOldUrl.replace("]","")
              myOldUrl=myOldUrl.replace("'","")
              myOldUrlList=myOldUrl.split(",")


              def GetFinalArtifactUrlList(buildNumber):
                  data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"created\").sort({\"$desc\":[\"created\"]})" %("${artifactoryBuildRepo}","${artifactoryBuildName}",buildNumber)
                  artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
                  artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
                  artifactoryRequest2.add_header("Content-Type", "text/plain")
                  jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
                  artifactData2 = json.loads(jobResponse2)

                  mylist=""
                  for index in range(len(artifactData2["results"])):
                      artifact_build_version_var="artifact_build_version_var_"+str(index)
                      releaseVariables[artifact_build_version_var]=artifactData2["results"][index]["name"]
                      data_url="${global.artifactoryurl}"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
                      if(mylist==""):
                          mylist=data_url
                      else:
                          mylist=mylist+","+data_url

                  if ',' in mylist:
                      mylist=mylist.replace(",","', '")
                      mylist= "['"+mylist+"']"

                  releaseVariables["artifact_build_version_artifactoryUrl"] = mylist
                  releaseVariables["artifact_build_version_path_var"]=artifactData2["results"][index]["path"]
                  releaseVariables["artifact_build_version_name_var"]=artifactData2["results"][index]["name"]

              def GetFinalArtifactData(myPathName,myArtifactName):
                  data1="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"path\":{\"$match\":\"%s\"}},{\"name\":{\"$match\":\"%s\"}}).include(\"name\",\"repo\",\"path\",\"created\",\"property\",\"artifact.module.build.url\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}",myPathName,myArtifactName)
                  artifactoryRequest1=urllib2.Request(url=artifactoryUrl,data=data1)
                  artifactoryRequest1.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
                  artifactoryRequest1.add_header("Content-Type", "text/plain")
                  jobResponse1=urllib2.urlopen(artifactoryRequest1).read()
                  artifactData1 = json.loads(jobResponse1)

                  releaseVariables["artifact_build_version_ciurl_var"]=artifactData1["results"][0]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]

                  for i in xrange(len(artifactData1["results"][0]["properties"])):
                      if (artifactData1["results"][0]["properties"][i]["key"] == "ait.number"):
                          releaseVariables["artifact_build_version_ait_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "scm.location"):
                          releaseVariables["artifact_build_version_scmloc_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "build.number"):
                          releaseVariables["artifact_build_version_buildnum_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "scm.branch"):
                          releaseVariables["artifact_build_version_scmbranch_var"]=artifactData1["results"][0]["properties"][i]["value"]

              if "${old_artifact_build_version_buildnum_var}" != "${artifact_build_version_buildnum_var}":
                  GetFinalArtifactUrlList("${artifact_build_version_buildnum_var}")
                  GetFinalArtifactData(releaseVariables["artifact_build_version_path_var"],releaseVariables["artifact_build_version_name_var"])
              elif myNewUrlList[0] not in myOldUrlList:
                  myNewUrl=myNewUrlList[0].rsplit('/', 1)
                  GetFinalArtifactData(myNewUrl[0],myNewUrl[1])

              releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"


              ### Set Deployment Dashboard parameters

              spkName = "${spkName}".upper().strip()
              delivery_environment_name = "${delivery_environment_name}".upper().strip()
              dashboard_delivery_environment_name = spkName + "-" + delivery_environment_name
              releaseVariables['dashboard_delivery_environment_name'] = dashboard_delivery_environment_name

              # ID
              dashboard_deployerId = str(dashboard_delivery_environment_name) + "-deployerId"
              releaseVariables[dashboard_deployerId] = "${nonprod_tower_deployer_id}"

              ###XLR DMZ Integration
              if releaseVariables['deployDMZ_dev']=="Yes":
                      releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl'].replace("${global.artifactoryurl}","${global.dmzArtifactoryUrl_NonProd}")
              else:
                  releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl']
              print("deployDMZ_dev==", releaseVariables['deployDMZ_dev'])
              print("Artifactory URL==", releaseVariables['published_artifact_url'])
          - name: Get job template id
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: "results[0].id"
            variableMapping:
              pythonScript.result: "${ansible_tower_job_template_id}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: "Deploy ${artifactoryBuildName}"
            type: ansible.RunPlaybook
            description: "## Deploy ${artifactoryBuildName}"
            flagComment: "Task 'Deploy ${artifactoryBuildName}' in Phase 'dev' has\
              \ been replaced by a manual task. The task of type 'ansible.LaunchJobTemplate'\
              \ could not be found because of a missing plugin."
            facets:
            - type: udm.DeploymentTaskFacet
              variableMapping:
                environmentId: "${dashboard_delivery_environment_name}"
                applicationId: "${component_name}"
                version: "${artifact_build_version_buildnum_var}"
            variableMapping:
              pythonScript.jobId: "${ansible_job_id}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
              pythonScript.inventory: "${ansible_tower_job_inventory_id}"
            tags:
            - key_process_step
          - name: Fetch ansible job log
            type: xlrelease.ScriptTask
            description: "#### This task will get latest version of the build artifact\
              \  ####"
            script: "releaseVariables[\"ansible_tower_job_url\"]=\"${global.ansible-non-prod-towerurl}/#/jobs/${ansible_job_id}\""
        - name: Kick off litmus tests
          type: xlrelease.SequentialGroup
          precondition: "\"${litmus_enable_automated_tests}\" == \"yes\""
          tags:
          - key_process_step
          tasks:
          - name: Validate LitmusTest input
            type: xlrelease.ScriptTask
            script: |-
              val = "${artifact_build_version_ait_var}"
              if not val: raise ValueError("ait_number is mandatory parameter for LitmusTest execution.")

              val = "${litmus_test_component}"
              if not val: raise ValueError("litmusComponentName is mandatory parameter for LitmusTest execution. Please fill it with valid value for your environment.")

              val = "${litmus_test_url}"
              if not val: raise ValueError("litmusTargetApplicationUrl is mandatory parameter for LitmusTest execution.Please fill it with valid value for your environment.")

              val = "${litmus_spk}"
              if not val: raise ValueError("litmus_spk is mandatory parameter for LitmusTest execution.")

              releaseVariables['litmus_input_validated'] = True
          - name: Submit Litmus Request
            type: xlrelease.ScriptTask
            precondition: "releaseVariables['litmus_input_validated'] == True"
            script: |-
              import urllib2
              import json
              import datetime
              import sys

              payload = {
                "BuildRunID": "" ,
                "AIT": "${artifact_build_version_ait_var}",
                "SPK": "${litmus_spk}",
                "JobStatus": "New",
                "DeployedDate": str(datetime.datetime.now()),
                "TestPhase": "${litmus_phase}",
                "ApplicationURL": "${litmus_app_url}",
                "EnvironmentName": "${delivery_environment_name}",
                "Component": "${litmus_test_component}",
                "Requestor":"XLR"
              }
              print("Req to be submitted to LitmusTest is - \n")
              print(payload)

              # Send req to Litmus
              data=json.dumps(payload)

              baseURL = "${litmus_test_url}"
              if not baseURL.endswith("/"):
                  baseURL = baseURL +"/"
              url = baseURL+"LitmusTest/InsertEvent"

              req=urllib2.Request(url=url ,data=data)
              req.add_header("Content-Type", "application/json")
              response=urllib2.urlopen(req).read()
              message = json.loads(response)
              print("\nResponse received-\n")
              print(message)
              requestStatus = message["requestStatus"]
              releaseVariables['litmus_request_id'] = message["requestId"]
              if requestStatus == "Request has been successfully queued.":
                releaseVariables['req_submitted'] = True
                print("\nRequest has been submitted to LitmusTest with requestId - "+ str(message["requestId"]))
              else:
                  print("\nRequest could not be submitted to LitmusTest.\n")
                  print (requestStatus)
                  print("\n")
                  sys.exit(1)
          - name: Process Response
            type: xlrelease.SequentialGroup
            precondition: "releaseVariables['req_submitted'] == True"
            tasks:
            - name: Process Smoke Test Response
              type: xlrelease.ScriptTask
              script: |-
                import json
                import urllib2
                import time
                import sys

                payload = {
                    "requestId":${litmus_request_id}
                }

                # Send req to Litmus for status check
                data = json.dumps(payload)
                baseURL = "${litmus_test_url}"
                if not baseURL.endswith("/"):
                    baseURL = baseURL + "/"
                url = baseURL + "LitmusTest/GetRequestStatus"

                timePassed = 0
                timeoutOccured = True
                while (timePassed < int(${litmus_smoke_timeout})):
                    time.sleep(${litmus_polling_interval})
                    timePassed = timePassed + ${litmus_polling_interval}

                    req = urllib2.Request(url=url, data=data)
                    req.add_header("Content-Type", "application/json")
                    response = urllib2.urlopen(req).read()
                    message = json.loads(response)

                    executingStatus = message["executingStatus"]
                    returnCode = message["executingState"]
                    index = returnCode.find("(")
                    shortCode = returnCode
                    if index != -1:
                        shortCode = returnCode[:returnCode.find("(")]
                    shortCode = shortCode.lower()

                    if (executingStatus == 'Waiting' or executingStatus == 'Smoke Executing'):
                        continue
                    print(message)
                    print("\n")
                    print("\n")
                    timeoutOccured = False
                    executionDetails = message["executionDetails"]
                    if (executingStatus.__contains__("Executing")):
                        if (shortCode == "smoke_pass1"):
                            print("\nSmoke Test passed, Basic Test is scheduled.")
                            releaseVariables['litmus_process_basic'] = True
                        elif (shortCode == "smoke_pass2"):
                            print("\nSmoke Passed, Regression Test is scheduled")
                            releaseVariables['litmus_process_regression'] = True
                        elif (shortCode == "basic_pass"):
                            print("\nBasic Passed, Regression Test is scheduled")
                            releaseVariables['litmus_process_regression'] = True
                        else:
                            print("\nInvalid executing state received.\n")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + eDetail["threshold"])
                    elif (executingStatus == 'Complete'):
                        if (shortCode == "request complete"):
                            print("\nRequest has been successfully completed.\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            releaseVariables['litmus_test_passed'] = True
                        elif (shortCode.__contains__("error")):
                            print("\nError occurred.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        elif (shortCode.__contains__("_fail")):
                            print("\nRequest failed.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        else:
                            print("\nInvalid executing state received.\n")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    else:
                        print("\nInvalid executing status received.\n")
                        print(executingStatus)
                        print("\n")
                        sys.exit(1)
                    break
                if timeoutOccured:
                    print("\nTimeout occurred.\n")
                    sys.exit(1)
            - name: Process Basic Test Response
              type: xlrelease.ScriptTask
              precondition: "releaseVariables['litmus_process_basic'] == True"
              script: |-
                import json
                import urllib2
                import time
                import sys

                payload = {
                    "requestId":${litmus_request_id}
                }

                # Send req to Litmus for status check
                data = json.dumps(payload)
                baseURL = "${litmus_test_url}"
                if not baseURL.endswith("/"):
                    baseURL = baseURL + "/"
                url = baseURL + "LitmusTest/GetRequestStatus"

                timePassed = 0
                timeoutOccured = True
                while (timePassed < int(${litmus_basic_timeout})):
                    time.sleep(${litmus_polling_interval})
                    timePassed = timePassed + ${litmus_polling_interval}

                    req = urllib2.Request(url=url, data=data)
                    req.add_header("Content-Type", "application/json")
                    response = urllib2.urlopen(req).read()
                    message = json.loads(response)
                    executingStatus = message["executingStatus"]
                    returnCode = message["executingState"]
                    index = returnCode.find("(")
                    shortCode = returnCode
                    if index != -1:
                        shortCode = returnCode[:returnCode.find("(")]
                    shortCode = shortCode.lower()

                    if (executingStatus == 'Basic Executing'):
                        continue
                    print(message)
                    print("\n")
                    print("\n")
                    timeoutOccured = False
                    executionDetails = message["executionDetails"]
                    if (executingStatus == "Regression Executing"):
                        if (shortCode == "basic_pass"):
                            print("\nBasic Passed, Regression Test is scheduled\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            releaseVariables['litmus_process_regression'] = True
                        else:
                            print("\nInvalid executing state received.\n")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    elif (executingStatus == 'Complete'):
                        if (shortCode == "request complete"):
                            print("\nRequest has been successfully completed.\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            releaseVariables['litmus_test_passed'] = True
                        elif (shortCode.__contains__("error")):
                            print("\nError occurred.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        elif (shortCode.__contains__("_fail")):
                            print("\nRequest failed.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        else:
                            print("\nInvalid executing state received.")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    else:
                        print("\nInvalid executing status received.\n")
                        print(executingStatus)
                        print("\n")
                        sys.exit(1)
                    break
                if timeoutOccured:
                    print("\nTimeout occurred.\n")
                    sys.exit(1)
            - name: Process Regression Test Response
              type: xlrelease.ScriptTask
              precondition: "releaseVariables['litmus_process_regression'] == True"
              script: |-
                import json
                import urllib2
                import time
                import sys

                payload = {
                  "requestId":${litmus_request_id}
                }

                # Send req to Litmus for status check
                data = json.dumps(payload)
                baseURL = "${litmus_test_url}"
                if not baseURL.endswith("/"):
                    baseURL = baseURL +"/"
                url = baseURL+"LitmusTest/GetRequestStatus"

                timePassed = 0
                timeoutOccured = True
                while (timePassed < int(${litmus_regression_timeout})):
                    time.sleep(${litmus_polling_interval})
                    timePassed = timePassed+ ${litmus_polling_interval}

                    req = urllib2.Request(url=url, data=data)
                    req.add_header("Content-Type", "application/json")
                    response = urllib2.urlopen(req).read()
                    message = json.loads(response)

                    executingStatus = message["executingStatus"]
                    returnCode = message["executingState"]
                    index = returnCode.find("(")
                    shortCode = returnCode
                    if index != -1:
                        shortCode = returnCode[:returnCode.find("(")]
                    shortCode = shortCode.lower()
                    if (executingStatus == 'Regression Executing' ):
                        continue
                    print(message)
                    print("\n")
                    print("\n")
                    timeoutOccured = False
                    executionDetails = message["executionDetails"]
                    if(executingStatus == 'Complete'):
                        if(shortCode == "request complete"):
                            print("\nRequest has been successfully completed.\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                            releaseVariables['litmus_test_passed'] = True
                        elif(shortCode.__contains__("error")):
                            print("\nError occurred.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        elif (shortCode.__contains__("_fail")):
                            print("\nRequest failed.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        else:
                            print("\nInvalid executing state received.")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    else:
                        print("\nInvalid executing status received.\n")
                        print(executingStatus)
                        print("\n")
                        sys.exit(1)
                    break
                if timeoutOccured:
                    print("\nTimeout occurred.\n")
                    sys.exit(1)
            - name: Sign off LitmusTest execution
              type: xlrelease.GateTask
              description: |-
                #### Hello Quality Engineer ${delivery_environment_type} Team :-

                Please review litmus test results and click "complete" to sign off.
              tags:
              - key_process_step
        - name: Post deployment certification by Quality Engineer DEV team
          type: xlrelease.GateTask
          description: |-
            #### Hello Quality Engineer ${delivery_environment_type} Team :-

            Can ${artifact_build_version_artifactoryUrl} be marked ${delivery_environment_name}-Certified=true in Artifactory ?

            Click "Complete" to confirm
          precondition: "\"${phaseEnablePostDeployGate_dev}\".lower() == \"yes\""
          tags:
          - key_process_step
          conditions:
          - name: "Tests executed, results reviewed. Build looks good ! OK to certify?"
            type: xlrelease.GateCondition
        - name: Certify build artifact version (s)
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: "Mark the artifact  ${artifactoryBuildName} certified in artifactory"
            type: xlrelease.ScriptTask
            tags:
            - key_process_step
            script: |-
              ### Set Deployment Dashboard parameters

              dashboard_delivery_environment_name = "${dashboard_delivery_environment_name}"
              dashboard_certStatus = str(dashboard_delivery_environment_name) + "-certStatus"
              ######

              full_url = "${artifact_build_version_artifactoryUrl}"
              urls_list = full_url.split(",")

              for myurl in urls_list:
                  api_call_url=myurl.replace("'","")
                  api_call_url=api_call_url.replace("[","")
                  api_call_url=api_call_url.replace("]","")
                  api_call_url=api_call_url.replace(" ","")
                  api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

                  artifact_url_to_update=api_call_url+"?properties="+"${delivery_environment_name}"+"-Certified=Yes"
                  request = HttpRequest({'url': '${global.artifactoryurl}'})
                  headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                  response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                  status = response.getStatus()

                  if response.getStatus() == 204:
                      releaseVariables[dashboard_certStatus] = 'Certified'
                      print myurl, " have been certified"
                      print '\n'
                  else:
                      print myurl, " could not be certified"
                      sys.exit(1)
          - name: "Mark Build Number:${artifact_build_version_buildnum_var} as a Release\
              \ Candidate"
            type: xlrelease.ScriptTask
            tags:
            - key_process_step
            script: |-
              import urllib2
              import json

              artifactoryUrl="${global.artifactoryurl}/api/search/aql"

              data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"property\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}")
              artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
              artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest.add_header("Content-Type", "text/plain")
              artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
              artifactData = json.loads(artifactoryResponse)
              print type(artifactData)

              #UnTag the Previous Release Candidate
              mylist=""
              for i in xrange(len(artifactData["results"])):
                  for j in xrange(len(artifactData["results"][i]["properties"])):
                      if (artifactData["results"][i]["properties"][j]["key"] == "${release_candidate_name}-Certified" and artifactData["results"][i]["properties"][j]["value"] == "Yes"):
                          artifact_url_to_update="/api/storage"+"/"+artifactData["results"][i]["repo"]+"/"+artifactData["results"][i]["path"]+"/"+artifactData["results"][i]["name"]+"?properties="+"${release_candidate_name}"+"-Certified=No"
                          request = HttpRequest({'url': '${global.artifactoryurl}'})
                          headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                          response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                          status = response.getStatus()


              #Tag the current build as Release Candidate
              full_url = "${artifact_build_version_artifactoryUrl}"
              urls_list = full_url.split(",")
              for myurl in urls_list:
                  api_call_url=myurl.replace("'","")
                  api_call_url=api_call_url.replace("[","")
                  api_call_url=api_call_url.replace("]","")
                  api_call_url=api_call_url.replace(" ","")
                  api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

                  artifact_url_to_update=api_call_url+"?properties="+"${release_candidate_name}"+"-Certified=Yes"
                  request = HttpRequest({'url': '${global.artifactoryurl}'})
                  headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                  response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                  status = response.getStatus()
                  if response.getStatus() == 204:
                      print myurl, " have been certified as a Release Candidate"
                      print '\n'
                  else:
                      print myurl, " could not be certified as a Release Candidate"
                      sys.exit(1)
          - name: Phase certification summary
            type: xlrelease.ScriptTask
            script: |-
              #phase_certified_artifact_version_name="phase_certified_artifact_version_"+"${component_name}"
              releaseVariables["phase_certified_artifact_version_name"] = "${artifact_build_version_artifactoryUrl}"

              #phase_certified_artifact_property_name = "phase_certified_artifact_property_"+"${component_name}"
              releaseVariables["phase_certified_artifact_property_name"] = "${delivery_environment_name}-Certified"
        - name: Closure
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: Compile Email Notification
            type: xlrelease.ScriptTask
            script: |-
              releaseVariables["email_body"] = "${spkName} ${component_name} has been successfully"
              releaseVariables["email_body_content"] =""
              phase_Title = getCurrentPhase().getTitle()
              release_Id = getCurrentRelease().getId()
              print("phase_Title==", phase_Title)
              print("Current release_Id", release_Id)
              deploy = getTasksByTitle("Deploy ${artifactoryBuildName}", phaseTitle = phase_Title, releaseId = release_Id)
              litmus = getTasksByTitle("Sign off LitmusTest execution", phaseTitle = phase_Title, releaseId = release_Id)
              cert = getTasksByTitle("Post deployment certification by Quality Engineer DEV team", phaseTitle = phase_Title, releaseId = release_Id)
              if len(deploy) != 0 and deploy[0]['status'] == "COMPLETED":
                  releaseVariables["email_body"] = releaseVariables["email_body"]+" deployed "
                  releaseVariables["email_body_content"] = "- #### Deployed artifacts: \n ${artifact_build_version_artifactorybrowseUrl} \n" + "- #### Refer the below url for tower job details: \n ${ansible_tower_job_url}"

              if len(litmus)!=0 and litmus[0]['status'] == "COMPLETED":
                  releaseVariables["email_body"] = releaseVariables["email_body"]+", litmus test executed "

              if len(cert)!=0 and cert[0]['status'] == "COMPLETED":
                  releaseVariables["email_body"] = releaseVariables["email_body"]+"& certified"
              if deploy[0]['status'] =="SKIPPED" and litmus[0]['status']=="SKIPPED" and cert[0]['status'] == "SKIPPED":
                  releaseVariables["email_body"] ="Deployment, Litmus test execution and certification of ${spkName} ${component_name} has been skipped"

              releaseVariables["email_body"] = releaseVariables["email_body"]+" in ${delivery_environment_name}"
              print("Deploy status ==", deploy[0]['status'])
              print("Litmus status ==", litmus[0]['status'])
              print ("Cert status ===", cert[0]['status'])
              print(releaseVariables["email_body"])
          - name: Send release notification
            type: xlrelease.NotificationTask
            description: "#### Send email notification for ${delivery_environment_name}\
              \ release ####"
            tags:
            - key_process_step
            addresses:
            - "${release_notification_list}"
            subject: "${spkName} ${component_name} release to ${delivery_environment_name}"
            body: |-
              #### ${email_body}

              ${email_body_content}

              - #### Refer release pipeline below for more info via 2 available options (flow view , table view):
              ${delivery_pipeline_url}
        color: '#009CDB'
      - phase: pre-prod
        tasks:
        - name: Acknowledge/sign off release code quality metrics
          type: xlrelease.SequentialGroup
          precondition: "releaseVariables['enable_sonar_metrics_check'] == 'Yes'"
          tags:
          - key_process_step
          tasks:
          - name: Delete Existing SonarQube token
            type: webhook.JsonWebhook
            URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
            method: POST
            username: "${global.cross_connect_userid}"
            variableMapping:
              pythonScript.password: "${global.cross_connect_password}"
          - name: Generate SonarQube token
            type: webhook.JsonWebhook
            URL: "${global.sonarurl}/api/user_tokens/generate?name=${spkComponentsToRelease}"
            method: POST
            username: "${global.cross_connect_userid}"
            jsonPathExpression: $.token
            variableMapping:
              pythonScript.result: "${SonarQube_token}"
              pythonScript.password: "${global.cross_connect_password}"
          - name: "Reading SonarQube Metrics for  ${sonarComponentKey}"
            type: xlrelease.ScriptTask
            script: |-
              import urllib2
              import json
              import base64

              # defining the api-endpoint

              url="${global.sonarurl}/api/measures/component?componentKey=${sonarComponentKey}&metricKeys=alert_status,bugs,blocker_violations,critical_violations,vulnerabilities,code_smells,duplicated_blocks,duplicated_lines_density,ncloc"

              print("URL....", url)

              token = releaseVariables['SonarQube_token'] + ":"
              encodedToken =  base64.encodestring(token).rstrip('\n')
              print ("Encodedtoken= ", encodedToken)

              req=urllib2.Request(url=url)
              req.add_header('Authorization', "Basic %s" % encodedToken)
              req.add_header("Content-Type", "application/json")

              jobResponse=urllib2.urlopen(req).read()

              print("JOB Response", jobResponse)

              json_data = json.loads(jobResponse)

              print ("\n JSON DATA....",json_data)

              metrics_data = {}
              for item in json_data['component']['measures']:
                  metrics_data[item['metric']] = item['value']

              releaseVariables['sonarqube_bugs']  = int(metrics_data.get('bugs'))

              releaseVariables['sonarqube_blocker_violations']  = int(metrics_data.get('blocker_violations'))

              releaseVariables['sonarqube_critical_violations']  = int(metrics_data.get('critical_violations'))
              releaseVariables['sonarqube_vulnerabilities'] = int(metrics_data.get('vulnerabilities'))
              releaseVariables['sonarqube_code_smells'] = int(metrics_data.get('code_smells'))
              releaseVariables['sonarqube_duplicated_blocks'] = int(metrics_data.get('duplicated_blocks'))
              releaseVariables['sonarqube_duplicated_lines_density'] = metrics_data.get('duplicated_lines_density')
              releaseVariables['sonarqube_ncloc'] = int(metrics_data.get('ncloc'))

              gg = metrics_data.get('alert_status')

              if gg == "OK":
                  releaseVariables['sonarqube_quality_gate'] = "PASSED"

              if gg == "ERROR":
                 releaseVariables['sonarqube_quality_gate'] = "FAILED"
          - name: Delete SonarQube token
            type: webhook.JsonWebhook
            URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
            method: POST
            username: "${global.cross_connect_userid}"
            variableMapping:
              pythonScript.password: "${global.cross_connect_password}"
          - name: Sign off on SonarQube metrics for the release
            type: xlrelease.GateTask
            description: |-
              - Quality Gate :  ${sonarqube_quality_gate}
              - Bugs: ${sonarqube_bugs}
              - Blocker Violations: ${sonarqube_blocker_violations}
              - Critical Violations: ${sonarqube_critical_violations}
              - Vulnerabilities: ${sonarqube_vulnerabilities}
              - Code Smells: ${sonarqube_code_smells}
              - Duplicated Blocks: ${sonarqube_duplicated_blocks}
              - Duplicated Line Density: ${sonarqube_duplicated_lines_density}
              - Lines of Code: ${sonarqube_ncloc}
            tags:
            - key_process_step
        - name: Pre-tasks for DMZ deployment
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: Validate Inventory configured in tower Job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: $..inventory
            variableMapping:
              pythonScript.result: "${ansible_template_inventory_name}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: Get Inventory name from Tower Job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: "results[0].summary_fields.inventory.name"
            precondition: "releaseVariables['ansible_template_inventory_name']!=\"\
              [null]\""
            variableMapping:
              pythonScript.result: "${tower_job_inventory_name}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: Validate inventory
            type: xlrelease.ScriptTask
            script: |-
              if releaseVariables['ansible_template_inventory_name']!='[null]' and releaseVariables['xlr_inventory_name']!="":
                  if releaseVariables['tower_job_inventory_name'] == releaseVariables['xlr_inventory_name']:
                      print "Inventory name in XLR and Tower are same, Good to go!"
                  elif releaseVariables['tower_job_inventory_name'] != releaseVariables['xlr_inventory_name']:
                     print """Ansible tower job_template '${ansible_tower_job_template_name}' is not correctly configured to accept an inventory as input \n Please remove inventory name and update the tower job_template with ('prompt on launch')"""
                     sys.exit(1)
              elif releaseVariables['ansible_template_inventory_name']=='[null]' and releaseVariables['xlr_inventory_name']=="":
                  print "Ansible tower job_template '${ansible_tower_job_template_name}'is not configured with an inventory name, please configure valid inventory name"
                  sys.exit(1)
              print "Validation looks Good !"
          - name: Construct Instance group url  from ansible Job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: "results[0].related.instance_groups"
            variableMapping:
              pythonScript.password: "${nonprod_tower_deployer_password}"
              pythonScript.result: "${ansible_tower_job_template_instance_group_url}"
          - name: Get Instance group details from instance group url
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}${ansible_tower_job_template_instance_group_url}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: results
            variableMapping:
              pythonScript.result: "${ansible_tower_instance_group_from_template}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: Get Ansible inventory id from XLR template
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/inventories?name=${xlr_inventory_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: "results[0].id"
            precondition: "releaseVariables['xlr_inventory_name'] !=\"\""
            variableMapping:
              pythonScript.result: "${ansible_tower_job_inventory}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: Get Inventory id from ansible job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: "results[0].summary_fields.inventory.id"
            precondition: "releaseVariables['xlr_inventory_name'] ==\"\""
            variableMapping:
              pythonScript.result: "${ansible_tower_job_inventory}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: Get Ansible Instance group from inventory id
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/inventories/${ansible_tower_job_inventory}/instance_groups"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: results
            variableMapping:
              pythonScript.password: "${nonprod_tower_deployer_password}"
              pythonScript.result: "${ansible_tower_instance_group}"
          - name: "Determine Artifactory : DMZ or Baronet"
            type: xlrelease.ScriptTask
            script: |-
              releaseVariables['deployDMZ_lle']="No"
              releaseVariables['ansible_tower_job_inventory_id']=0
              jobtemplate_deploydmz ="No"
              inventory_deploydmz = "No"
              instance_group_match ="No"
              if releaseVariables['xlr_inventory_name'] =="":
                  releaseVariables['ansible_tower_job_inventory_id']=0
              elif releaseVariables['xlr_inventory_name'] !="":
                  releaseVariables['ansible_tower_job_inventory_id'] = int (releaseVariables['ansible_tower_job_inventory'])
              print ("Inventory_id passing from XLR to Tower job template =>",releaseVariables['ansible_tower_job_inventory_id'])

              if "ztwr" in releaseVariables['ansible_tower_instance_group']:
                  inventory_deploydmz="Yes"
              elif "ztwr" not in releaseVariables['ansible_tower_instance_group']:
                  inventory_deploydmz="No"
              if inventory_deploydmz =="No":
                  if "ztwr" not in releaseVariables['ansible_tower_instance_group'] and releaseVariables['ansible_tower_instance_group'] !="[]":
                      inventory_instance_grp = "Yes"
                  elif releaseVariables['ansible_tower_instance_group'] =="[]":
                      inventory_instance_grp = "No"
                  print ("inventory_instance_grp==>", inventory_instance_grp)

              if "ztwr" in releaseVariables['ansible_tower_instance_group_from_template']:
                  jobtemplate_deploydmz="Yes"
              elif "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template']:
                  jobtemplate_deploydmz = "No"

              if jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="Yes":
                  print """Instance group in inventory configured with non-DMZ but instance group in tower job template configured with DMZ \n Always job template instance group take precedence, so please configure your Tower job template properly"""
                  sys.exit(1)
              elif jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="No":
                  releaseVariables['deployDMZ_lle'] = "Yes"
              elif jobtemplate_deploydmz == "Yes" and inventory_deploydmz=="Yes":
                  if "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  elif "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  elif "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  elif "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  if instance_group_match == "Yes":
                      releaseVariables['deployDMZ_lle'] = "Yes"
                  else:
                      print """DMZ instance group configured in inventory does not match with DMZ instance group configured in job template...\n Please configure them correctly!!"""
                      sys.exit(1)

              if jobtemplate_deploydmz=="No":
                  if "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template'] and releaseVariables['ansible_tower_instance_group_from_template'] !="[]":
                      template_instance_grp = "Yes"
                  elif releaseVariables['ansible_tower_instance_group_from_template'] =="[]":
                      template_instance_grp = "No"
                  print ("template_instance_grp==>", template_instance_grp)
                  if template_instance_grp == "Yes" and inventory_deploydmz=="Yes":
                      print """Your inventory's instance group configured with DMZ But Your job template's instance group not configured with DMZ. \n Always job template instance group take precedence, so please configure your Tower job template properly"""
                      releaseVariables['deployDMZ_lle'] = "No"
                      sys.exit(1)
                  elif template_instance_grp == "No" and inventory_deploydmz=="Yes":
                      releaseVariables['deployDMZ_lle'] = "Yes"
                  elif template_instance_grp == "No" and inventory_deploydmz=="No":
                      releaseVariables['deployDMZ_lle'] = "No"
              print ("inventory_dmz==>", inventory_deploydmz)
              print ("jobtemplate_dmz==>", jobtemplate_deploydmz)
              print("<-------------------deployDMZ---------->", releaseVariables['deployDMZ_lle'])
        - name: Get build artifact version (s) to deploy
          type: xlrelease.SequentialGroup
          tasks:
          - name: Artifactory API key generation
            type: xlrelease.SequentialGroup
            description: '### This task will generate encrypted API key that can be
              used in the fetch artifact version script tasks of this release template'
            tasks:
            - name: GET
              type: webhook.JsonWebhook
              URL: "${global.artifactoryurl}/api/security/apiKey"
              username: "${global.cross_connect_userid}"
              jsonPathExpression: $.apiKey
              variableMapping:
                pythonScript.result: "${ArtifactoryAPIkey}"
                pythonScript.password: "${global.cross_connect_password}"
          - name: Get build artifact's Release Candidate Version
            type: xlrelease.ScriptTask
            description: "#### This task will get latest version of the build artifact\
              \  ####"
            script: |-
              import urllib2
              import json

              artifactoryUrl="${global.artifactoryurl}/api/search/aql"
              certification_history = ""

              data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"property\",\"artifact.module.build.url\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}")
              artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
              artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest.add_header("Content-Type", "text/plain")
              artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
              artifactData = json.loads(artifactoryResponse)

              myprop={}
              for i in xrange(len(artifactData["results"])):
                  for j in xrange(len(artifactData["results"][i]["properties"])):
                      if (artifactData["results"][i]["properties"][j]["key"] == "${release_candidate_name}-Certified" and artifactData["results"][i]["properties"][j]["value"] == "Yes"):
                          releaseVariables["artifact_build_version_ciurl_var"]=artifactData["results"][i]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]
                          myprop=artifactData["results"][i]["properties"]

              for i in xrange(len(myprop)):
                  if (myprop[i]["key"] == "build.number"):
                      releaseVariables["artifact_build_version_buildnum_var"]=myprop[i]["value"]
                  if (myprop[i]["key"] == "ait.number"):
                      releaseVariables["artifact_build_version_ait_var"]=myprop[i]["value"]
                  if (myprop[i]["key"] == "scm.location"):
                      releaseVariables["artifact_build_version_scmloc_var"]=myprop[i]["value"]
                  if (myprop[i]["key"] == "scm.branch"):
                      releaseVariables["artifact_build_version_scmbranch_var"]=myprop[i]["value"]
                  if ("Certified" in myprop[i]["key"]):
                      certification_history="\n\n" + myprop[i]["key"] + "=" + myprop[i]["value"]+"\n\n"+certification_history

              releaseVariables["artifactory_certification_history"]=certification_history

              data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}",releaseVariables["artifact_build_version_buildnum_var"])
              artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
              artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest2.add_header("Content-Type", "text/plain")
              jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
              artifactData2 = json.loads(jobResponse2)

              mylist=""
              for index in range(len(artifactData2["results"])):
                  data_url="https://artifacts.customer.domain.com/artifactory"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
                  if(mylist==""):
                      mylist=data_url
                  else:
                      mylist=mylist+","+data_url

              if ',' in mylist:
                  mylist=mylist.replace(",","', '")
                  mylist= "['"+mylist+"']"

              releaseVariables["artifact_build_version_artifactoryUrl"] = mylist


              releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"
              releaseVariables["old_artifact_build_version_artifactoryUrl"]=releaseVariables["artifact_build_version_artifactoryUrl"]
              releaseVariables["old_artifact_build_version_buildnum_var"]=releaseVariables["artifact_build_version_buildnum_var"]
        - name: Deployment approval by Deployer LLE team
          type: xlrelease.UserInputTask
          description: |-
            #### Hello Deployer ${delivery_environment_type} Team :-
            ${phase_certified_artifact_property} ${phase_certified_artifact_version}

            Tower job template ${ansible_tower_job_template_name} will deploy the following build to ${delivery_environment_name}

            ${artifact_build_version_artifactorybrowseUrl}

            Certification History:
            ${artifactory_certification_history}

            Click "Complete" to to kick off deployment job in tower
          precondition: "\"${phaseEnablePreDeployGate_lle}\".lower() == \"yes\""
          tags:
          - key_process_step
          variables:
          - artifact_build_version_artifactoryUrl
          - artifact_build_version_buildnum_var
          - nonprod_tower_deployer_id
          - nonprod_tower_deployer_password
        - name: Deploy application changes/build
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: Construct artifactory url for deployment
            type: xlrelease.ScriptTask
            description: "#### This task will get latest version of the build artifact\
              \  ####"
            script: |-
              import urllib2
              import json

              artifactoryUrl="${global.artifactoryurl}/api/search/aql"
              myNewUrl="${artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
              myNewUrl=myNewUrl.replace("webapp/#/artifacts/browse/tree/General/","")
              myNewUrl=myNewUrl.replace("${artifactoryBuildRepo}/","")
              myNewUrl=myNewUrl.replace("[","")
              myNewUrl=myNewUrl.replace("]","")
              myNewUrl=myNewUrl.replace("'","")
              myNewUrlList=myNewUrl.split(",")


              myOldUrl="${old_artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
              myOldUrl=myOldUrl.replace("webapp/#/artifacts/browse/tree/General/","")
              myOldUrl=myOldUrl.replace("${artifactoryBuildRepo}/","")
              myOldUrl=myOldUrl.replace("[","")
              myOldUrl=myOldUrl.replace("]","")
              myOldUrl=myOldUrl.replace("'","")
              myOldUrlList=myOldUrl.split(",")

              releaseVariables["isReleaseCandidate"]="No"

              def GetFinalArtifactUrlList(buildNumber):
                  data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"created\").sort({\"$desc\":[\"created\"]})" %("${artifactoryBuildRepo}","${artifactoryBuildName}",buildNumber)
                  artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
                  artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
                  artifactoryRequest2.add_header("Content-Type", "text/plain")
                  jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
                  artifactData2 = json.loads(jobResponse2)

                  mylist=""
                  for index in range(len(artifactData2["results"])):
                      data_url="${global.artifactoryurl}"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
                      if(mylist==""):
                          mylist=data_url
                      else:
                          mylist=mylist+","+data_url

                  if ',' in mylist:
                      mylist=mylist.replace(",","', '")
                      mylist= "['"+mylist+"']"

                  releaseVariables["artifact_build_version_artifactoryUrl"] = mylist
                  releaseVariables["artifact_build_version_path_var"]=artifactData2["results"][index]["path"]
                  releaseVariables["artifact_build_version_name_var"]=artifactData2["results"][index]["name"]

              def GetFinalArtifactData(myPathName,myArtifactName):
                  data1="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"path\":{\"$match\":\"%s\"}},{\"name\":{\"$match\":\"%s\"}}).include(\"name\",\"repo\",\"path\",\"created\",\"property\",\"artifact.module.build.url\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}",myPathName,myArtifactName)
                  artifactoryRequest1=urllib2.Request(url=artifactoryUrl,data=data1)
                  artifactoryRequest1.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
                  artifactoryRequest1.add_header("Content-Type", "text/plain")
                  jobResponse1=urllib2.urlopen(artifactoryRequest1).read()
                  artifactData1 = json.loads(jobResponse1)

                  releaseVariables["artifact_build_version_ciurl_var"]=artifactData1["results"][0]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]

                  for i in xrange(len(artifactData1["results"][0]["properties"])):
                      if (artifactData1["results"][0]["properties"][i]["key"] == "ait.number"):
                          releaseVariables["artifact_build_version_ait_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "scm.location"):
                          releaseVariables["artifact_build_version_scmloc_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "build.number"):
                          releaseVariables["artifact_build_version_buildnum_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "scm.branch"):
                          releaseVariables["artifact_build_version_scmbranch_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "${release_candidate_name}-Certified" and artifactData1["results"][0]["properties"][i]["value"] == "Yes"):
                          releaseVariables["isReleaseCandidate"]="Yes"


              if "${old_artifact_build_version_buildnum_var}" != "${artifact_build_version_buildnum_var}":
                  GetFinalArtifactUrlList("${artifact_build_version_buildnum_var}")
                  GetFinalArtifactData(releaseVariables["artifact_build_version_path_var"],releaseVariables["artifact_build_version_name_var"])
                  if (releaseVariables["isReleaseCandidate"] == "No"):
                      print 'The details entered does not correspond to a release candidate build.'
                      sys.exit(1)
              elif myNewUrlList[0] not in myOldUrlList:
                  myNewUrl=myNewUrlList[0].rsplit('/', 1)
                  GetFinalArtifactData(myNewUrl[0],myNewUrl[1])
                  if (releaseVariables["isReleaseCandidate"] == "No"):
                      print 'The details entered does not correspond to a release candidate build.'
                      sys.exit(1)


              releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"

              ### Set Deployment Dashboard parameters

              spkName = "${spkName}".upper().strip()
              delivery_environment_name = "${delivery_environment_name}".upper().strip()
              dashboard_delivery_environment_name = spkName + "-" + delivery_environment_name
              releaseVariables['dashboard_delivery_environment_name'] = dashboard_delivery_environment_name

              # ID
              dashboard_deployerId = str(dashboard_delivery_environment_name) + "-deployerId"
              releaseVariables[dashboard_deployerId] = "${nonprod_tower_deployer_id}"

              ###XLR DMZ Integration
              if releaseVariables['deployDMZ_lle']=="Yes":
                      releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl'].replace("${global.artifactoryurl}","${global.dmzArtifactoryUrl_NonProd}")
              else:
                  releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl']
              print("deployDMZ_lle==", releaseVariables['deployDMZ_lle'])
              print("Artifactory URL==", releaseVariables['published_artifact_url'])
          - name: Get job template id
            type: webhook.JsonWebhook
            URL: "${global.ansible-non-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${nonprod_tower_deployer_id}"
            jsonPathExpression: "results[0].id"
            variableMapping:
              pythonScript.result: "${ansible_tower_job_template_id}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
          - name: "Deploy ${artifactoryBuildName}"
            type: ansible.RunPlaybook
            description: "## Deploy ${artifactoryBuildName}"
            flagComment: "Task 'Deploy ${artifactoryBuildName}' in Phase 'lle' has\
              \ been replaced by a manual task. The task of type 'ansible.LaunchJobTemplate'\
              \ could not be found because of a missing plugin."
            facets:
            - type: udm.DeploymentTaskFacet
              variableMapping:
                environmentId: "${dashboard_delivery_environment_name}"
                applicationId: "${component_name}"
                version: "${artifact_build_version_buildnum_var}"
            variableMapping:
              pythonScript.jobId: "${ansible_job_id}"
              pythonScript.password: "${nonprod_tower_deployer_password}"
              pythonScript.inventory: "${ansible_tower_job_inventory_id}"
            tags:
            - key_process_step
          - name: Fetch ansible job log
            type: xlrelease.ScriptTask
            description: "#### This task will get latest version of the build artifact\
              \  ####"
            script: "releaseVariables[\"ansible_tower_job_url\"]=\"${global.ansible-non-prod-towerurl}/#/jobs/${ansible_job_id}\""
        - name: Kick off litmus tests
          type: xlrelease.SequentialGroup
          precondition: "\"${litmus_enable_automated_tests}\".lower() == \"yes\""
          tags:
          - key_process_step
          tasks:
          - name: Validate LitmusTest input
            type: xlrelease.ScriptTask
            script: |-
              val = "${artifact_build_version_ait_var}"
              if not val: raise ValueError("ait_number is mandatory parameter for LitmusTest execution.")

              val = "${litmus_test_component}"
              if not val: raise ValueError("litmusComponentName is mandatory parameter for LitmusTest execution. Please fill it with valid value for your environment.")

              val = "${litmus_test_url}"
              if not val: raise ValueError("litmusTargetApplicationUrl is mandatory parameter for LitmusTest execution.Please fill it with valid value for your environment.")

              val = "${litmus_spk}"
              if not val: raise ValueError("litmus_spk is mandatory parameter for LitmusTest execution.")

              releaseVariables['litmus_input_validated'] = True
          - name: Submit Litmus Request
            type: xlrelease.ScriptTask
            precondition: "releaseVariables['litmus_input_validated'] == True"
            script: |-
              import urllib2
              import json
              import datetime
              import sys

              payload = {
                "BuildRunID": "" ,
                "AIT": "${artifact_build_version_ait_var}",
                "SPK": "${litmus_spk}",
                "JobStatus": "New",
                "DeployedDate": str(datetime.datetime.now()),
                "TestPhase": "${litmus_phase}",
                "ApplicationURL": "${litmus_app_url}",
                "EnvironmentName": "${delivery_environment_name}",
                "Component": "${litmus_test_component}",
                "Requestor":"XLR"
              }
              print("Req to be submitted to LitmusTest is - \n")
              print(payload)

              # Send req to Litmus
              data=json.dumps(payload)

              baseURL = "${litmus_test_url}"
              if not baseURL.endswith("/"):
                  baseURL = baseURL +"/"
              url = baseURL+"LitmusTest/InsertEvent"

              req=urllib2.Request(url=url ,data=data)
              req.add_header("Content-Type", "application/json")
              response=urllib2.urlopen(req).read()
              message = json.loads(response)
              print("\nResponse received-\n")
              print(message)
              requestStatus = message["requestStatus"]
              releaseVariables['litmus_request_id'] = message["requestId"]
              if requestStatus == "Request has been successfully queued.":
                releaseVariables['req_submitted'] = True
                print("\nRequest has been submitted to LitmusTest with requestId - "+ str(message["requestId"]))
              else:
                  print("\nRequest could not be submitted to LitmusTest.\n")
                  print (requestStatus)
                  print("\n")
                  sys.exit(1)
          - name: Process Response
            type: xlrelease.SequentialGroup
            precondition: "releaseVariables['req_submitted'] == True"
            tasks:
            - name: Process Smoke Test Response
              type: xlrelease.ScriptTask
              script: |-
                import json
                import urllib2
                import time
                import sys

                payload = {
                    "requestId":${litmus_request_id}
                }

                # Send req to Litmus for status check
                data = json.dumps(payload)
                baseURL = "${litmus_test_url}"
                if not baseURL.endswith("/"):
                    baseURL = baseURL + "/"
                url = baseURL + "LitmusTest/GetRequestStatus"

                timePassed = 0
                timeoutOccured = True
                while (timePassed < int(${litmus_smoke_timeout})):
                    time.sleep(${litmus_polling_interval})
                    timePassed = timePassed + ${litmus_polling_interval}

                    req = urllib2.Request(url=url, data=data)
                    req.add_header("Content-Type", "application/json")
                    response = urllib2.urlopen(req).read()
                    message = json.loads(response)

                    executingStatus = message["executingStatus"]
                    returnCode = message["executingState"]
                    index = returnCode.find("(")
                    shortCode = returnCode
                    if index != -1:
                        shortCode = returnCode[:returnCode.find("(")]
                    shortCode = shortCode.lower()

                    if (executingStatus == 'Waiting' or executingStatus == 'Smoke Executing'):
                        continue
                    print(message)
                    print("\n")
                    print("\n")
                    timeoutOccured = False
                    executionDetails = message["executionDetails"]
                    if (executingStatus.__contains__("Executing")):
                        if (shortCode == "smoke_pass1"):
                            print("\nSmoke Test passed, Basic Test is scheduled.")
                            releaseVariables['litmus_process_basic'] = True
                        elif (shortCode == "smoke_pass2"):
                            print("\nSmoke Passed, Regression Test is scheduled")
                            releaseVariables['litmus_process_regression'] = True
                        elif (shortCode == "basic_pass"):
                            print("\nBasic Passed, Regression Test is scheduled")
                            releaseVariables['litmus_process_regression'] = True
                        else:
                            print("\nInvalid executing state received.\n")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + eDetail["threshold"])
                    elif (executingStatus == 'Complete'):
                        if (shortCode == "request complete"):
                            print("\nRequest has been successfully completed.\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            releaseVariables['litmus_test_passed'] = True
                        elif (shortCode.__contains__("error")):
                            print("\nError occurred.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        elif (shortCode.__contains__("_fail")):
                            print("\nRequest failed.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        else:
                            print("\nInvalid executing state received.\n")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    else:
                        print("\nInvalid executing status received.\n")
                        print(executingStatus)
                        print("\n")
                        sys.exit(1)
                    break
                if timeoutOccured:
                    print("\nTimeout occurred.\n")
                    sys.exit(1)
            - name: Process Basic Test Response
              type: xlrelease.ScriptTask
              precondition: "releaseVariables['litmus_process_basic'] == True"
              script: |-
                import json
                import urllib2
                import time
                import sys

                payload = {
                    "requestId":${litmus_request_id}
                }

                # Send req to Litmus for status check
                data = json.dumps(payload)
                baseURL = "${litmus_test_url}"
                if not baseURL.endswith("/"):
                    baseURL = baseURL + "/"
                url = baseURL + "LitmusTest/GetRequestStatus"

                timePassed = 0
                timeoutOccured = True
                while (timePassed < int(${litmus_basic_timeout})):
                    time.sleep(${litmus_polling_interval})
                    timePassed = timePassed + ${litmus_polling_interval}

                    req = urllib2.Request(url=url, data=data)
                    req.add_header("Content-Type", "application/json")
                    response = urllib2.urlopen(req).read()
                    message = json.loads(response)
                    executingStatus = message["executingStatus"]
                    returnCode = message["executingState"]
                    index = returnCode.find("(")
                    shortCode = returnCode
                    if index != -1:
                        shortCode = returnCode[:returnCode.find("(")]
                    shortCode = shortCode.lower()

                    if (executingStatus == 'Basic Executing'):
                        continue
                    print(message)
                    print("\n")
                    print("\n")
                    timeoutOccured = False
                    executionDetails = message["executionDetails"]
                    if (executingStatus == "Regression Executing"):
                        if (shortCode == "basic_pass"):
                            print("\nBasic Passed, Regression Test is scheduled\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            releaseVariables['litmus_process_regression'] = True
                        else:
                            print("\nInvalid executing state received.\n")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    elif (executingStatus == 'Complete'):
                        if (shortCode == "request complete"):
                            print("\nRequest has been successfully completed.\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            releaseVariables['litmus_test_passed'] = True
                        elif (shortCode.__contains__("error")):
                            print("\nError occurred.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        elif (shortCode.__contains__("_fail")):
                            print("\nRequest failed.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        else:
                            print("\nInvalid executing state received.")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    else:
                        print("\nInvalid executing status received.\n")
                        print(executingStatus)
                        print("\n")
                        sys.exit(1)
                    break
                if timeoutOccured:
                    print("\nTimeout occurred.\n")
                    sys.exit(1)
            - name: Process Regression Test Response
              type: xlrelease.ScriptTask
              precondition: "releaseVariables['litmus_process_regression'] == True"
              script: |-
                import json
                import urllib2
                import time
                import sys

                payload = {
                  "requestId":${litmus_request_id}
                }

                # Send req to Litmus for status check
                data = json.dumps(payload)
                baseURL = "${litmus_test_url}"
                if not baseURL.endswith("/"):
                    baseURL = baseURL +"/"
                url = baseURL+"LitmusTest/GetRequestStatus"

                timePassed = 0
                timeoutOccured = True
                while (timePassed < int(${litmus_regression_timeout})):
                    time.sleep(${litmus_polling_interval})
                    timePassed = timePassed+ ${litmus_polling_interval}

                    req = urllib2.Request(url=url, data=data)
                    req.add_header("Content-Type", "application/json")
                    response = urllib2.urlopen(req).read()
                    message = json.loads(response)

                    executingStatus = message["executingStatus"]
                    returnCode = message["executingState"]
                    index = returnCode.find("(")
                    shortCode = returnCode
                    if index != -1:
                        shortCode = returnCode[:returnCode.find("(")]
                    shortCode = shortCode.lower()
                    if (executingStatus == 'Regression Executing' ):
                        continue
                    print(message)
                    print("\n")
                    print("\n")
                    timeoutOccured = False
                    executionDetails = message["executionDetails"]
                    if(executingStatus == 'Complete'):
                        if(shortCode == "request complete"):
                            print("\nRequest has been successfully completed.\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                            releaseVariables['litmus_test_passed'] = True
                        elif(shortCode.__contains__("error")):
                            print("\nError occurred.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        elif (shortCode.__contains__("_fail")):
                            print("\nRequest failed.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        else:
                            print("\nInvalid executing state received.")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    else:
                        print("\nInvalid executing status received.\n")
                        print(executingStatus)
                        print("\n")
                        sys.exit(1)
                    break
                if timeoutOccured:
                    print("\nTimeout occurred.\n")
                    sys.exit(1)
            - name: Sign off LitmusTest execution
              type: xlrelease.GateTask
              description: |-
                #### Hello Quality Engineer ${delivery_environment_type} Team :-

                Please review litmus test results and click "complete" to sign off.
              tags:
              - key_process_step
        - name: Post deployment certification by Quality Engineer LLE team
          type: xlrelease.GateTask
          description: |-
            #### Hello Quality Engineer ${delivery_environment_type} Team :-

            Can ${artifact_build_version_artifactoryUrl} be marked ${delivery_environment_name}-Certified=true in Artifactory ?

            Click "Complete" to confirm
          precondition: "\"${phaseEnablePostDeployGate_lle}\".lower() == \"yes\""
          tags:
          - key_process_step
          conditions:
          - name: "Tests executed, results reviewed. Build looks good ! OK to certify?"
            type: xlrelease.GateCondition
        - name: Certify build artifact version (s)
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: "Mark the artifact  ${artifactoryBuildName} certified in artifactory"
            type: xlrelease.ScriptTask
            tags:
            - key_process_step
            script: |-
              ### Set Deployment Dashboard parameters

              dashboard_delivery_environment_name = "${dashboard_delivery_environment_name}"
              dashboard_certStatus = str(dashboard_delivery_environment_name) + "-certStatus"
              ######

              full_url = "${artifact_build_version_artifactoryUrl}"
              urls_list = full_url.split(",")

              for myurl in urls_list:
                  api_call_url=myurl.replace("'","")
                  api_call_url=api_call_url.replace("[","")
                  api_call_url=api_call_url.replace("]","")
                  api_call_url=api_call_url.replace(" ","")
                  api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

                  artifact_url_to_update=api_call_url+"?properties="+"${delivery_environment_name}"+"-Certified=Yes"
                  request = HttpRequest({'url': '${global.artifactoryurl}'})
                  headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                  response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                  status = response.getStatus()

                  if response.getStatus() == 204:
                      releaseVariables[dashboard_certStatus] = 'Certified'
                      print myurl, " have been certified"
                      print '\n'
                  else:
                      print myurl, " could not be certified"
                      sys.exit(1)
          - name: "Mark Build Number:${artifact_build_version_buildnum_var} as a Release\
              \ Candidate"
            type: xlrelease.ScriptTask
            tags:
            - key_process_step
            script: |-
              import urllib2
              import json

              artifactoryUrl="${global.artifactoryurl}/api/search/aql"

              data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"property\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}")
              artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
              artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest.add_header("Content-Type", "text/plain")
              artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
              artifactData = json.loads(artifactoryResponse)
              print type(artifactData)

              #UnTag the Previous Release Candidate
              mylist=""
              for i in xrange(len(artifactData["results"])):
                  for j in xrange(len(artifactData["results"][i]["properties"])):
                      if (artifactData["results"][i]["properties"][j]["key"] == "${release_candidate_name}-Certified" and artifactData["results"][i]["properties"][j]["value"] == "Yes"):
                          artifact_url_to_update="/api/storage"+"/"+artifactData["results"][i]["repo"]+"/"+artifactData["results"][i]["path"]+"/"+artifactData["results"][i]["name"]+"?properties="+"${release_candidate_name}"+"-Certified=No"
                          request = HttpRequest({'url': '${global.artifactoryurl}'})
                          headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                          response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                          status = response.getStatus()


              #Tag the current build as Release Candidate
              full_url = "${artifact_build_version_artifactoryUrl}"
              urls_list = full_url.split(",")
              for myurl in urls_list:
                  api_call_url=myurl.replace("'","")
                  api_call_url=api_call_url.replace("[","")
                  api_call_url=api_call_url.replace("]","")
                  api_call_url=api_call_url.replace(" ","")
                  api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

                  artifact_url_to_update=api_call_url+"?properties="+"${release_candidate_name}"+"-Certified=Yes"
                  request = HttpRequest({'url': '${global.artifactoryurl}'})
                  headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                  response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                  status = response.getStatus()
                  if response.getStatus() == 204:
                      print myurl, " have been certified as a Release Candidate"
                      print '\n'
                  else:
                      print myurl, " could not be certified as a Release Candidate"
                      sys.exit(1)
          - name: Phase certification summary
            type: xlrelease.ScriptTask
            script: |-
              #phase_certified_artifact_version_name="phase_certified_artifact_version_"+"${component_name}"
              releaseVariables["phase_certified_artifact_version_name"] = "${artifact_build_version_artifactoryUrl}"

              #phase_certified_artifact_property_name = "phase_certified_artifact_property_"+"${component_name}"
              releaseVariables["phase_certified_artifact_property_name"] = "${delivery_environment_name}-Certified"
        - name: Closure
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: Compile Email Notification
            type: xlrelease.ScriptTask
            script: |-
              releaseVariables["email_body"] = "${spkName} ${component_name} has been successfully"
              releaseVariables["email_body_content"] =""
              phase_Title = getCurrentPhase().getTitle()
              release_Id = getCurrentRelease().getId()
              print("phase_Title==", phase_Title)
              print("Current release_Id", release_Id)

              deploy = getTasksByTitle("Deploy ${artifactoryBuildName}", phaseTitle = phase_Title, releaseId = release_Id)
              litmus = getTasksByTitle("Sign off LitmusTest execution", phaseTitle = phase_Title, releaseId = release_Id)
              cert = getTasksByTitle("Post deployment certification by Quality Engineer LLE team", phaseTitle = phase_Title, releaseId = release_Id)

              if len(deploy) != 0 and deploy[0]['status'] == "COMPLETED":
                  releaseVariables["email_body"] = releaseVariables["email_body"]+" deployed "
                  releaseVariables["email_body_content"] = "- #### Deployed artifacts: \n ${artifact_build_version_artifactorybrowseUrl} \n" + "- #### Refer the below url for tower job details: \n ${ansible_tower_job_url}"

              if len(litmus)!=0 and litmus[0]['status'] == "COMPLETED":
                  releaseVariables["email_body"] = releaseVariables["email_body"]+", litmus test executed "

              if len(cert)!=0 and cert[0]['status'] == "COMPLETED":
                  releaseVariables["email_body"] = releaseVariables["email_body"]+"& certified"

              if deploy[0]['status'] =="SKIPPED" and litmus[0]['status']=="SKIPPED" and cert[0]['status'] == "SKIPPED":
                  releaseVariables["email_body"] ="Deployment, Litmus test execution and certification of ${spkName} ${component_name} has been skipped"

              releaseVariables["email_body"] = releaseVariables["email_body"]+" in ${delivery_environment_name}"
              print("Deploy status ==", deploy[0]['status'])
              print("Litmus status ==", litmus[0]['status'])
              print ("Cert status ===", cert[0]['status'])
              print(releaseVariables["email_body"])
          - name: Send release notification
            type: xlrelease.NotificationTask
            description: "#### Send email notification for ${delivery_environment_name}\
              \ release ####"
            tags:
            - key_process_step
            addresses:
            - "${release_notification_list}"
            subject: "${spkName} ${component_name} release to ${delivery_environment_name}"
            body: |-
              #### ${email_body}

              ${email_body_content}

              - #### Refer release pipeline below for more info via 2 available options (flow view , table view):
              ${delivery_pipeline_url}
        color: '#009CDB'
      - phase: prod
        tasks:
        - name: Acknowledge/sign off release code quality metrics
          type: xlrelease.SequentialGroup
          precondition: "releaseVariables['enable_sonar_metrics_check'] == 'Yes'"
          tags:
          - key_process_step
          tasks:
          - name: Delete Existing SonarQube token
            type: webhook.JsonWebhook
            URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
            method: POST
            username: "${global.cross_connect_userid}"
            variableMapping:
              pythonScript.password: "${global.cross_connect_password}"
          - name: Generate SonarQube token
            type: webhook.JsonWebhook
            URL: "${global.sonarurl}/api/user_tokens/generate?name=${spkComponentsToRelease}"
            method: POST
            username: "${global.cross_connect_userid}"
            jsonPathExpression: $.token
            variableMapping:
              pythonScript.result: "${SonarQube_token}"
              pythonScript.password: "${global.cross_connect_password}"
          - name: "Reading SonarQube Metrics for  ${sonarComponentKey}"
            type: xlrelease.ScriptTask
            script: |-
              import urllib2
              import json
              import base64

              # defining the api-endpoint

              url="${global.sonarurl}/api/measures/component?componentKey=${sonarComponentKey}&metricKeys=alert_status,bugs,blocker_violations,critical_violations,vulnerabilities,code_smells,duplicated_blocks,duplicated_lines_density,ncloc"

              print("URL....", url)

              token = releaseVariables['SonarQube_token'] + ":"
              encodedToken =  base64.encodestring(token).rstrip('\n')
              print ("Encodedtoken= ", encodedToken)

              req=urllib2.Request(url=url)
              req.add_header('Authorization', "Basic %s" % encodedToken)
              req.add_header("Content-Type", "application/json")

              jobResponse=urllib2.urlopen(req).read()

              print("JOB Response", jobResponse)

              json_data = json.loads(jobResponse)

              print ("\n JSON DATA....",json_data)

              metrics_data = {}
              for item in json_data['component']['measures']:
                  metrics_data[item['metric']] = item['value']

              releaseVariables['sonarqube_bugs']  = int(metrics_data.get('bugs'))

              releaseVariables['sonarqube_blocker_violations']  = int(metrics_data.get('blocker_violations'))

              releaseVariables['sonarqube_critical_violations']  = int(metrics_data.get('critical_violations'))
              releaseVariables['sonarqube_vulnerabilities'] = int(metrics_data.get('vulnerabilities'))
              releaseVariables['sonarqube_code_smells'] = int(metrics_data.get('code_smells'))
              releaseVariables['sonarqube_duplicated_blocks'] = int(metrics_data.get('duplicated_blocks'))
              releaseVariables['sonarqube_duplicated_lines_density'] = metrics_data.get('duplicated_lines_density')
              releaseVariables['sonarqube_ncloc'] = int(metrics_data.get('ncloc'))

              gg = metrics_data.get('alert_status')

              if gg == "OK":
                  releaseVariables['sonarqube_quality_gate'] = "PASSED"

              if gg == "ERROR":
                 releaseVariables['sonarqube_quality_gate'] = "FAILED"
          - name: Delete SonarQube token
            type: webhook.JsonWebhook
            URL: "${global.sonarurl}/api/user_tokens/revoke?name=${spkComponentsToRelease}"
            method: POST
            username: "${global.cross_connect_userid}"
            variableMapping:
              pythonScript.password: "${global.cross_connect_password}"
          - name: Sign off on SonarQube metrics for the release
            type: xlrelease.GateTask
            description: |-
              - Quality Gate :  ${sonarqube_quality_gate}
              - Bugs: ${sonarqube_bugs}
              - Blocker Violations: ${sonarqube_blocker_violations}
              - Critical Violations: ${sonarqube_critical_violations}
              - Vulnerabilities: ${sonarqube_vulnerabilities}
              - Code Smells: ${sonarqube_code_smells}
              - Duplicated Blocks: ${sonarqube_duplicated_blocks}
              - Duplicated Line Density: ${sonarqube_duplicated_lines_density}
              - Lines of Code: ${sonarqube_ncloc}
            tags:
            - key_process_step
        - name: Pre-tasks for DMZ deployment
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: Validate Inventory configured in tower Job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${towerDeployerIdProd}"
            jsonPathExpression: $..inventory
            variableMapping:
              pythonScript.result: "${ansible_template_inventory_name}"
              pythonScript.password: "${towerDeployerPasswordProd}"
          - name: Get Inventory name from Tower Job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${towerDeployerIdProd}"
            jsonPathExpression: "results[0].summary_fields.inventory.name"
            precondition: "releaseVariables['ansible_template_inventory_name']!=\"\
              [null]\""
            variableMapping:
              pythonScript.result: "${tower_job_inventory_name}"
              pythonScript.password: "${towerDeployerPasswordProd}"
          - name: Validate inventory
            type: xlrelease.ScriptTask
            script: |-
              if releaseVariables['ansible_template_inventory_name']!='[null]' and releaseVariables['xlr_inventory_name']!="":
                  if releaseVariables['tower_job_inventory_name'] == releaseVariables['xlr_inventory_name']:
                      print "Inventory name in XLR and Tower are same, Good to go!"
                  elif releaseVariables['tower_job_inventory_name'] != releaseVariables['xlr_inventory_name']:
                     print """Ansible tower job_template '${ansible_tower_job_template_name}' is not correctly configured to accept an inventory as input \n Please remove inventory name and update the tower job_template with ('prompt on launch')"""
                     sys.exit(1)
              elif releaseVariables['ansible_template_inventory_name']=='[null]' and releaseVariables['xlr_inventory_name']=="":
                  print "Ansible tower job_template '${ansible_tower_job_template_name}'is not configured with an inventory name, please configure valid inventory name"
                  sys.exit(1)
              print "Validation looks Good !"
          - name: Construct Instance group url  from ansible Job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${towerDeployerIdProd}"
            jsonPathExpression: "results[0].related.instance_groups"
            variableMapping:
              pythonScript.password: "${towerDeployerPasswordProd}"
              pythonScript.result: "${ansible_tower_job_template_instance_group_url}"
          - name: Get Instance group details from instance group url
            type: webhook.JsonWebhook
            URL: "${global.ansible-prod-towerurl}${ansible_tower_job_template_instance_group_url}"
            username: "${towerDeployerIdProd}"
            jsonPathExpression: results
            variableMapping:
              pythonScript.result: "${ansible_tower_instance_group_from_template}"
              pythonScript.password: "${towerDeployerPasswordProd}"
          - name: Get Ansible inventory id from XLR template
            type: webhook.JsonWebhook
            URL: "${global.ansible-prod-towerurl}/api/v2/inventories?name=${xlr_inventory_name}"
            username: "${towerDeployerIdProd}"
            jsonPathExpression: "results[0].id"
            precondition: "releaseVariables['xlr_inventory_name'] !=\"\""
            variableMapping:
              pythonScript.result: "${ansible_tower_job_inventory}"
              pythonScript.password: "${towerDeployerPasswordProd}"
          - name: Get Inventory id from ansible job template
            type: webhook.JsonWebhook
            URL: "${global.ansible-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${towerDeployerIdProd}"
            jsonPathExpression: "results[0].summary_fields.inventory.id"
            precondition: "releaseVariables['xlr_inventory_name'] ==\"\""
            variableMapping:
              pythonScript.result: "${ansible_tower_job_inventory}"
              pythonScript.password: "${towerDeployerPasswordProd}"
          - name: Get Ansible Instance group from inventory id
            type: webhook.JsonWebhook
            URL: "${global.ansible-prod-towerurl}/api/v2/inventories/${ansible_tower_job_inventory}/instance_groups"
            username: "${towerDeployerIdProd}"
            jsonPathExpression: results
            variableMapping:
              pythonScript.password: "${towerDeployerPasswordProd}"
              pythonScript.result: "${ansible_tower_instance_group}"
          - name: "Determine Artifactory : DMZ or Baronet"
            type: xlrelease.ScriptTask
            script: |-
              releaseVariables['deployDMZ_prod']="No"
              releaseVariables['ansible_tower_job_inventory_id']=0
              jobtemplate_deploydmz ="No"
              inventory_deploydmz = "No"
              instance_group_match ="No"
              if releaseVariables['xlr_inventory_name'] =="":
                  releaseVariables['ansible_tower_job_inventory_id']=0
              elif releaseVariables['xlr_inventory_name'] !="":
                  releaseVariables['ansible_tower_job_inventory_id'] = int (releaseVariables['ansible_tower_job_inventory'])
              print ("Inventory_id passing from XLR to Tower job template =>",releaseVariables['ansible_tower_job_inventory_id'])

              if "ztwr" in releaseVariables['ansible_tower_instance_group']:
                  inventory_deploydmz="Yes"
              elif "ztwr" not in releaseVariables['ansible_tower_instance_group']:
                  inventory_deploydmz="No"
              if inventory_deploydmz =="No":
                  if "ztwr" not in releaseVariables['ansible_tower_instance_group'] and releaseVariables['ansible_tower_instance_group'] !="[]":
                      inventory_instance_grp = "Yes"
                  elif releaseVariables['ansible_tower_instance_group'] =="[]":
                      inventory_instance_grp = "No"
                  print ("inventory_instance_grp==>", inventory_instance_grp)

              if "ztwr" in releaseVariables['ansible_tower_instance_group_from_template']:
                  jobtemplate_deploydmz="Yes"
              elif "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template']:
                  jobtemplate_deploydmz = "No"

              if jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="Yes":
                  print """Instance group in inventory configured with non-DMZ but instance group in tower job template configured with DMZ \n Always job template instance group take precedence, so please configure your Tower job template properly"""
                  sys.exit(1)
              elif jobtemplate_deploydmz == "Yes" and inventory_instance_grp =="No":
                  releaseVariables['deployDMZ_prod'] = "Yes"
              elif jobtemplate_deploydmz == "Yes" and inventory_deploydmz=="Yes":
                  if "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  elif "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_np" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  elif "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_securez_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  elif "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group'] and "ztwr_presentationz_prod" in releaseVariables['ansible_tower_instance_group_from_template']:
                      instance_group_match = "Yes"
                  if instance_group_match == "Yes":
                      releaseVariables['deployDMZ_prod'] = "Yes"
                  else:
                      print """DMZ instance group configured in inventory does not match with DMZ instance group configured in job template...\n Please configure them correctly!!"""
                      sys.exit(1)

              if jobtemplate_deploydmz=="No":
                  if "ztwr" not in releaseVariables['ansible_tower_instance_group_from_template'] and releaseVariables['ansible_tower_instance_group_from_template'] !="[]":
                      template_instance_grp = "Yes"
                  elif releaseVariables['ansible_tower_instance_group_from_template'] =="[]":
                      template_instance_grp = "No"
                  print ("template_instance_grp==>", template_instance_grp)
                  if template_instance_grp == "Yes" and inventory_deploydmz=="Yes":
                      print """Your inventory's instance group configured with DMZ But Your job template's instance group not configured with DMZ. \n Always job template instance group take precedence, so please configure your Tower job template properly"""
                      releaseVariables['deployDMZ_prod'] = "No"
                      sys.exit(1)
                  elif template_instance_grp == "No" and inventory_deploydmz=="Yes":
                      releaseVariables['deployDMZ_prod'] = "Yes"
                  elif template_instance_grp == "No" and inventory_deploydmz=="No":
                      releaseVariables['deployDMZ_prod'] = "No"
              print ("inventory_dmz==>", inventory_deploydmz)
              print ("jobtemplate_dmz==>", jobtemplate_deploydmz)
              print("<-------------------deployDMZ---------->", releaseVariables['deployDMZ_prod'])
        - name: Get build artifact version (s) to deploy
          type: xlrelease.SequentialGroup
          tasks:
          - name: Artifactory API key generation
            type: xlrelease.SequentialGroup
            description: '### This task will generate encrypted API key that can be
              used in the fetch artifact version script tasks of this release template'
            tasks:
            - name: GET
              type: webhook.JsonWebhook
              URL: "${global.artifactoryurl}/api/security/apiKey"
              username: "${global.cross_connect_userid}"
              jsonPathExpression: $.apiKey
              variableMapping:
                pythonScript.result: "${ArtifactoryAPIkey}"
                pythonScript.password: "${global.cross_connect_password}"
          - name: Get build artifact's Release Candidate Version
            type: xlrelease.ScriptTask
            description: "#### This task will get latest version of the build artifact\
              \  ####"
            script: |-
              import urllib2
              import json

              artifactoryUrl="${global.artifactoryurl}/api/search/aql"
              certification_history = ""

              data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"property\",\"artifact.module.build.url\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}")
              artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
              artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest.add_header("Content-Type", "text/plain")
              artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
              artifactData = json.loads(artifactoryResponse)

              myprop={}
              for i in xrange(len(artifactData["results"])):
                  for j in xrange(len(artifactData["results"][i]["properties"])):
                      if (artifactData["results"][i]["properties"][j]["key"] == "${release_candidate_name}-Certified" and artifactData["results"][i]["properties"][j]["value"] == "Yes"):
                          releaseVariables["artifact_build_version_ciurl_var"]=artifactData["results"][i]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]
                          myprop=artifactData["results"][i]["properties"]

              for i in xrange(len(myprop)):
                  if (myprop[i]["key"] == "build.number"):
                      releaseVariables["artifact_build_version_buildnum_var"]=myprop[i]["value"]
                  if (myprop[i]["key"] == "ait.number"):
                      releaseVariables["artifact_build_version_ait_var"]=myprop[i]["value"]
                  if (myprop[i]["key"] == "scm.location"):
                      releaseVariables["artifact_build_version_scmloc_var"]=myprop[i]["value"]
                  if (myprop[i]["key"] == "scm.branch"):
                      releaseVariables["artifact_build_version_scmbranch_var"]=myprop[i]["value"]
                  if ("Certified" in myprop[i]["key"]):
                      certification_history="\n\n" + myprop[i]["key"] + "=" + myprop[i]["value"]+"\n\n"+certification_history

              releaseVariables["artifactory_certification_history"]=certification_history

              data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}",releaseVariables["artifact_build_version_buildnum_var"])
              artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
              artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest2.add_header("Content-Type", "text/plain")
              jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
              artifactData2 = json.loads(jobResponse2)

              mylist=""
              for index in range(len(artifactData2["results"])):
                  data_url="https://artifacts.customer.domain.com/artifactory"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
                  if(mylist==""):
                      mylist=data_url
                  else:
                      mylist=mylist+","+data_url

              if ',' in mylist:
                  mylist=mylist.replace(",","', '")
                  mylist= "['"+mylist+"']"

              releaseVariables["artifact_build_version_artifactoryUrl"] = mylist


              releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"
              releaseVariables["old_artifact_build_version_artifactoryUrl"]=releaseVariables["artifact_build_version_artifactoryUrl"]
              releaseVariables["old_artifact_build_version_buildnum_var"]=releaseVariables["artifact_build_version_buildnum_var"]
        - name: Ensure production change readiness
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: Confirm target release CRQ number
            type: xlrelease.UserInputTask
            description: '#### Please confirm CRQ number of this release'
            tags:
            - key_process_step
            variables:
            - target_release_crq_number
          - name: "Get current status of ${target_release_crq_number}"
            type: xlrelease.ScriptTask
            precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
            script: |-
              import urllib2
              import json
              import time
              import base64

              url="${global.remedyurl}/security/issueToken?servicename=changeservice"

              req=urllib2.Request(url=url,data="")

              req.add_header("Content-Type", "application/x-www-form-urlencoded")
              req.add_header("userName", "ZS30SW4")
              req.add_header("password", base64.b64decode("cndralMyWXE="))

              Token=urllib2.urlopen(req).read()


              # defining the api-endpoint
              url="${global.remedyurl}/api/changequery/get_changecore/${target_release_crq_number}"

              req1=urllib2.Request(url=url)
              req1.add_header("Authorization", Token)
              req1.add_header("Content-Type", "application/json")

              jobResponse=urllib2.urlopen(req1).read()
              jsonData = json.loads(jobResponse)
              status = jsonData['status']
              releaseVariables["CRQStatus"]=status
              print(releaseVariables["CRQStatus"])

              # Getting Release-id
              releaseId = "${release.id}"
              id = releaseId.replace('/','-').replace("Applications-","/#/releases/")
              releaseVariables['xlr_url'] = "${global.xlrurl}"+id
              print("\n \n xlr_url =" , releaseVariables['xlr_url'])
          - name: "Update ${target_release_crq_number} work info w/ delivery pipeline\
              \ status"
            type: xlrelease.ScriptTask
            precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
            script: |-
              import urllib2
              import json
              import time
              import base64

              url="${global.remedyurl}/security/issueToken?servicename=changeservice"

              req=urllib2.Request(url=url,data="")

              req.add_header("Content-Type", "application/x-www-form-urlencoded")
              req.add_header("userName", "ZS30SW4")
              req.add_header("password", base64.b64decode("cndralMyWXE="))

              Token=urllib2.urlopen(req).read()



              # defining the api-endpoint
              url2="${global.remedyurl}/api/change/${target_release_crq_number}/updatechange"


              transaction_datetime = time.strftime('%Y-%m-%dT%H:%M:%S')

              transId ="XLR_Add_Worklog_"+str(transaction_datetime)

              # sourceReqId is obtained from Remedy (its constant and wont change for every call)
              #sourceReqId = 'XLR_GWB_CHANGE_002'

              print("transaction ID:", transId)

              json1={
                  "transactionDetails": {
                  "transactionType": "ADDWORKLOG",
                  "transactionId": transId,
                  "eventSource": "XLR_GWB_CHANGE",
                  "sourceRequestId": "XLR_GWB_CHANGE",
                  "eventTarget": "BAC_CHANGE",
                  "targetRequestId": "${target_release_crq_number}",
                  "transactionDate": transaction_datetime
                },
                "updateSystemManaged": {
                  "personIdType": "LoginName",
                  "createdBy": "${xlr_remedy_workinfo_creator}"
                },
                "changeWorkInfo": {
                  "workLogId": "",
                  "workLogType": "General Information",
                  "workLogNotes": "${spkName} has been successfully deployed, tested & certified in DEV & LLE environments  \n\nDeployed artifacts:  ${artifact_build_version_artifactorybrowseUrl} \n\nFor further details on this release, check delivery pipeline ${delivery_pipeline_url}",
                  "workLogSubmitter": "${xlr_remedy_workinfo_workLogSubmitter}",
                  "workLogAccess": "Public"
                 }
              }

              print(json1)

              # data to be sent to api
              data=json.dumps(json1)

              req1=urllib2.Request(url=url2,data=data)

              req1.add_header("Authorization", Token)
              req1.add_header("Content-Type", "application/json")
              req1.get_method = lambda : 'PUT'

              response=urllib2.urlopen(req1).read()
              message = json.loads(response)
              print(message)
          - name: "Update ${target_release_crq_number} work info w/ Install Plan"
            type: xlrelease.ScriptTask
            precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
            script: |-
              import urllib2
              import json
              import time
              import base64

              url="${global.remedyurl}/security/issueToken?servicename=changeservice"

              req=urllib2.Request(url=url,data="")

              req.add_header("Content-Type", "application/x-www-form-urlencoded")
              req.add_header("userName", "ZS30SW4")
              req.add_header("password", base64.b64decode("cndralMyWXE="))

              Token=urllib2.urlopen(req).read()



              # defining the api-endpoint
              url2="${global.remedyurl}/api/change/${target_release_crq_number}/updatechange"


              transaction_datetime = time.strftime('%Y-%m-%dT%H:%M:%S')

              transId ="XLR_Add_Worklog_"+str(transaction_datetime)

              # sourceReqId is obtained from Remedy (its constant and wont change for every call)
              #sourceReqId = 'XLR_GWB_CHANGE_002'

              print("transaction ID:", transId)

              json1={
                  "transactionDetails": {
                  "transactionType": "ADDWORKLOG",
                  "transactionId": transId,
                  "eventSource": "XLR_GWB_CHANGE",
                  "sourceRequestId": "XLR_GWB_CHANGE",
                  "eventTarget": "BAC_CHANGE",
                  "targetRequestId": "${target_release_crq_number}",
                  "transactionDate": transaction_datetime
                },
                "updateSystemManaged": {
                  "personIdType": "LoginName",
                  "createdBy": "${xlr_remedy_workinfo_creator}"
                },
                "changeWorkInfo": {
                  "workLogId": "",
                  "workLogType": "Install Plan",
                  "workLogNotes": "${spkName} change will be deployed to production by Horizon CD pipeline (in XLR). Details on steps being executed can be found here :- ${delivery_pipeline_url}",
                  "workLogSubmitter": "${xlr_remedy_workinfo_workLogSubmitter}",
                  "workLogAccess": "Public"
                 }
              }

              print(json1)

              # data to be sent to api
              data=json.dumps(json1)

              req1=urllib2.Request(url=url2,data=data)

              req1.add_header("Authorization", Token)
              req1.add_header("Content-Type", "application/json")
              req1.get_method = lambda : 'PUT'

              response=urllib2.urlopen(req1).read()
              message = json.loads(response)
              print(message)
          - name: "Update ${target_release_crq_number} work info w/ Test Plan"
            type: xlrelease.ScriptTask
            precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
            script: |-
              import urllib2
              import json
              import time
              import base64

              url="${global.remedyurl}/security/issueToken?servicename=changeservice"

              req=urllib2.Request(url=url,data="")

              req.add_header("Content-Type", "application/x-www-form-urlencoded")
              req.add_header("userName", "ZS30SW4")
              req.add_header("password", base64.b64decode("cndralMyWXE="))

              Token=urllib2.urlopen(req).read()



              # defining the api-endpoint
              url2="${global.remedyurl}/api/change/${target_release_crq_number}/updatechange"


              transaction_datetime = time.strftime('%Y-%m-%dT%H:%M:%S')

              transId ="XLR_Add_Worklog_"+str(transaction_datetime)

              # sourceReqId is obtained from Remedy (its constant and wont change for every call)
              #sourceReqId = 'XLR_GWB_CHANGE_002'

              print("transaction ID:", transId)

              json1={
                  "transactionDetails": {
                  "transactionType": "ADDWORKLOG",
                  "transactionId": transId,
                  "eventSource": "XLR_GWB_CHANGE",
                  "sourceRequestId": "XLR_GWB_CHANGE",
                  "eventTarget": "BAC_CHANGE",
                  "targetRequestId": "${target_release_crq_number}",
                  "transactionDate": transaction_datetime
                },
                "updateSystemManaged": {
                  "personIdType": "LoginName",
                  "createdBy": "${xlr_remedy_workinfo_creator}"
                },
                "changeWorkInfo": {
                  "workLogId": "",
                  "workLogType": "Test Plan",
                  "workLogNotes": "${spkName} change will be tested in an automated fashion by litmus and executed by Horizon CD pipeline (in XLR). Details on test results, signoffs etc can be found here :- ${delivery_pipeline_url}",
                  "workLogSubmitter": "${xlr_remedy_workinfo_workLogSubmitter}",
                  "workLogAccess": "Public"
                 }
              }

              print(json1)

              # data to be sent to api
              data=json.dumps(json1)

              req1=urllib2.Request(url=url2,data=data)

              req1.add_header("Authorization", Token)
              req1.add_header("Content-Type", "application/json")
              req1.get_method = lambda : 'PUT'

              response=urllib2.urlopen(req1).read()
              message = json.loads(response)
              print(message)
          - name: "Update ${target_release_crq_number} work info w/ Backout Plan"
            type: xlrelease.ScriptTask
            precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
            script: |-
              import urllib2
              import json
              import time
              import base64

              url="${global.remedyurl}/security/issueToken?servicename=changeservice"

              req=urllib2.Request(url=url,data="")

              req.add_header("Content-Type", "application/x-www-form-urlencoded")
              req.add_header("userName", "ZS30SW4")
              req.add_header("password", base64.b64decode("cndralMyWXE="))

              Token=urllib2.urlopen(req).read()



              # defining the api-endpoint
              url2="${global.remedyurl}/api/change/${target_release_crq_number}/updatechange"


              transaction_datetime = time.strftime('%Y-%m-%dT%H:%M:%S')

              transId ="XLR_Add_Worklog_"+str(transaction_datetime)

              # sourceReqId is obtained from Remedy (its constant and wont change for every call)
              #sourceReqId = 'XLR_GWB_CHANGE_002'

              print("transaction ID:", transId)

              json1={
                  "transactionDetails": {
                  "transactionType": "ADDWORKLOG",
                  "transactionId": transId,
                  "eventSource": "XLR_GWB_CHANGE",
                  "sourceRequestId": "XLR_GWB_CHANGE",
                  "eventTarget": "BAC_CHANGE",
                  "targetRequestId": "${target_release_crq_number}",
                  "transactionDate": transaction_datetime
                },
                "updateSystemManaged": {
                  "personIdType": "LoginName",
                  "createdBy": "${xlr_remedy_workinfo_creator}"
                },
                "changeWorkInfo": {
                  "workLogId": "",
                  "workLogType": "Backout Plan",
                  "workLogNotes": "${spkName} change backout can be performed from the Horizon CD pipeline (in XLR) itself (manually by doing a restart on PROD phases and directing it to deploy a specific version to Production environments that the team decides to roll it back to) . Details on pipeline execution can be found here :- ${delivery_pipeline_url}",
                  "workLogSubmitter": "${xlr_remedy_workinfo_workLogSubmitter}",
                  "workLogAccess": "Public"
                 }
              }

              print(json1)

              # data to be sent to api
              data=json.dumps(json1)

              req1=urllib2.Request(url=url2,data=data)

              req1.add_header("Authorization", Token)
              req1.add_header("Content-Type", "application/json")
              req1.get_method = lambda : 'PUT'

              response=urllib2.urlopen(req1).read()
              message = json.loads(response)
              print(message)
          - name: "Send an email to the release team to ensure ${target_release_crq_number}\
              \ readiness"
            type: xlrelease.NotificationTask
            precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
            tags:
            - key_process_step
            addresses:
            - "${release_notification_list}"
            subject: "Review CRQ ${target_release_crq_number}"
            body: |-
              - Current status of ${target_release_crq_number} :  ${CRQStatus}
              - Please review [${target_release_crq_number}](
              ${global.itsmurl}${target_release_crq_number}) for completeness and work with your change coordinators in getting necessary approvals.
              - Please make sure CRQ is put into "Scheduled" state for the deployment to begin
          - name: "Send an email to the release team to ensure ${target_release_crq_number}\
              \ readiness"
            type: xlrelease.NotificationTask
            precondition: "releaseVariables['remedyEnableIntegration'] == 'No'"
            tags:
            - key_process_step
            addresses:
            - "${release_notification_list}"
            subject: "Review CRQ ${target_release_crq_number}"
            body: |-
              - Please review [${target_release_crq_number}](
              ${global.itsmurl}${target_release_crq_number})for completeness and work with your change coordinators in getting necessary approvals.
              - Please make sure CRQ is put into "Scheduled" state for the deployment to begin
        - name: Production change go/no-go
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: Production Go/No Go Decision?
            type: xlrelease.GateTask
            description: |-
              #### Hello Release Manager Team :-

              Is ${target_release_crq_number} approved and ready to go to Production?
            tags:
            - key_process_step
            conditions:
            - name: "Yes, ${target_release_crq_number} is in scheduled state and good\
                \ to go"
              type: xlrelease.GateCondition
          - name: "Get current status of ${target_release_crq_number}"
            type: xlrelease.ScriptTask
            precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
            script: |-
              import urllib2
              import json
              import time
              import base64

              url="${global.remedyurl}/security/issueToken?servicename=changeservice"

              req=urllib2.Request(url=url,data="")

              req.add_header("Content-Type", "application/x-www-form-urlencoded")
              req.add_header("userName", "ZS30SW4")
              req.add_header("password", base64.b64decode("cndralMyWXE="))

              Token=urllib2.urlopen(req).read()




              # defining the api-endpoint
              url="${global.remedyurl}/api/changequery/get_changecore/${target_release_crq_number}"

              req1=urllib2.Request(url=url)
              req1.add_header("Authorization", Token)
              req1.add_header("Content-Type", "application/json")

              jobResponse=urllib2.urlopen(req1).read()
              jsonData = json.loads(jobResponse)
              status = jsonData['status']
              releaseVariables["CRQStatus"]=status
              print(releaseVariables["CRQStatus"])

              # Getting Release-id
              releaseId = "${release.id}"
              id = releaseId.replace('/','-').replace("Applications-","/#/releases/")
              releaseVariables['xlr_url'] = "${global.xlrurl}"+id
              print("\n \n xlr_url =" , releaseVariables['xlr_url'])
          - name: Final confirmation on production change
            type: xlrelease.GateTask
            description: |-
              #### ** Hey Release Manager Team :- **  ####

              Please provide final confirmation on this production change.

              - Change : ${target_release_crq_number}
              - Status =  ${CRQStatus}
            precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
            tags:
            - key_process_step
            conditions:
            - name: "Looks right, OK to proceeed !"
              type: xlrelease.GateCondition
        - name: Deployment approval by Deployer PROD team
          type: xlrelease.UserInputTask
          description: |-
            #### Hello Deployer ${delivery_environment_type} Team :-
            ${phase_certified_artifact_property} ${phase_certified_artifact_version}

            Tower job template ${ansible_tower_job_template_name} will deploy the following build to ${delivery_environment_name}

            ${artifact_build_version_artifactorybrowseUrl}

            Certification History:
            ${artifactory_certification_history}

            Click "Complete" to to kick off deployment job in tower
          tags:
          - key_process_step
          variables:
          - artifact_build_version_artifactoryUrl
          - artifact_build_version_buildnum_var
          - towerDeployerIdProd
          - towerDeployerPasswordProd
        - name: Deploy application changes/build
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: Construct artifactory url for deployment
            type: xlrelease.ScriptTask
            description: "#### This task will get latest version of the build artifact\
              \  ####"
            script: |-
              import urllib2
              import json

              artifactoryUrl="${global.artifactoryurl}/api/search/aql"
              myNewUrl="${artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
              myNewUrl=myNewUrl.replace("webapp/#/artifacts/browse/tree/General/","")
              myNewUrl=myNewUrl.replace("${artifactoryBuildRepo}/","")
              myNewUrl=myNewUrl.replace("[","")
              myNewUrl=myNewUrl.replace("]","")
              myNewUrl=myNewUrl.replace("'","")
              myNewUrlList=myNewUrl.split(",")


              myOldUrl="${old_artifact_build_version_artifactoryUrl}".replace("${global.artifactoryurl}/","")
              myOldUrl=myOldUrl.replace("webapp/#/artifacts/browse/tree/General/","")
              myOldUrl=myOldUrl.replace("${artifactoryBuildRepo}/","")
              myOldUrl=myOldUrl.replace("[","")
              myOldUrl=myOldUrl.replace("]","")
              myOldUrl=myOldUrl.replace("'","")
              myOldUrlList=myOldUrl.split(",")

              releaseVariables["isReleaseCandidate"]="No"

              def GetFinalArtifactUrlList(buildNumber):
                  data2="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"@build.number\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"created\").sort({\"$desc\":[\"created\"]})" %("${artifactoryBuildRepo}","${artifactoryBuildName}",buildNumber)
                  artifactoryRequest2=urllib2.Request(url=artifactoryUrl,data=data2)
                  artifactoryRequest2.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
                  artifactoryRequest2.add_header("Content-Type", "text/plain")
                  jobResponse2=urllib2.urlopen(artifactoryRequest2).read()
                  artifactData2 = json.loads(jobResponse2)

                  mylist=""
                  for index in range(len(artifactData2["results"])):
                      data_url="${global.artifactoryurl}"+"/"+artifactData2["results"][index]["repo"]+"/"+artifactData2["results"][index]["path"]+"/"+artifactData2["results"][index]["name"]
                      if(mylist==""):
                          mylist=data_url
                      else:
                          mylist=mylist+","+data_url

                  if ',' in mylist:
                      mylist=mylist.replace(",","', '")
                      mylist= "['"+mylist+"']"

                  releaseVariables["artifact_build_version_artifactoryUrl"] = mylist
                  releaseVariables["artifact_build_version_path_var"]=artifactData2["results"][index]["path"]
                  releaseVariables["artifact_build_version_name_var"]=artifactData2["results"][index]["name"]

              def GetFinalArtifactData(myPathName,myArtifactName):
                  data1="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"},{\"path\":{\"$match\":\"%s\"}},{\"name\":{\"$match\":\"%s\"}}).include(\"name\",\"repo\",\"path\",\"created\",\"property\",\"artifact.module.build.url\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}",myPathName,myArtifactName)
                  artifactoryRequest1=urllib2.Request(url=artifactoryUrl,data=data1)
                  artifactoryRequest1.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
                  artifactoryRequest1.add_header("Content-Type", "text/plain")
                  jobResponse1=urllib2.urlopen(artifactoryRequest1).read()
                  artifactData1 = json.loads(jobResponse1)

                  releaseVariables["artifact_build_version_ciurl_var"]=artifactData1["results"][0]["artifacts"][0]["modules"][0]["builds"][0]["build.url"]

                  for i in xrange(len(artifactData1["results"][0]["properties"])):
                      if (artifactData1["results"][0]["properties"][i]["key"] == "ait.number"):
                          releaseVariables["artifact_build_version_ait_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "scm.location"):
                          releaseVariables["artifact_build_version_scmloc_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "build.number"):
                          releaseVariables["artifact_build_version_buildnum_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "scm.branch"):
                          releaseVariables["artifact_build_version_scmbranch_var"]=artifactData1["results"][0]["properties"][i]["value"]
                      if (artifactData1["results"][0]["properties"][i]["key"] == "${release_candidate_name}-Certified" and artifactData1["results"][0]["properties"][i]["value"] == "Yes"):
                          releaseVariables["isReleaseCandidate"]="Yes"


              if "${old_artifact_build_version_buildnum_var}" != "${artifact_build_version_buildnum_var}":
                  GetFinalArtifactUrlList("${artifact_build_version_buildnum_var}")
                  GetFinalArtifactData(releaseVariables["artifact_build_version_path_var"],releaseVariables["artifact_build_version_name_var"])
                  if (releaseVariables["isReleaseCandidate"] == "No"):
                      print 'The details entered does not correspond to a release candidate build.'
                      sys.exit(1)
              elif myNewUrlList[0] not in myOldUrlList:
                  myNewUrl=myNewUrlList[0].rsplit('/', 1)
                  GetFinalArtifactData(myNewUrl[0],myNewUrl[1])
                  if (releaseVariables["isReleaseCandidate"] == "No"):
                      print 'The details entered does not correspond to a release candidate build.'
                      sys.exit(1)


              releaseVariables["artifact_build_version_artifactorybrowseUrl"]="${global.artifactoryurl}/webapp/#/builds/${artifactoryBuildName}".replace(" ","%20")+"/"+releaseVariables["artifact_build_version_buildnum_var"]+"//published/"

              ### Set Deployment Dashboard parameters

              spkName = "${spkName}".upper().strip()
              delivery_environment_name = "${delivery_environment_name}".upper().strip()
              dashboard_delivery_environment_name = spkName + "-" + delivery_environment_name
              releaseVariables['dashboard_delivery_environment_name'] = dashboard_delivery_environment_name

              # ID
              dashboard_deployerId = str(dashboard_delivery_environment_name) + "-deployerId"
              releaseVariables[dashboard_deployerId] = "${towerDeployerIdProd}"
              ###XLR DMZ Integration
              if releaseVariables['deployDMZ_prod']=="Yes":
                      releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl'].replace("${global.artifactoryurl}","${global.dmzArtifactoryUrl_Prod}")
              else:
                  releaseVariables['published_artifact_url']=releaseVariables['artifact_build_version_artifactoryUrl']
              print("deployDMZ_prod==", releaseVariables['deployDMZ_prod'])
              print("Artifactory URL==", releaseVariables['published_artifact_url'])
          - name: Get job template id
            type: webhook.JsonWebhook
            URL: "${global.ansible-prod-towerurl}/api/v2/job_templates?name=${ansible_tower_job_template_name}"
            username: "${towerDeployerIdProd}"
            jsonPathExpression: "results[0].id"
            variableMapping:
              pythonScript.result: "${ansible_tower_job_template_id}"
              pythonScript.password: "${towerDeployerPasswordProd}"
          - name: "Deploy ${artifactoryBuildName}"
            type: ansible.RunPlaybook
            description: "## Deploy ${artifactoryBuildName}"
            flagComment: "Task 'Deploy ${artifactoryBuildName}' in Phase 'prod' has\
              \ been replaced by a manual task. The task of type 'ansible.LaunchJobTemplate'\
              \ could not be found because of a missing plugin."
            facets:
            - type: udm.DeploymentTaskFacet
              variableMapping:
                environmentId: "${dashboard_delivery_environment_name}"
                applicationId: "${component_name}"
                version: "${artifact_build_version_buildnum_var}"
            variableMapping:
              pythonScript.jobId: "${ansible_job_id}"
              pythonScript.password: "${towerDeployerPasswordProd}"
              pythonScript.inventory: "${ansible_tower_job_inventory_id}"
            tags:
            - key_process_step
          - name: Fetch ansible job log
            type: xlrelease.ScriptTask
            description: "#### This task will get latest version of the build artifact\
              \  ####"
            script: "releaseVariables[\"ansible_tower_job_url\"]=\"${global.ansible-prod-towerurl}/#/jobs/${ansible_job_id}\""
        - name: Kick off litmus tests
          type: xlrelease.SequentialGroup
          precondition: "\"${litmus_enable_automated_tests}\".lower() == \"yes\""
          tags:
          - key_process_step
          tasks:
          - name: Validate LitmusTest input
            type: xlrelease.ScriptTask
            script: |-
              val = "${artifact_build_version_ait_var}"
              if not val: raise ValueError("ait_number is mandatory parameter for LitmusTest execution.")

              val = "${litmus_test_component}"
              if not val: raise ValueError("litmusComponentName is mandatory parameter for LitmusTest execution. Please fill it with valid value for your environment.")

              val = "${litmus_test_url}"
              if not val: raise ValueError("litmusTargetApplicationUrl is mandatory parameter for LitmusTest execution.Please fill it with valid value for your environment.")

              val = "${litmus_spk}"
              if not val: raise ValueError("litmus_spk is mandatory parameter for LitmusTest execution.")

              releaseVariables['litmus_input_validated'] = True
          - name: Submit Litmus Request
            type: xlrelease.ScriptTask
            precondition: "releaseVariables['litmus_input_validated'] == True"
            script: |-
              import urllib2
              import json
              import datetime
              import sys

              payload = {
                "BuildRunID": "" ,
                "AIT": "${artifact_build_version_ait_var}",
                "SPK": "${litmus_spk}",
                "JobStatus": "New",
                "DeployedDate": str(datetime.datetime.now()),
                "TestPhase": "${litmus_phase}",
                "ApplicationURL": "${litmus_app_url}",
                "EnvironmentName": "${delivery_environment_name}",
                "Component": "${litmus_test_component}",
                "Requestor":"XLR"
              }
              print("Req to be submitted to LitmusTest is - \n")
              print(payload)

              # Send req to Litmus
              data=json.dumps(payload)

              baseURL = "${litmus_test_url}"
              if not baseURL.endswith("/"):
                  baseURL = baseURL +"/"
              url = baseURL+"LitmusTest/InsertEvent"

              req=urllib2.Request(url=url ,data=data)
              req.add_header("Content-Type", "application/json")
              response=urllib2.urlopen(req).read()
              message = json.loads(response)
              print("\nResponse received-\n")
              print(message)
              requestStatus = message["requestStatus"]
              releaseVariables['litmus_request_id'] = message["requestId"]
              if requestStatus == "Request has been successfully queued.":
                releaseVariables['req_submitted'] = True
                print("\nRequest has been submitted to LitmusTest with requestId - "+ str(message["requestId"]))
              else:
                  print("\nRequest could not be submitted to LitmusTest.\n")
                  print (requestStatus)
                  print("\n")
                  sys.exit(1)
          - name: Process Response
            type: xlrelease.SequentialGroup
            precondition: "releaseVariables['req_submitted'] == True"
            tasks:
            - name: Process Smoke Test Response
              type: xlrelease.ScriptTask
              script: |-
                import json
                import urllib2
                import time
                import sys

                payload = {
                    "requestId":${litmus_request_id}
                }

                # Send req to Litmus for status check
                data = json.dumps(payload)
                baseURL = "${litmus_test_url}"
                if not baseURL.endswith("/"):
                    baseURL = baseURL + "/"
                url = baseURL + "LitmusTest/GetRequestStatus"

                timePassed = 0
                timeoutOccured = True
                while (timePassed < int(${litmus_smoke_timeout})):
                    time.sleep(${litmus_polling_interval})
                    timePassed = timePassed + ${litmus_polling_interval}

                    req = urllib2.Request(url=url, data=data)
                    req.add_header("Content-Type", "application/json")
                    response = urllib2.urlopen(req).read()
                    message = json.loads(response)

                    executingStatus = message["executingStatus"]
                    returnCode = message["executingState"]
                    index = returnCode.find("(")
                    shortCode = returnCode
                    if index != -1:
                        shortCode = returnCode[:returnCode.find("(")]
                    shortCode = shortCode.lower()

                    if (executingStatus == 'Waiting' or executingStatus == 'Smoke Executing'):
                        continue
                    print(message)
                    print("\n")
                    print("\n")
                    timeoutOccured = False
                    executionDetails = message["executionDetails"]
                    if (executingStatus.__contains__("Executing")):
                        if (shortCode == "smoke_pass1"):
                            print("\nSmoke Test passed, Basic Test is scheduled.")
                            releaseVariables['litmus_process_basic'] = True
                        elif (shortCode == "smoke_pass2"):
                            print("\nSmoke Passed, Regression Test is scheduled")
                            releaseVariables['litmus_process_regression'] = True
                        elif (shortCode == "basic_pass"):
                            print("\nBasic Passed, Regression Test is scheduled")
                            releaseVariables['litmus_process_regression'] = True
                        else:
                            print("\nInvalid executing state received.\n")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                        print("\nTest execution summary- ")
                        for eDetail in executionDetails:
                            print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + eDetail["threshold"])
                    elif (executingStatus == 'Complete'):
                        if (shortCode == "request complete"):
                            print("\nRequest has been successfully completed.\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            releaseVariables['litmus_test_passed'] = True
                        elif (shortCode.__contains__("error")):
                            print("\nError occurred.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        elif (shortCode.__contains__("_fail")):
                            print("\nRequest failed.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        else:
                            print("\nInvalid executing state received.\n")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    else:
                        print("\nInvalid executing status received.\n")
                        print(executingStatus)
                        print("\n")
                        sys.exit(1)
                    break
                if timeoutOccured:
                    print("\nTimeout occurred.\n")
                    sys.exit(1)
            - name: Process Basic Test Response
              type: xlrelease.ScriptTask
              precondition: "releaseVariables['litmus_process_basic'] == True"
              script: |-
                import json
                import urllib2
                import time
                import sys

                payload = {
                    "requestId":${litmus_request_id}
                }

                # Send req to Litmus for status check
                data = json.dumps(payload)
                baseURL = "${litmus_test_url}"
                if not baseURL.endswith("/"):
                    baseURL = baseURL + "/"
                url = baseURL + "LitmusTest/GetRequestStatus"

                timePassed = 0
                timeoutOccured = True
                while (timePassed < int(${litmus_basic_timeout})):
                    time.sleep(${litmus_polling_interval})
                    timePassed = timePassed + ${litmus_polling_interval}

                    req = urllib2.Request(url=url, data=data)
                    req.add_header("Content-Type", "application/json")
                    response = urllib2.urlopen(req).read()
                    message = json.loads(response)
                    executingStatus = message["executingStatus"]
                    returnCode = message["executingState"]
                    index = returnCode.find("(")
                    shortCode = returnCode
                    if index != -1:
                        shortCode = returnCode[:returnCode.find("(")]
                    shortCode = shortCode.lower()

                    if (executingStatus == 'Basic Executing'):
                        continue
                    print(message)
                    print("\n")
                    print("\n")
                    timeoutOccured = False
                    executionDetails = message["executionDetails"]
                    if (executingStatus == "Regression Executing"):
                        if (shortCode == "basic_pass"):
                            print("\nBasic Passed, Regression Test is scheduled\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            releaseVariables['litmus_process_regression'] = True
                        else:
                            print("\nInvalid executing state received.\n")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    elif (executingStatus == 'Complete'):
                        if (shortCode == "request complete"):
                            print("\nRequest has been successfully completed.\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            releaseVariables['litmus_test_passed'] = True
                        elif (shortCode.__contains__("error")):
                            print("\nError occurred.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        elif (shortCode.__contains__("_fail")):
                            print("\nRequest failed.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : " + eDetail["testType"] + ", Total : " + str(eDetail["total"]) + ", Pass : " + str(
                                    eDetail["pass"]) + ", Fail : " + str(eDetail["fail"]) + ", Threshold : " + str(
                                    eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        else:
                            print("\nInvalid executing state received.")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    else:
                        print("\nInvalid executing status received.\n")
                        print(executingStatus)
                        print("\n")
                        sys.exit(1)
                    break
                if timeoutOccured:
                    print("\nTimeout occurred.\n")
                    sys.exit(1)
            - name: Process Regression Test Response
              type: xlrelease.ScriptTask
              precondition: "releaseVariables['litmus_process_regression'] == True"
              script: |-
                import json
                import urllib2
                import time
                import sys

                payload = {
                  "requestId":${litmus_request_id}
                }

                # Send req to Litmus for status check
                data = json.dumps(payload)
                baseURL = "${litmus_test_url}"
                if not baseURL.endswith("/"):
                    baseURL = baseURL +"/"
                url = baseURL+"LitmusTest/GetRequestStatus"

                timePassed = 0
                timeoutOccured = True
                while (timePassed < int(${litmus_regression_timeout})):
                    time.sleep(${litmus_polling_interval})
                    timePassed = timePassed+ ${litmus_polling_interval}

                    req = urllib2.Request(url=url, data=data)
                    req.add_header("Content-Type", "application/json")
                    response = urllib2.urlopen(req).read()
                    message = json.loads(response)

                    executingStatus = message["executingStatus"]
                    returnCode = message["executingState"]
                    index = returnCode.find("(")
                    shortCode = returnCode
                    if index != -1:
                        shortCode = returnCode[:returnCode.find("(")]
                    shortCode = shortCode.lower()
                    if (executingStatus == 'Regression Executing' ):
                        continue
                    print(message)
                    print("\n")
                    print("\n")
                    timeoutOccured = False
                    executionDetails = message["executionDetails"]
                    if(executingStatus == 'Complete'):
                        if(shortCode == "request complete"):
                            print("\nRequest has been successfully completed.\n")
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                            releaseVariables['litmus_test_passed'] = True
                        elif(shortCode.__contains__("error")):
                            print("\nError occurred.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        elif (shortCode.__contains__("_fail")):
                            print("\nRequest failed.\n")
                            print(returnCode)
                            print("\nTest execution summary- ")
                            for eDetail in executionDetails:
                                print("\nTestType : "+eDetail["testType"]+", Total : "+str(eDetail["total"])+", Pass : "+str(eDetail["pass"])+", Fail : "+str(eDetail["fail"])+", Threshold : "+str(eDetail["threshold"]))
                            print("\n")
                            sys.exit(1)
                        else:
                            print("\nInvalid executing state received.")
                            print(returnCode)
                            print("\n")
                            sys.exit(1)
                    else:
                        print("\nInvalid executing status received.\n")
                        print(executingStatus)
                        print("\n")
                        sys.exit(1)
                    break
                if timeoutOccured:
                    print("\nTimeout occurred.\n")
                    sys.exit(1)
            - name: Sign off LitmusTest execution
              type: xlrelease.GateTask
              description: |-
                #### Hello Quality Engineer ${delivery_environment_type} Team :-

                Please review litmus test results and click "complete" to sign off.
              tags:
              - key_process_step
        - name: Post deployment certification by Quality Engineer PROD team
          type: xlrelease.GateTask
          description: |-
            #### Hello Quality Engineer ${delivery_environment_type} Team :-

            Can ${artifact_build_version_artifactoryUrl} be marked ${delivery_environment_name}-Certified=true in Artifactory ?

            Click "Complete" to confirm
          tags:
          - key_process_step
          conditions:
          - name: "Tests executed, results reviewed. Build looks good ! OK to certify?"
            type: xlrelease.GateCondition
        - name: Certify build artifact version (s)
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: "Mark the artifact  ${artifactoryBuildName} certified in artifactory"
            type: xlrelease.ScriptTask
            tags:
            - key_process_step
            script: |-
              ### Set Deployment Dashboard parameters

              dashboard_delivery_environment_name = "${dashboard_delivery_environment_name}"
              dashboard_certStatus = str(dashboard_delivery_environment_name) + "-certStatus"
              ######

              full_url = "${artifact_build_version_artifactoryUrl}"
              urls_list = full_url.split(",")

              for myurl in urls_list:
                  api_call_url=myurl.replace("'","")
                  api_call_url=api_call_url.replace("[","")
                  api_call_url=api_call_url.replace("]","")
                  api_call_url=api_call_url.replace(" ","")
                  api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

                  artifact_url_to_update=api_call_url+"?properties="+"${delivery_environment_name}"+"-Certified=Yes"
                  request = HttpRequest({'url': '${global.artifactoryurl}'})
                  headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                  response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                  status = response.getStatus()

                  if response.getStatus() == 204:
                      releaseVariables[dashboard_certStatus] = 'Certified'
                      print myurl, " have been certified"
                      print '\n'
                  else:
                      print myurl, " could not be certified"
                      sys.exit(1)
          - name: "Mark Build Number:${artifact_build_version_buildnum_var} as a Release\
              \ Candidate"
            type: xlrelease.ScriptTask
            tags:
            - key_process_step
            script: |-
              import urllib2
              import json

              artifactoryUrl="${global.artifactoryurl}/api/search/aql"

              data="items.find({\"repo\":\"%s\"},{\"@build.name\":\"%s\"}).include(\"name\",\"repo\",\"path\",\"property\")" %("${artifactoryBuildRepo}","${artifactoryBuildName}")
              artifactoryRequest=urllib2.Request(url=artifactoryUrl,data=data)
              artifactoryRequest.add_header("X-JFrog-Art-Api", "${ArtifactoryAPIkey}")
              artifactoryRequest.add_header("Content-Type", "text/plain")
              artifactoryResponse=urllib2.urlopen(artifactoryRequest).read()
              artifactData = json.loads(artifactoryResponse)
              print type(artifactData)

              #UnTag the Previous Release Candidate
              mylist=""
              for i in xrange(len(artifactData["results"])):
                  for j in xrange(len(artifactData["results"][i]["properties"])):
                      if (artifactData["results"][i]["properties"][j]["key"] == "${release_candidate_name}-Certified" and artifactData["results"][i]["properties"][j]["value"] == "Yes"):
                          artifact_url_to_update="/api/storage"+"/"+artifactData["results"][i]["repo"]+"/"+artifactData["results"][i]["path"]+"/"+artifactData["results"][i]["name"]+"?properties="+"${release_candidate_name}"+"-Certified=No"
                          request = HttpRequest({'url': '${global.artifactoryurl}'})
                          headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                          response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                          status = response.getStatus()


              #Tag the current build as Release Candidate
              full_url = "${artifact_build_version_artifactoryUrl}"
              urls_list = full_url.split(",")
              for myurl in urls_list:
                  api_call_url=myurl.replace("'","")
                  api_call_url=api_call_url.replace("[","")
                  api_call_url=api_call_url.replace("]","")
                  api_call_url=api_call_url.replace(" ","")
                  api_call_url=api_call_url.replace("${global.artifactoryurl}","/api/storage")

                  artifact_url_to_update=api_call_url+"?properties="+"${release_candidate_name}"+"-Certified=Yes"
                  request = HttpRequest({'url': '${global.artifactoryurl}'})
                  headers = {'X-JFrog-Art-Api': '${ArtifactoryAPIkey}'}
                  response = request.put(artifact_url_to_update,"",contentType = 'text/plain',headers = headers)
                  status = response.getStatus()
                  if response.getStatus() == 204:
                      print myurl, " have been certified as a Release Candidate"
                      print '\n'
                  else:
                      print myurl, " could not be certified as a Release Candidate"
                      sys.exit(1)
          - name: Phase certification summary
            type: xlrelease.ScriptTask
            script: |-
              #phase_certified_artifact_version_name="phase_certified_artifact_version_"+"${component_name}"
              releaseVariables["phase_certified_artifact_version_name"] = "${artifact_build_version_artifactoryUrl}"

              #phase_certified_artifact_property_name = "phase_certified_artifact_property_"+"${component_name}"
              releaseVariables["phase_certified_artifact_property_name"] = "${delivery_environment_name}-Certified"
        - name: User story status update
          type: xlrelease.SequentialGroup
          precondition: "\"${jiraEnableStatusUpdates}\".lower() == \"yes\""
          tags:
          - key_process_step
          tasks:
          - name: Confirm FixVersion and credentials for JIRA
            type: xlrelease.UserInputTask
            description: Please enter the required information below.
            tags:
            - key_process_step
            variables:
            - jira_fixversion
            - jiraUserId
            - jiraUserPassword
          - name: Get list of user stories associated with this release
            type: jira.Query
            username: "${jiraUserId}"
            query: "project = \"${jira_project}\" AND issuetype = Story AND fixVersion\
              \ = \"${jira_fixversion}\""
            variableMapping:
              pythonScript.password: "${jiraUserPassword}"
              pythonScript.issues: "${user_stories_list}"
          - name: Get list of user stories associated with this release that are currently
              in "READY TO RELEASE" status
            type: jira.Query
            username: "${jiraUserId}"
            query: "project = \"${jira_project}\" AND issuetype = Story AND fixVersion\
              \ = \"${jira_fixversion}\" AND status = \"Ready to Release\""
            variableMapping:
              pythonScript.issues: "${ready_to_release_user_stories}"
              pythonScript.password: "${jiraUserPassword}"
          - name: Confirm the list of stories whose status needs to be updated to
              "RELEASED"
            type: xlrelease.UserInputTask
            description: "#### Confirm if the list of stories below can be updated\
              \ to \"RELEASED\" state ####"
            tags:
            - key_process_step
            variables:
            - user_stories_list
            - ready_to_release_user_stories
          - name: Construct Jira URL
            type: xlrelease.ScriptTask
            script: |-
              jira_stories = ${user_stories_list}

              url_list = ""

              for story in jira_stories:
                  construct_url = "${global.jiraurl}/browse/" + story
                  url_list = url_list + "\n\n" + construct_url

              print url_list
              releaseVariables['fixversion_stories_jira_url'] = url_list
          - name: Update status of confirmed user stories to "RELEASED"
            type: jira.UpdateIssues
            username: "${jiraUserId}"
            newStatus: RELEASED
            comment: "Released via ITSM change ${target_release_crq_number}"
            variableMapping:
              pythonScript.password: "${jiraUserPassword}"
              pythonScript.issues: "${user_stories_list}"
        - name: Closure
          type: xlrelease.SequentialGroup
          tags:
          - key_process_step
          tasks:
          - name: "Update ${target_release_crq_number} work info w/ delivery pipeline\
              \ status"
            type: xlrelease.ScriptTask
            precondition: "releaseVariables['remedyEnableIntegration'] == 'Yes'"
            script: |-
              import urllib2
              import json
              import time
              import base64

              url="${global.remedyurl}/security/issueToken?servicename=changeservice"

              req=urllib2.Request(url=url,data="")

              req.add_header("Content-Type", "application/x-www-form-urlencoded")
              req.add_header("userName", "ZS30SW4")
              req.add_header("password", base64.b64decode("cndralMyWXE="))

              Token=urllib2.urlopen(req).read()
              #releaseVariables["muleToken"]=Token


              # defining the api-endpoint
              url2="${global.remedyurl}/api/change/${target_release_crq_number}/updatechange"


              transaction_datetime = time.strftime('%Y-%m-%dT%H:%M:%S')

              transId ="XLR_Add_Worklog_"+str(transaction_datetime)

              # sourceReqId is obtained from Remedy (its constant and wont change for every call)
              #sourceReqId = 'XLR_GWB_CHANGE_002'

              print("transaction ID:", transId)

              json1={
                  "transactionDetails": {
                  "transactionType": "ADDWORKLOG",
                  "transactionId": transId,
                  "eventSource": "XLR_GWB_CHANGE",
                  "sourceRequestId": "XLR_GWB_CHANGE",
                  "eventTarget": "BAC_CHANGE",
                  "targetRequestId": "${target_release_crq_number}",
                  "transactionDate": transaction_datetime
                },
                "updateSystemManaged": {
                  "personIdType": "LoginName",
                  "createdBy": "${xlr_remedy_workinfo_creator}"
                },
                "changeWorkInfo": {
                  "workLogId": "",
                  "workLogType": "General Information",
                  "workLogNotes": """${spkName} ${component_name} has been successfully deployed, tested & certified in Production environment  \n\n Deployed artifacts:  ${artifact_build_version_artifactorybrowseUrl} \n\n Released User Stories: ${fixversion_stories_jira_url}  \n\n For further details on this release, check delivery pipeline ${delivery_pipeline_url}""",
                  "workLogSubmitter": "${xlr_remedy_workinfo_workLogSubmitter}",
                  "workLogAccess": "Public"
                 }
              }

              print(json1)

              # data to be sent to api
              data=json.dumps(json1)

              req1=urllib2.Request(url=url2,data=data)

              req1.add_header("Authorization", Token)
              req1.add_header("Content-Type", "application/json")
              req1.get_method = lambda : 'PUT'

              response=urllib2.urlopen(req1).read()
              message = json.loads(response)
              print(message)
          - name: Update release name
            type: xlrelease.ScriptTask
            script: |-
              current_release = getCurrentRelease()

              current_release.title = "{0} - {1}".format(current_release.title,"${target_release_crq_number}")
              current_release.description = "${spkName} ${component_name} has been successfully deployed, tested & certified in DEV & LLE environments  \n\nDeployed artifacts:  ${artifact_build_version_artifactorybrowseUrl} \n\nFor further details on this release, check delivery pipeline ${delivery_pipeline_url}"


              releaseApi.updateRelease(current_release)
          - name: Compile Email Notification
            type: xlrelease.ScriptTask
            script: |-
              releaseVariables["email_body"] = "${spkName} ${component_name} has been successfully"
              releaseVariables["email_body_content"] =""
              releaseVariables['jira'] = ""
              phase_Title = getCurrentPhase().getTitle()
              release_Id = getCurrentRelease().getId()
              print ("phase_Title===", phase_Title)
              print("release_Id===", release_Id)

              deploy = getTasksByTitle("Deploy ${artifactoryBuildName}", phaseTitle = phase_Title, releaseId = release_Id)
              litmus = getTasksByTitle("Sign off LitmusTest execution", phaseTitle = phase_Title, releaseId = release_Id)
              cert = getTasksByTitle("Post deployment certification by Quality Engineer PROD team", phaseTitle = phase_Title, releaseId = release_Id)
              jira = getTasksByTitle('Update status of confirmed user stories to "RELEASED"', phaseTitle = phase_Title, releaseId = release_Id)
              if len(deploy) != 0 and deploy[0]['status'] == "COMPLETED":
                  releaseVariables["email_body"] = releaseVariables["email_body"]+" deployed "
                  releaseVariables["email_body_content"] = "- #### Deployed artifacts: \n ${artifact_build_version_artifactorybrowseUrl} \n" + "- #### Refer the below url for tower job details: \n ${ansible_tower_job_url}"
              if len(litmus)!=0 and litmus[0]['status'] == "COMPLETED":
                  releaseVariables["email_body"] = releaseVariables["email_body"]+", litmus test executed "
              if len(cert)!=0 and cert[0]['status'] == "COMPLETED":
                 releaseVariables["email_body"] = releaseVariables["email_body"]+"& certified"
              if jira[0]['status']=="COMPLETED":
                  releaseVariables['jira'] = """- #### Released user stories: \n ${fixversion_stories_jira_url}"""

              if deploy[0]['status'] =="SKIPPED" and litmus[0]['status']=="SKIPPED" and cert[0]['status'] == "SKIPPED":
                  releaseVariables["email_body"] ="Deployment, Litmus test execution and certification of ${spkName} ${component_name} has been skipped"
              releaseVariables["email_body"] = releaseVariables["email_body"]+" in ${delivery_environment_name}"
              releaseVariables['prod_crq'] = """- #### Production change record:  [${target_release_crq_number}](${global.itsmurl}${target_release_crq_number}) \n\n"""
              print("Deploy status ==", deploy[0]['status'])
              print ("Cert status ===", cert[0]['status'])
              print("JIRA Status==",jira[0]['status'])
              print("Litmus status ==", litmus[0]['status'])
              print(releaseVariables["email_body"])
          - name: Send release notification
            type: xlrelease.NotificationTask
            description: "#### Send email notification for ${delivery_environment_name}\
              \ release ####"
            tags:
            - key_process_step
            addresses:
            - "${release_notification_list}"
            subject: "${spkName} ${component_name} release to ${delivery_environment_name}\
              \ - ${target_release_crq_number}"
            body: |-
              #### ${email_body}

              ${prod_crq}

              ${email_body_content}

              ${jira}

              - #### Refer release pipeline below for more info via 2 available options (flow view , table view):
              ${delivery_pipeline_url}
        color: '#009CDB'
      realFlagStatus: ATTENTION_NEEDED
      variables:
      - type: xlrelease.StringVariable
        key: MANUAL-DATA-ENTRY_SECTION_START
        requiresValue: false
        value: "###############  MANUAL ENTRY ###############"
      - type: xlrelease.PasswordStringVariable
        key: towerDeployerPasswordNonProd
        requiresValue: false
        description: Password of the deployer id that has permissions to execute your
          component's deployment job template
      - type: xlrelease.PasswordStringVariable
        key: towerDeployerPasswordProd
        requiresValue: false
        description: Password of the deployer id that has permissions to execute your
          component's deployment job template
      - type: xlrelease.StringVariable
        key: MANUAL-ENTRY-SECTION-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: ENV-SECTION-START
        requiresValue: false
        value: "####### ENVIRONMENT METADATA #########"
      - type: xlrelease.StringVariable
        key: spkName
        requiresValue: false
        description: "What's your SPK name? (This will be used as tags for reporting)\
          \ [e.g RPIST]"
        value: ETASC
      - type: xlrelease.StringVariable
        key: lobName
        requiresValue: false
        description: "What's your LOB name? (This will be used as tags for reporting)\
          \ [e.g GBAM or CSWT or CDO]"
      - type: xlrelease.ListStringVariable
        key: spkComponentsToRelease
        requiresValue: false
        description: "[WHAT TO RELEASE] - Component Name is your Bitbucket Repo Name\
          \ (a buildable unit) which has a corresponding Jenkins build job"
        value:
        - dee_poc_delivery
      - type: xlrelease.ListStringVariable
        key: releaseEnvironments
        requiresValue: false
        description: "[WHERE TO RELEASE] - List of environments that the components\
          \ will be deployed too  (e.g Dev,DIT,CIT,SIT,UAT,PreProd,Prod etc). Keep\
          \ the names same as the ones you'd use in your ansible playbooks. Ensure\
          \ entries are in the order of their execution"
      - type: xlrelease.MapStringStringVariable
        key: phaseType
        requiresValue: false
        description: "Map your environments names i.e., for each of the environment\
          \ defined in the \"releaseEnvironments\" variable to their types (options\
          \ are: DEV, LLE or PROD). Based on environment type, gate approvers will\
          \ be automatically assigned to their respective Deployer & Quality Engineer\
          \ teams.  Here the release environment name as defined in \"releaseEnvironments\"\
          \ variable is the Key and the value is either DEV, LLE or PROD. For ex:\
          \ SIT will be mapped to DEV, UAT to LLE and PROD to PROD. (keep them same,\
          \ case sensitive)"
      - type: xlrelease.StringVariable
        key: ENV-SECTION-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: TOWER-SECTION-START
        requiresValue: false
        value: "############## ANSIBLE TOWER ###########"
      - type: xlrelease.MapStringStringVariable
        key: towerJobTemplate
        requiresValue: false
        description: "Names of Ansible deployment job template for each one of the\
          \ environment defined in the variable \"releaseEnvironments.\" Enter it\
          \ in key-value pair with key being the environment name as entered in the\
          \ \"releaseEnvironments\" variable and value being ansible job deployment.\
          \ (keep them same, case sensitive) and value being the comma separated list\
          \ for all the components in the same order as mentioned in the above fields.\
          \ Please ensure key-value entries for all the envs setup in this template"
      - type: xlrelease.MapStringStringVariable
        key: towerInventory
        requiresValue: false
        description: "Names of Ansible inventory for each one of the environment defined\
          \ in the variable \"releaseEnvironments.\" Enter it in key-value pair with\
          \ key being the environment name as entered in the \"releaseEnvironments\"\
          \ variable and value being ansible inventory name. (keep them same, case\
          \ sensitive). You can leave blank for the value if you dont want provide\
          \ inventory name but Key should be mandatory."
      - type: xlrelease.StringVariable
        key: towerDeployerIdNonProd
        requiresValue: false
        description: Deployer id that has permissions to execute the components deployment
          job templates in tower. Leave it blank if you want to type it in at run
          time. This value can be overwritten at run time
      - type: xlrelease.StringVariable
        key: towerDeployerIdProd
        requiresValue: false
        description: Deployer id that has permissions to execute the components deployment
          Prod job templates in tower. Leave it blank if you want to type it in at
          run time. This value can be overwritten at run time
      - type: xlrelease.MapStringStringVariable
        key: towerAnsibleExtras
        requiresValue: false
        description: "Do you have extra vars w/ static values for every env? If yes,\
          \ type them in here in key-value format. Key is extra var name, value is\
          \ its value"
      - type: xlrelease.StringVariable
        key: TOWER-SECTION-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: ARTIFACTORY-SECTION-START
        requiresValue: false
        value: "############# ARTIFACTORY #############"
      - type: xlrelease.StringVariable
        key: artifactoryBuildName
        requiresValue: false
        description: "Enter the corresponding artifactory build name for the component.\
          \ Eg. ETASC :: dee_poc_delivery :: release :: runit-release-2.0"
        value: "ETASC :: dee_poc_delivery :: release :: runit-release-2.0"
      - type: xlrelease.StringVariable
        key: artifactoryBuildRepo
        requiresValue: false
        description: "Enter the repository location where the build artifacts are\
          \ stored in artifactory.  Eg: libs-release-local-maven"
      - type: xlrelease.StringVariable
        key: ARTIFACTORY-SECTION-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: EMAIL-SECTION-START
        requiresValue: false
        value: "##### EMAIL NOTIFICATION LISTS #############"
      - type: xlrelease.StringVariable
        key: phaseNotificationDg_dev
        requiresValue: false
        description: "comma seperated email ids for DEV release notifications (Eg\
          \ user@domain.com, user@domain.com)"
      - type: xlrelease.StringVariable
        key: phaseNotificationDg_lle
        requiresValue: false
        description: "comma separated email ids/DG for LLE release notifications \
          \ (Eg user@domain.com, user@domain.com)"
      - type: xlrelease.StringVariable
        key: phaseNotificationDg_prod
        requiresValue: false
        description: "comma separated email ids/DG for PROD release notifications\
          \ (Eg user@domain.com, user@domain.com)"
      - type: xlrelease.StringVariable
        key: EMAIL-SECTION-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: GATES-SECTION-START
        requiresValue: false
        value: "########## DEPLOYMENT GATES ###########"
      - type: xlrelease.StringVariable
        key: phaseEnablePreDeployGate_dev
        requiresValue: false
        description: Do you want to have a gate assigned to "Deployer DEV" team to
          approve before triggering DEV deployments in the release flow
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - "Yes"
          - "No"
      - type: xlrelease.StringVariable
        key: phaseEnablePostDeployGate_dev
        requiresValue: false
        description: Do you want to have a gate assigned to "Quality Engineer DEV"
          team to approve and sign off on DEV deployments?
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - "Yes"
          - "No"
      - type: xlrelease.StringVariable
        key: phaseEnablePreDeployGate_lle
        requiresValue: false
        description: Do you want to have a gate assigned to "Deployer LLE" team to
          approve before triggering LLE deployments in the release flow
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - "Yes"
          - "No"
      - type: xlrelease.StringVariable
        key: phaseEnablePostDeployGate_lle
        requiresValue: false
        description: Do you want to have a gate assigned to "Quality Engineer LLE"
          team to approve and sign off on LLE deployments?
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - "Yes"
          - "No"
      - type: xlrelease.StringVariable
        key: GATES-SECTION-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: JIRA-SECTION-START
        requiresValue: false
        value: "################# JIRA #################"
      - type: xlrelease.StringVariable
        key: jiraEnableStatusUpdates
        requiresValue: false
        description: "set it to yes if you want to enable steps to auto update jira\
          \ story status during production release. If set to true, fill in 4 questions\
          \ that follows next else keep them blank or NA"
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - "Yes"
          - "No"
      - type: xlrelease.StringVariable
        key: jiraUserId
        requiresValue: false
        description: User ID that can query your JIRA project and update story status
      - type: xlrelease.PasswordStringVariable
        key: jiraUserPassword
        requiresValue: false
        description: Password associated with that user ID that can query your JIRA
          project and update story status
      - type: xlrelease.StringVariable
        key: JIRA-SECTION-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: REMEDY-SECTION-START
        requiresValue: false
        value: "############# REMEDY ITSM #############"
      - type: xlrelease.StringVariable
        key: remedyEnableIntegration
        requiresValue: false
        description: "Please select true if you want to enable tasks in this XLR template\
          \ that would auto query/update CRQ [NOTE: This functionality is not available\
          \ for Remedy Production instance. All the values in the variables below\
          \ prefixed as xlr are for demo purposes only]"
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - "Yes"
          - "No"
      - type: xlrelease.StringVariable
        key: REMEDY-SECTION-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: LITMUS-SECTION-START
        requiresValue: false
        value: "############## LITMUS  ################"
      - type: xlrelease.MapStringStringVariable
        key: litmusEnableFunctionalTests
        requiresValue: false
        description: "Do you want to enable/disable automated tests in each your envs?\
          \ Enter it in key-value pair w/ key being the environment name as entered\
          \ in the prior variable (keep them same, case sensitive). To enable automated\
          \ test cases, value will be 'Yes', otherwise test cases will be disabled.\
          \ By default automated test cases are disabled."
      - type: xlrelease.MapStringStringVariable
        key: litmusComponentName
        requiresValue: false
        description: "What are the names of LitmusTest components for each one of\
          \ your envs? Enter it in key-value pair w/ key being the environment name\
          \ as entered in the prior variable (keep them same, case sensitive). Please\
          \ ensure key-value entries for all the envs setup in this template"
      - type: xlrelease.MapStringStringVariable
        key: litmusTargetApplicationUrl
        requiresValue: false
        description: "What are the URLs of LitmusTest rest endpoint for each one of\
          \ your envs? Enter it in key-value pair w/ key being the environment name\
          \ as entered in the prior variable (keep them same, case sensitive). Please\
          \ ensure key-value entries for all the envs setup in this template"
      - type: xlrelease.StringVariable
        key: LITMUS-SECTION-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: SONAR-SECTION-START
        requiresValue: false
        value: "################# SONAR ##############"
      - type: xlrelease.MapStringStringVariable
        key: sonarEnableMetricsCheck
        requiresValue: false
        description: "Where do you want a gate for sonar metrics check in the release\
          \ flow? If yes, fill in the sonar section variables below"
      - type: xlrelease.StringVariable
        key: sonarComponentKey
        requiresValue: false
        description: "Please provide the Sonar Project Key from the Sonar properties\
          \ file , example: INC-source-44849"
      - type: xlrelease.StringVariable
        key: SONAR-SECTION-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: DEFAULT-VALUES-START
        requiresValue: false
        value: '#############DEFAULT VALUES#############'
      - type: xlrelease.StringVariable
        key: osPlatform
        requiresValue: false
        description: "This variable is needed as part of mandatory Matrix adoption.\
          \ Select application OS platform. Ex: Linux/windows"
        value: Linux
      - type: xlrelease.StringVariable
        key: target_release_crq_number
        requiresValue: false
        description: Please enter the valid CRQ number (e.g CRQ000001607133)
      - type: xlrelease.StringVariable
        key: integrated_release_name
        requiresValue: false
        description: Please Do Not Configure this value
      - type: xlrelease.StringVariable
        key: DEFAULT-VALUES-END
        requiresValue: false
        value: '######################################'
      - type: xlrelease.StringVariable
        key: xlr_remedy_workinfo_creator
        requiresValue: false
        showOnReleaseStart: false
        description: This is the nbk-id of the user who creates the worklog of CRQ
          in Remedy. The value of this variable auto set during the execution of the
          release.
      - type: xlrelease.StringVariable
        key: xlr_remedy_workinfo_workLogSubmitter
        requiresValue: false
        showOnReleaseStart: false
        description: This is the nbk-id of the user who submits the worklog of CRQ
          in Remedy. The value of this variable auto set during the execution of the
          release.
      - type: xlrelease.StringVariable
        key: ArtifactoryAPIkey
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: CurrentArtifactoryAPIkey
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: artifact_build_version_var
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: artifact_build_version_path_var
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: delivery_environment_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: jira_fixversion
        requiresValue: false
        showOnReleaseStart: false
        description: What's the value of FixVersion (release name) in your JIRA project
          for this production release?
      - type: xlrelease.MapStringStringVariable
        key: user_stories_list
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: artifact_build_version_repo_var
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: delivery_environment_type
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: component_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: litmus_polling_interval
        requiresValue: false
        showOnReleaseStart: false
        description: "This is time in Seconds, between two successive 'status check'\
          \ calls to LitmusTest.[e.g. 300]. Default value is 300."
        value: "300"
      - type: xlrelease.StringVariable
        key: ansible_tower_job_template_id
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: artifact_build_version_artifactoryUrl
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: litmus_spk
        requiresValue: false
        showOnReleaseStart: false
        description: What's the SPK associated with the Litmustest this template intends
          to execute?
      - type: xlrelease.StringVariable
        key: ansible_tower_job_template_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: release_notification_list
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: CRQStatus
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: litmus_phase
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: litmus_enable_automated_tests
        requiresValue: false
        showOnReleaseStart: false
        description: yes/no
      - type: xlrelease.StringVariable
        key: phase_certified_artifact_property
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: phase_certified_artifact_version
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: delivery_pipeline_url
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.MapStringStringVariable
        key: ready_to_release_user_stories
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: enable_sonar_metrics_check
        requiresValue: false
        showOnReleaseStart: false
        description: The value of this variable will be auto set based on the sonarEnableMetricsCheck
          value
        valueProvider:
          type: xlrelease.ListOfStringValueProviderConfiguration
          values:
          - "Yes"
          - "No"
      - type: xlrelease.StringVariable
        key: SonarQube_token
        requiresValue: false
        showOnReleaseStart: false
        description: This is auto generated by XLR
      - type: xlrelease.StringVariable
        key: sonarqube_blocker_violations
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: sonarqube_bugs
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: sonarqube_code_smells
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: sonarqube_critical_violations
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: sonarqube_duplicated_blocks
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: sonarqube_duplicated_lines_density
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: sonarqube_ncloc
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: sonarqube_quality_gate
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: sonarqube_vulnerabilities
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: fixversion_stories_jira_url
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: artifact_build_version_artifactorybrowseUrl
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: artifact_build_version_ait_var
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: artifact_build_version_scmloc_var
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: release_owner
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: artifact_build_version_buildnum_var
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: artifact_build_version_ciurl_var
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.MapStringStringVariable
        key: litmus_env_to_app_url_mapping
        requiresValue: false
        showOnReleaseStart: false
        description: "What are the URLs of application you want LitmusTest to use\
          \ to run the test cases for each one of your envs? Enter it in key-value\
          \ pair w/ key being the environment name as entered in the prior variable\
          \ (keep them same, case sensitive). Please ensure key-value entries for\
          \ all the envs setup in this template"
      - type: xlrelease.StringVariable
        key: artifact_build_version_scmbranch_var
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: litmus_test_url
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.BooleanVariable
        key: req_submitted
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: litmus_request_id
        requiresValue: false
        showOnReleaseStart: false
        description: requestId returned by Litmus
      - type: xlrelease.BooleanVariable
        key: litmus_test_passed
        requiresValue: false
        showOnReleaseStart: false
        label: Tells the result of Litmus test execution
      - type: xlrelease.BooleanVariable
        key: litmus_process_basic
        requiresValue: false
        showOnReleaseStart: false
        label: Tells if Basic test should be executed or not
      - type: xlrelease.StringVariable
        key: litmus_test_component
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.BooleanVariable
        key: litmus_input_validated
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.BooleanVariable
        key: litmus_process_regression
        requiresValue: false
        showOnReleaseStart: false
        label: Tells if regression test result task should be processed or not
      - type: xlrelease.StringVariable
        key: litmus_basic_timeout
        requiresValue: false
        showOnReleaseStart: false
        value: "5400"
      - type: xlrelease.StringVariable
        key: litmus_regression_timeout
        requiresValue: false
        showOnReleaseStart: false
        value: "14400"
      - type: xlrelease.StringVariable
        key: litmus_smoke_timeout
        requiresValue: false
        showOnReleaseStart: false
        value: "1200"
      - type: xlrelease.StringVariable
        key: litmus_app_url
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: phase_certified_artifact_property_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: phase_certified_artifact_version_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: nonprod_tower_deployer_id
        showOnReleaseStart: false
      - type: xlrelease.PasswordStringVariable
        key: nonprod_tower_deployer_password
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: jira_project
        requiresValue: false
        showOnReleaseStart: false
        description: What's your JIRA project name? (This should be same as SPK name)
      - type: xlrelease.MapStringStringVariable
        key: litmus_env_to_phase_mapping
        requiresValue: false
        showOnReleaseStart: false
        description: "What are the names of test phase for each one of your envs?\
          \ Enter it in key-value pair w/ key being the environment name as entered\
          \ in the prior variable (keep them same, case sensitive). Please ensure\
          \ key-value entries for all the envs setup in this template"
      - type: xlrelease.StringVariable
        key: jenkinsTriggerInfo
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: grm_record_code
        requiresValue: false
        showOnReleaseStart: false
        value: BEN-04-05
      - type: xlrelease.StringVariable
        key: grm_record_jurisdiction
        requiresValue: false
        showOnReleaseStart: false
        value: US
      - type: xlrelease.StringVariable
        key: auto_refresh_test
        requiresValue: false
        showOnReleaseStart: false
        value: "123"
      - type: xlrelease.StringVariable
        key: master_template_version
        requiresValue: false
        showOnReleaseStart: false
        description: "This variable used to identify the master template version for\
          \ Auto Refresh Utility, so don't delete it"
        value: "Universal release template (release branch)  version 2.0 Production\
          \ date : 03/09/19"
      - type: xlrelease.StringVariable
        key: artifact_build_name_url_format
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: old_artifact_build_version_artifactoryUrl
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: old_artifact_build_version_buildnum_var
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: original_release_title
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: dashboard_delivery_environment_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: email_body_content
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: email_body
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: jira
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: release_candidate_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: artifactory_certification_history
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: release_config_file_repo_url
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: prod_crq
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: ansible_tower_job_inventory_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: ansible_tower_job_inventory
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: ansible_tower_instance_group
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.IntegerVariable
        key: ansible_tower_job_inventory_id
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: published_artifact_url
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: repo_user
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: ansible_template_inventory_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: tower_job_inventory_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: ansible_tower_job_template_instance_group_url
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: ansible_tower_instance_group_from_template
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: xlr_inventory_name
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.ListStringVariable
        key: temp_integrated_release_environment
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: ansible_job_id
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: ansible_tower_job_url
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: jenkinsBuildNo
        requiresValue: false
        showOnReleaseStart: false
      - type: xlrelease.StringVariable
        key: release_config_file_content
        requiresValue: false
        showOnReleaseStart: false
      allowConcurrentReleasesFromTrigger: false
      riskProfile: Default risk profile
- directory: Workflow Executions
---
apiVersion: xl-release/v1
kind: Permissions
metadata:
  home: Digital.ai - Official
spec:
- directory: "."
  teams:
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
  - name: Folder Owner
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
- directory: Workflows
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - template#view
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
- directory: Workflows/DORA
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - template#view
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
- directory: Workflows/Terraform
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - template#view
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
- directory: Workflows/ArgoCD
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - template#view
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
- directory: Workflows/AWS
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - template#view
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
- directory: Workflows/Helm
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - template#view
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
- directory: Workflows/Secret Management
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - template#view
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
- directory: Workflows/Azure
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - template#view
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
- directory: Workflows/Release runner
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - template#view
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
- directory: Workflows/Digital.ai Deploy
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - template#view
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
- directory: Templates
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - release#start
    - release#view
    - template#create_release
    - template#view
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
- directory: Templates/Governance Pipeline
  teams:
  - name: Viewer
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - release#start
    - release#view
    - template#create_release
    - template#view
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Folder Owner
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
- directory: Workflow Executions
  teams:
  - name: Template Owner
    permissions:
    - template#edit_failure_handler
    - template#edit_precondition
    - template#lock_task
  - name: Folder Owner
  - name: Release Admin
    permissions:
    - release#edit_failure_handler
    - release#edit_precondition
    - release#lock_task
  - name: Workflow Admin
    roles:
    - Authenticated Users
    permissions:
    - folder#view
    - workflow#start_execution
